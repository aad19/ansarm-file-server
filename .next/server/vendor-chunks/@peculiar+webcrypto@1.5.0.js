"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar+webcrypto@1.5.0";
exports.ids = ["vendor-chunks/@peculiar+webcrypto@1.5.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@peculiar+webcrypto@1.5.0/node_modules/@peculiar/webcrypto/build/webcrypto.es.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+webcrypto@1.5.0/node_modules/@peculiar/webcrypto/build/webcrypto.es.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Crypto: () => (/* binding */ Crypto),\n/* harmony export */   CryptoKey: () => (/* reexport safe */ webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoKey)\n/* harmony export */ });\n/* harmony import */ var webcrypto_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webcrypto-core */ \"(rsc)/./node_modules/.pnpm/webcrypto-core@1.8.1/node_modules/webcrypto-core/build/webcrypto-core.es.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/./node_modules/.pnpm/@peculiar+json-schema@1.1.12/node_modules/@peculiar/json-schema/build/index.es.js\");\n/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/.pnpm/pvtsutils@1.3.6/node_modules/pvtsutils/build/index.es.js\");\n/* harmony import */ var _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/./node_modules/.pnpm/@peculiar+asn1-schema@2.3.15/node_modules/@peculiar/asn1-schema/build/es2015/index.js\");\n/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nconst JsonBase64UrlConverter = {\n    fromJSON: (value) => buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.FromBase64Url(value)),\n    toJSON: (value) => pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64Url(value),\n};\n\nclass CryptoKey extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0);\n        this.algorithm = { name: \"\" };\n        this.extractable = false;\n        this.type = \"secret\";\n        this.usages = [];\n        this.kty = \"oct\";\n        this.alg = \"\";\n    }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ name: \"ext\", type: _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonPropTypes.Boolean, optional: true })\n], CryptoKey.prototype, \"extractable\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ name: \"key_ops\", type: _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonPropTypes.String, repeated: true, optional: true })\n], CryptoKey.prototype, \"usages\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ type: _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonPropTypes.String })\n], CryptoKey.prototype, \"kty\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ type: _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonPropTypes.String, optional: true })\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.kty = \"oct\";\n        this.type = \"secret\";\n    }\n}\n\nclass AsymmetricKey extends CryptoKey {\n}\n\nclass AesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch (this.algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return `A${this.algorithm.length}CBC`;\n            case \"AES-CTR\":\n                return `A${this.algorithm.length}CTR`;\n            case \"AES-GCM\":\n                return `A${this.algorithm.length}GCM`;\n            case \"AES-KW\":\n                return `A${this.algorithm.length}KW`;\n            case \"AES-CMAC\":\n                return `A${this.algorithm.length}CMAC`;\n            case \"AES-ECB\":\n                return `A${this.algorithm.length}ECB`;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {\n    }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ name: \"k\", converter: JsonBase64UrlConverter })\n], AesCryptoKey.prototype, \"data\", void 0);\n\nclass AesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new AesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto__WEBPACK_IMPORTED_MODULE_2___default().randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\n                break;\n            case \"raw\":\n                key = new AesCryptoKey();\n                key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(keyData);\n                break;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.algorithm.length = key.data.length << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        switch (key.algorithm.length) {\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"keyData: Is wrong key length\");\n        }\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return this.encryptAesCBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-CTR\":\n                return this.encryptAesCTR(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-GCM\":\n                return this.encryptAesGCM(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-KW\":\n                return this.encryptAesKW(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-ECB\":\n                return this.encryptAesECB(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch (algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return this.decryptAesCBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-CTR\":\n                return this.decryptAesCTR(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-GCM\":\n                return this.decryptAesGCM(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-KW\":\n                return this.decryptAesKW(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"AES-ECB\":\n                return this.decryptAesECB(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptAesCBC(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCBC(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesCTR(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.counter));\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCTR(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesGCM(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.iv), {\n            authTagLength: (algorithm.tagLength || 128) >> 3,\n        });\n        if (algorithm.additionalData) {\n            cipher.setAAD(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.additionalData));\n        }\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesGCM(algorithm, key, data) {\n        const tagLength = (algorithm.tagLength || 128) >> 3;\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv), {\n            authTagLength: tagLength,\n        });\n        const enc = data.slice(0, data.length - tagLength);\n        const tag = data.slice(data.length - tagLength);\n        if (algorithm.additionalData) {\n            decipher.setAAD(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.additionalData));\n        }\n        decipher.setAuthTag(tag);\n        let dec = decipher.update(enc);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesKW(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        return new Uint8Array(enc).buffer;\n    }\n    static async decryptAesKW(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesECB(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesECB(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nAesCrypto.AES_KW_IV = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nconst keyStorage = new WeakMap();\nfunction getCryptoKey(key) {\n    const res = keyStorage.get(key);\n    if (!res) {\n        throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"Cannot get CryptoKey from secure storage\");\n    }\n    return res;\n}\nfunction setCryptoKey(value) {\n    const key = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\n    Object.freeze(key);\n    keyStorage.set(key, value);\n    return key;\n}\n\nclass AesCbcProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesCbcProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nconst zero = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst rb = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\nconst blockSize = 16;\nfunction bitShiftLeft(buffer) {\n    const shifted = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(buffer.length);\n    const last = buffer.length - 1;\n    for (let index = 0; index < last; index++) {\n        shifted[index] = buffer[index] << 1;\n        if (buffer[index + 1] & 0x80) {\n            shifted[index] += 0x01;\n        }\n    }\n    shifted[last] = buffer[last] << 1;\n    return shifted;\n}\nfunction xor(a, b) {\n    const length = Math.min(a.length, b.length);\n    const output = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(length);\n    for (let index = 0; index < length; index++) {\n        output[index] = a[index] ^ b[index];\n    }\n    return output;\n}\nfunction aes(key, message) {\n    const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`aes${key.length << 3}`, key, zero);\n    const result = cipher.update(message);\n    cipher.final();\n    return result;\n}\nfunction getMessageBlock(message, blockIndex) {\n    const block = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = start + blockSize;\n    message.copy(block, 0, start, end);\n    return block;\n}\nfunction getPaddedMessageBlock(message, blockIndex) {\n    const block = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = message.length;\n    block.fill(0);\n    message.copy(block, 0, start, end);\n    block[end - start] = 0x80;\n    return block;\n}\nfunction generateSubkeys(key) {\n    const l = aes(key, zero);\n    let subkey1 = bitShiftLeft(l);\n    if (l[0] & 0x80) {\n        subkey1 = xor(subkey1, rb);\n    }\n    let subkey2 = bitShiftLeft(subkey1);\n    if (subkey1[0] & 0x80) {\n        subkey2 = xor(subkey2, rb);\n    }\n    return { subkey1, subkey2 };\n}\nfunction aesCmac(key, message) {\n    const subkeys = generateSubkeys(key);\n    let blockCount = Math.ceil(message.length / blockSize);\n    let lastBlockCompleteFlag;\n    let lastBlock;\n    if (blockCount === 0) {\n        blockCount = 1;\n        lastBlockCompleteFlag = false;\n    }\n    else {\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\n    }\n    const lastBlockIndex = blockCount - 1;\n    if (lastBlockCompleteFlag) {\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n    }\n    else {\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n    }\n    let x = zero;\n    let y;\n    for (let index = 0; index < lastBlockIndex; index++) {\n        y = xor(x, getMessageBlock(message, index));\n        x = aes(key, y);\n    }\n    y = xor(lastBlock, x);\n    return aes(key, y);\n}\nclass AesCmacProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesCmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const result = aesCmac(getCryptoKey(key).data, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        return new Uint8Array(result).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const signature2 = await this.sign(algorithm, key, data);\n        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signature).compare(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signature2)) === 0;\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesCtrProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesCtrProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesGcmProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesGcmProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesKwProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesKwProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesEcbProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AesEcbProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass DesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch (this.algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return `DES-CBC`;\n            case \"DES-EDE3-CBC\":\n                return `3DES-CBC`;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {\n    }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ name: \"k\", converter: JsonBase64UrlConverter })\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new DesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto__WEBPACK_IMPORTED_MODULE_2___default().randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\n                break;\n            case \"raw\":\n                key = new DesCryptoKey();\n                key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(keyData);\n                break;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return this.encryptDesCBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.encryptDesEDE3CBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof DesCryptoKey)) {\n            throw new Error(\"key: Is not DesCryptoKey\");\n        }\n        switch (algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return this.decryptDesCBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.decryptDesEDE3CBC(algorithm, key, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptDesCBC(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesCBC(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptDesEDE3CBC(algorithm, key, data) {\n        const cipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createCipheriv(`des-ede3-cbc`, key.data, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesEDE3CBC(algorithm, key, data) {\n        const decipher = crypto__WEBPACK_IMPORTED_MODULE_2___default().createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n}\n\nclass DesCbcProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.DesProvider {\n    constructor() {\n        super(...arguments);\n        this.keySizeBits = 64;\n        this.ivSize = 8;\n        this.name = \"DES-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\n        if (key.data.length !== (this.keySizeBits >> 3)) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\n\nclass DesEde3CbcProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.DesProvider {\n    constructor() {\n        super(...arguments);\n        this.keySizeBits = 192;\n        this.ivSize = 8;\n        this.name = \"DES-EDE3-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\n        if (key.data.length !== (this.keySizeBits >> 3)) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\n\nfunction getJwkAlgorithm(algorithm) {\n    switch (algorithm.name.toUpperCase()) {\n        case \"RSA-OAEP\": {\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n        }\n        case \"RSASSA-PKCS1-V1_5\":\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PSS\":\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PKCS1\":\n            return `RS1`;\n        default:\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n    }\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n        return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(json, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPrivateKey });\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(key);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n    }\n}\n\nclass RsaPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n        return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.publicKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPublicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(json, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPublicKey });\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(key);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n    }\n}\n\nclass RsaCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new RsaPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new RsaPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const publicExponent = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([\n            buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\n            buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(algorithm.publicExponent),\n        ]).readInt32BE(0);\n        const keys = crypto__WEBPACK_IMPORTED_MODULE_2___default().generateKeyPairSync(\"rsa\", {\n            modulusLength: algorithm.modulusLength,\n            publicExponent,\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    const asnKey = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPublicKey });\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            }\n            case \"spki\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n                const asnKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.publicKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPublicKey);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n                const asnKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.RsaPrivateKey);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async sign(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.signRsa(algorithm, key, data);\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async verify(algorithm, key, signature, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.verifySSA(algorithm, key, data, signature);\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-OAEP\":\n                return this.encryptOAEP(algorithm, key, data);\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-OAEP\":\n                return this.decryptOAEP(algorithm, key, data);\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(asnKey);\n        const key = new RsaPrivateKey();\n        key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(asnKey);\n        const key = new RsaPublicKey();\n        key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getCryptoAlgorithm(alg) {\n        switch (alg.hash.name.toUpperCase()) {\n            case \"SHA-1\":\n                return \"RSA-SHA1\";\n            case \"SHA-256\":\n                return \"RSA-SHA256\";\n            case \"SHA-384\":\n                return \"RSA-SHA384\";\n            case \"SHA-512\":\n                return \"RSA-SHA512\";\n            case \"SHA3-256\":\n                return \"RSA-SHA3-256\";\n            case \"SHA3-384\":\n                return \"RSA-SHA3-384\";\n            case \"SHA3-512\":\n                return \"RSA-SHA3-512\";\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"algorithm.hash: Is not recognized\");\n        }\n    }\n    static signRsa(algorithm, key, data) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto__WEBPACK_IMPORTED_MODULE_2___default().createSign(cryptoAlg);\n        signer.update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const signature = signer.sign(options);\n        return new Uint8Array(signature).buffer;\n    }\n    static verifySSA(algorithm, key, data, signature) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto__WEBPACK_IMPORTED_MODULE_2___default().createVerify(cryptoAlg);\n        signer.update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const ok = signer.verify(options, signature);\n        return ok;\n    }\n    static encryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n            padding: (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_PKCS1_OAEP_PADDING,\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto__WEBPACK_IMPORTED_MODULE_2___default().publicEncrypt(options, data)).buffer;\n    }\n    static decryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n            padding: (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_PKCS1_OAEP_PADDING,\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto__WEBPACK_IMPORTED_MODULE_2___default().privateDecrypt(options, data)).buffer;\n    }\n}\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.RsaSsaProvider {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\n\nclass RsaPssProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.RsaPssProvider {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\n\nclass ShaCrypto {\n    static size(algorithm) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"SHA-1\":\n                return 160;\n            case \"SHA-256\":\n            case \"SHA3-256\":\n                return 256;\n            case \"SHA-384\":\n            case \"SHA3-384\":\n                return 384;\n            case \"SHA-512\":\n            case \"SHA3-512\":\n                return 512;\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static getAlgorithmName(algorithm) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"SHA-1\":\n                return \"sha1\";\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            case \"SHA-512\":\n                return \"sha512\";\n            case \"SHA3-256\":\n                return \"sha3-256\";\n            case \"SHA3-384\":\n                return \"sha3-384\";\n            case \"SHA3-512\":\n                return \"sha3-512\";\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static digest(algorithm, data) {\n        const hashAlg = this.getAlgorithmName(algorithm);\n        const hash = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(hashAlg)\n            .update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\n\nclass RsaOaepProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.RsaOaepProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onEncrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const dataView = new Uint8Array(data);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = dataView.byteLength;\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\n        if (dataLength > keySize - 2 * hashSize - 2) {\n            throw new Error(\"Data too large\");\n        }\n        const message = new Uint8Array(keySize);\n        const seed = message.subarray(1, hashSize + 1);\n        const dataBlock = message.subarray(hashSize + 1);\n        dataBlock.set(dataView, hashSize + psLength + 1);\n        const labelHash = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\n            .update(webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\n            .digest();\n        dataBlock.set(labelHash, 0);\n        dataBlock[hashSize + psLength] = 1;\n        crypto__WEBPACK_IMPORTED_MODULE_2___default().randomFillSync(seed);\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for (let i = 0; i < dataBlock.length; i++) {\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for (let i = 0; i < seed.length; i++) {\n            seed[i] ^= seedMask[i];\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const pkcs0 = crypto__WEBPACK_IMPORTED_MODULE_2___default().publicEncrypt({\n            key: internalKey.pem,\n            padding: (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_NO_PADDING,\n        }, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(message));\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = data.byteLength;\n        if (dataLength !== keySize) {\n            throw new Error(\"Bad data\");\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        let pkcs0 = crypto__WEBPACK_IMPORTED_MODULE_2___default().privateDecrypt({\n            key: internalKey.pem,\n            padding: (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_NO_PADDING,\n        }, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        const z = pkcs0[0];\n        const seed = pkcs0.subarray(1, hashSize + 1);\n        const dataBlock = pkcs0.subarray(hashSize + 1);\n        if (z !== 0) {\n            throw new Error(\"Decryption failed\");\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for (let i = 0; i < seed.length; i++) {\n            seed[i] ^= seedMask[i];\n        }\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for (let i = 0; i < dataBlock.length; i++) {\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const labelHash = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\n            .update(webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\n            .digest();\n        for (let i = 0; i < hashSize; i++) {\n            if (labelHash[i] !== dataBlock[i]) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        let psEnd = hashSize;\n        for (; psEnd < dataBlock.length; psEnd++) {\n            const psz = dataBlock[psEnd];\n            if (psz === 1) {\n                break;\n            }\n            if (psz !== 0) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        if (psEnd === dataBlock.length) {\n            throw new Error(\"Decryption failed\");\n        }\n        pkcs0 = dataBlock.subarray(psEnd + 1);\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    mgf1(algorithm, seed, length = 0) {\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\n        const mask = new Uint8Array(length);\n        const counter = new Uint8Array(4);\n        const chunks = Math.ceil(length / hashSize);\n        for (let i = 0; i < chunks; i++) {\n            counter[0] = i >>> 24;\n            counter[1] = (i >>> 16) & 255;\n            counter[2] = (i >>> 8) & 255;\n            counter[3] = i & 255;\n            const submask = mask.subarray(i * hashSize);\n            let chunk = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(algorithm.name.replace(\"-\", \"\"))\n                .update(seed)\n                .update(counter)\n                .digest();\n            if (chunk.length > submask.length) {\n                chunk = chunk.subarray(0, submask.length);\n            }\n            submask.set(chunk);\n        }\n        return mask;\n    }\n}\n\nclass RsaEsProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSAES-PKCS1-v1_5\";\n        this.usages = {\n            publicKey: [\"encrypt\", \"wrapKey\"],\n            privateKey: [\"decrypt\", \"unwrapKey\"],\n        };\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        switch (algorithm.modulusLength) {\n            case 1024:\n            case 2048:\n            case 4096:\n                break;\n            default:\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n        }\n    }\n    async onEncrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const enc = crypto__WEBPACK_IMPORTED_MODULE_2___default().publicEncrypt(options, new Uint8Array(data));\n        return new Uint8Array(enc).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const dec = crypto__WEBPACK_IMPORTED_MODULE_2___default().privateDecrypt(options, new Uint8Array(data));\n        return new Uint8Array(dec).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    toCryptoOptions(key) {\n        const type = key.type.toUpperCase();\n        return {\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n            padding: (crypto__WEBPACK_IMPORTED_MODULE_2___default().constants).RSA_PKCS1_PADDING,\n        };\n    }\n}\n\nconst namedOIDs = {\n    \"1.2.840.10045.3.1.7\": \"P-256\",\n    \"P-256\": \"1.2.840.10045.3.1.7\",\n    \"1.3.132.0.34\": \"P-384\",\n    \"P-384\": \"1.3.132.0.34\",\n    \"1.3.132.0.35\": \"P-521\",\n    \"P-521\": \"1.3.132.0.35\",\n    \"1.3.132.0.10\": \"K-256\",\n    \"K-256\": \"1.3.132.0.10\",\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\",\n};\nfunction getOidByNamedCurve$1(namedCurve) {\n    const oid = namedOIDs[namedCurve];\n    if (!oid) {\n        throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\n\nclass EcPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n        return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        const key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(json, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPrivateKey });\n        keyInfo.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(key);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EcPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n        return new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPublicKey(keyInfo.publicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(json, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPublicKey });\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.publicKeyAlgorithm.parameters = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        keyInfo.publicKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.toASN(key).valueHex;\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass Sha1Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-1\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha256Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha384Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha512Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3256Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3384Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3512Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass EcCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EcPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EcPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const keys = crypto__WEBPACK_IMPORTED_MODULE_2___default().generateKeyPairSync(\"ec\", {\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto__WEBPACK_IMPORTED_MODULE_2___default().createSign(cryptoAlg);\n        signer.update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const signature = signer.sign(options);\n        const ecSignature = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(signature, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcDsaSignature);\n        const signatureRaw = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcUtils.encodeSignature(ecSignature, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcCurves.get(key.algorithm.namedCurve).size);\n        return signatureRaw.buffer;\n    }\n    static async verify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto__WEBPACK_IMPORTED_MODULE_2___default().createVerify(cryptoAlg);\n        signer.update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const ecSignature = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcDsaSignature();\n        const namedCurve = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcCurves.get(key.algorithm.namedCurve);\n        const signaturePoint = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcUtils.decodeSignature(signature, namedCurve.size);\n        ecSignature.r = pvtsutils__WEBPACK_IMPORTED_MODULE_5__.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\n        ecSignature.s = pvtsutils__WEBPACK_IMPORTED_MODULE_5__.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\n        const ecSignatureRaw = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(ecSignature));\n        const ok = signer.verify(options, ecSignatureRaw);\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n        const ecdh = crypto__WEBPACK_IMPORTED_MODULE_2___default().createECDH(cryptoAlg);\n        const asnPrivateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(baseKey.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n        const asnEcPrivateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(asnPrivateKey.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPrivateKey);\n        ecdh.setPrivateKey(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(asnEcPrivateKey.privateKey));\n        const asnPublicKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(algorithm.public.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n        const bits = ecdh.computeSecret(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(asnPublicKey.publicKey));\n        if (length === null) {\n            return bits;\n        }\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\": {\n                const publicKeyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(key.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n                return publicKeyInfo.publicKey;\n            }\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    const asnKey = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPublicKey });\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            }\n            case \"raw\": {\n                const asnKey = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPublicKey(keyData);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"spki\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n                const asnKey = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPublicKey(keyInfo.publicKey);\n                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n                const asnKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EcPrivateKey);\n                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static assertKeyParameters(parameters, namedCurve) {\n        if (!parameters) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoError(\"Key info doesn't have required parameters\");\n        }\n        let namedCurveIdentifier = \"\";\n        try {\n            namedCurveIdentifier = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(parameters, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.ObjectIdentifier).value;\n        }\n        catch (e) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoError(\"Cannot read key info parameters\");\n        }\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.CryptoError(\"Key info parameter doesn't match to named curve\");\n        }\n    }\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\n        keyInfo.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(asnKey);\n        const key = new EcPrivateKey();\n        key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\n        keyInfo.publicKeyAlgorithm.parameters = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.ObjectIdentifier(namedCurve));\n        keyInfo.publicKey = asnKey.value;\n        const key = new EcPublicKey();\n        key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getOpenSSLNamedCurve(curve) {\n        switch (curve.toUpperCase()) {\n            case \"P-256\":\n                return \"prime256v1\";\n            case \"K-256\":\n                return \"secp256k1\";\n            case \"P-384\":\n                return \"secp384r1\";\n            case \"P-521\":\n                return \"secp521r1\";\n            default:\n                return curve;\n        }\n    }\n}\nEcCrypto.publicKeyUsages = [\"verify\"];\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcdsaProvider {\n    constructor() {\n        super(...arguments);\n        this.namedCurves = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcCurves.names;\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n}\n\nclass EcdhProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcdhProvider {\n    constructor() {\n        super(...arguments);\n        this.namedCurves = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcCurves.names;\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n}\n\nconst edOIDs = {\n    [webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idEd448]: \"Ed448\",\n    \"ed448\": webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idEd448,\n    [webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idX448]: \"X448\",\n    \"x448\": webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idX448,\n    [webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idEd25519]: \"Ed25519\",\n    \"ed25519\": webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idEd25519,\n    [webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idX25519]: \"X25519\",\n    \"x25519\": webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idX25519,\n};\nfunction getOidByNamedCurve(namedCurve) {\n    const oid = edOIDs[namedCurve.toLowerCase()];\n    if (!oid) {\n        throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\n\nclass EdPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n        return _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.CurvePrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        const key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(json, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.CurvePrivateKey });\n        keyInfo.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(key);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EdPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(this.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n        return keyInfo.publicKey;\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, {\n            x: pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64Url(key)\n        });\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        if (!json.x) {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(`Cannot get property from JWK. Property 'x' is required`);\n        }\n        const keyInfo = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        keyInfo.publicKey = pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.FromBase64Url(json.x);\n        this.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EdCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EdPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EdPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const type = algorithm.namedCurve.toLowerCase();\n        const keys = crypto__WEBPACK_IMPORTED_MODULE_2___default().generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const signature = crypto__WEBPACK_IMPORTED_MODULE_2___default().sign(null, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data), options);\n        return webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const ok = crypto__WEBPACK_IMPORTED_MODULE_2___default().verify(null, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data), options, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signature));\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const publicKey = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n            key: algorithm.public.data,\n            format: \"der\",\n            type: \"spki\",\n        });\n        const privateKey = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPrivateKey({\n            key: baseKey.data,\n            format: \"der\",\n            type: \"pkcs8\",\n        });\n        const bits = crypto__WEBPACK_IMPORTED_MODULE_2___default().diffieHellman({\n            publicKey,\n            privateKey,\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\": {\n                const publicKeyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(key.data, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n                return publicKeyInfo.publicKey;\n            }\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.CurvePrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    if (!jwk.x) {\n                        throw new TypeError(\"keyData: Cannot get required 'x' filed\");\n                    }\n                    return this.importPublicKey(pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\n                }\n            }\n            case \"raw\": {\n                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\n            }\n            case \"spki\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PublicKeyInfo);\n                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(new Uint8Array(keyData), webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n                const asnKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnParser.parse(keyInfo.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.CurvePrivateKey);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPrivateKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            d: pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64Url(asnKey.d),\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPublicKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            x: pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64Url(asnKey),\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n}\nEdCrypto.publicKeyUsages = [\"verify\"];\nEdCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EdDsaProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EdDsaProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\"),\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\n\nclass EcdhEsProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.EcdhEsProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.toUpperCase(),\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\n\nclass Ed25519CryptoKey extends CryptoKey {\n    constructor(algorithm, extractable, usages, data) {\n        super();\n        this.algorithm = algorithm;\n        this.extractable = extractable;\n        this.usages = usages;\n        this.data = Buffer.from(data);\n    }\n    toJWK() {\n        return {\n            kty: \"OKP\",\n            crv: this.algorithm.name,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n    }\n}\n\nclass Ed25519PrivateKey extends Ed25519CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    toJWK() {\n        const pubJwk = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n            key: this.data,\n            format: \"pem\",\n        }).export({ format: \"jwk\" });\n        const raw = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.toUint8Array(this.data.toString());\n        const pkcs8 = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnConvert.parse(raw, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo);\n        const d = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnConvert.parse(pkcs8.privateKey, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EdPrivateKey).value;\n        return {\n            ...super.toJWK(),\n            ...pubJwk,\n            d: Buffer.from(new Uint8Array(d)).toString(\"base64url\"),\n        };\n    }\n}\n\nclass Ed25519PublicKey extends Ed25519CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    toJWK() {\n        const jwk = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n            key: this.data,\n            format: \"pem\",\n        }).export({ format: \"jwk\" });\n        return {\n            ...super.toJWK(),\n            ...jwk,\n        };\n    }\n}\n\nclass Ed25519Crypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const type = algorithm.name.toLowerCase();\n        const keys = crypto__WEBPACK_IMPORTED_MODULE_2___default().generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"pem\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"pem\",\n                type: \"pkcs8\",\n            },\n        });\n        const keyAlg = {\n            name: type === \"ed25519\" ? \"Ed25519\" : \"X25519\",\n        };\n        const privateKeyUsages = keyUsages.filter((usage) => this.privateKeyUsages.includes(usage));\n        const publicKeyUsages = keyUsages.filter((usage) => this.publicKeyUsages.includes(usage));\n        return {\n            privateKey: new Ed25519PrivateKey(keyAlg, extractable, privateKeyUsages, keys.privateKey),\n            publicKey: new Ed25519PublicKey(keyAlg, true, publicKeyUsages, keys.publicKey),\n        };\n    }\n    static async sign(algorithm, key, data) {\n        const signature = crypto__WEBPACK_IMPORTED_MODULE_2___default().sign(null, Buffer.from(data), key.data);\n        return webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        return crypto__WEBPACK_IMPORTED_MODULE_2___default().verify(null, Buffer.from(data), key.data, signature);\n    }\n    static async exportKey(format, key) {\n        switch (format) {\n            case \"jwk\":\n                return key.toJWK();\n            case \"pkcs8\": {\n                return webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.toArrayBuffer(key.data.toString());\n            }\n            case \"spki\": {\n                return webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.toArrayBuffer(key.data.toString());\n            }\n            case \"raw\": {\n                const jwk = key.toJWK();\n                return pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.FromBase64Url(jwk.x);\n            }\n            default:\n                return Promise.reject(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\"));\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const privateData = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.EdPrivateKey();\n                    privateData.value = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toArrayBuffer(Buffer.from(jwk.d, \"base64url\"));\n                    const pkcs8 = new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.PrivateKeyInfo();\n                    pkcs8.privateKeyAlgorithm.algorithm = algorithm.name.toLowerCase() === \"ed25519\"\n                        ? webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idEd25519\n                        : webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.asn1.idX25519;\n                    pkcs8.privateKey = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnConvert.serialize(privateData);\n                    const raw = _peculiar_asn1_schema__WEBPACK_IMPORTED_MODULE_6__.AsnConvert.serialize(pkcs8);\n                    const pem = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.fromBufferSource(raw, \"PRIVATE KEY\");\n                    return new Ed25519PrivateKey(algorithm, extractable, keyUsages, pem);\n                }\n                else if (jwk.x) {\n                    const pubKey = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n                        format: \"jwk\",\n                        key: jwk,\n                    });\n                    const pem = pubKey.export({ format: \"pem\", type: \"spki\" });\n                    return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n                }\n                else {\n                    throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"keyData: Cannot import JWK. 'd' or 'x' must be presented\");\n                }\n            }\n            case \"pkcs8\": {\n                const pem = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.fromBufferSource(keyData, \"PRIVATE KEY\");\n                return new Ed25519PrivateKey(algorithm, extractable, keyUsages, pem);\n            }\n            case \"spki\": {\n                const pem = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.PemConverter.fromBufferSource(keyData, \"PUBLIC KEY\");\n                return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n            }\n            case \"raw\": {\n                const raw = keyData;\n                const key = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n                    format: \"jwk\",\n                    key: {\n                        kty: \"OKP\",\n                        crv: algorithm.name.toLowerCase() === \"ed25519\" ? \"Ed25519\" : \"X25519\",\n                        x: pvtsutils__WEBPACK_IMPORTED_MODULE_5__.Convert.ToBase64Url(raw),\n                    },\n                });\n                const pem = key.export({ format: \"pem\", type: \"spki\" });\n                return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n            }\n            default:\n                return Promise.reject(new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\"));\n        }\n    }\n}\nEd25519Crypto.privateKeyUsages = [\"sign\", \"deriveBits\", \"deriveKey\"];\nEd25519Crypto.publicKeyUsages = [\"verify\"];\n\nclass Ed25519Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.Ed25519Provider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await Ed25519Crypto.generateKey(algorithm, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const signature = Ed25519Crypto.sign(algorithm, internalKey, new Uint8Array(data));\n        return signature;\n    }\n    onVerify(algorithm, key, signature, data) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.verify(algorithm, internalKey, new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.exportKey(format, internalKey);\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const internalKey = await Ed25519Crypto.importKey(format, keyData, algorithm, extractable, keyUsages);\n        return setCryptoKey(internalKey);\n    }\n}\n\nclass X25519Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.X25519Provider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await Ed25519Crypto.generateKey(algorithm, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const internalBaseKey = getCryptoKey(baseKey);\n        const internalPublicKey = getCryptoKey(algorithm.public);\n        const publicKey = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPublicKey({\n            key: internalPublicKey.data.toString(),\n            format: \"pem\",\n            type: \"spki\",\n        });\n        const privateKey = crypto__WEBPACK_IMPORTED_MODULE_2___default().createPrivateKey({\n            key: internalBaseKey.data.toString(),\n            format: \"pem\",\n            type: \"pkcs8\",\n        });\n        const bits = crypto__WEBPACK_IMPORTED_MODULE_2___default().diffieHellman({\n            publicKey,\n            privateKey,\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    async onExportKey(format, key) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.exportKey(format, internalKey);\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await Ed25519Crypto.importKey(format, keyData, algorithm, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof Ed25519CryptoKey)) {\n            throw new TypeError(\"key: Is not a Ed25519CryptoKey\");\n        }\n    }\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\n}\n\nclass Pbkdf2Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.Pbkdf2Provider {\n    async onDeriveBits(algorithm, baseKey, length) {\n        return new Promise((resolve, reject) => {\n            const salt = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toArrayBuffer(algorithm.salt);\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\n            crypto__WEBPACK_IMPORTED_MODULE_2___default().pbkdf2(getCryptoKey(baseKey).data, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(new Uint8Array(derivedBits).buffer);\n                }\n            });\n        });\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format === \"raw\") {\n            const key = new PbkdfCryptoKey();\n            key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(keyData);\n            key.algorithm = { name: this.name };\n            key.extractable = false;\n            key.usages = keyUsages;\n            return setCryptoKey(key);\n        }\n        throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'raw'\");\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n        }\n    }\n}\n\nclass HmacCryptoKey extends CryptoKey {\n    get alg() {\n        const hash = this.algorithm.hash.name.toUpperCase();\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\n    }\n    set alg(value) {\n    }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([\n    (0,_peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonProp)({ name: \"k\", converter: JsonBase64UrlConverter })\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.HmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\n        const key = new HmacCryptoKey();\n        key.algorithm = {\n            ...algorithm,\n            length,\n            name: this.name,\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto__WEBPACK_IMPORTED_MODULE_2___default().randomBytes(length >> 3);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHmac(cryptoAlg, getCryptoKey(key).data)\n            .update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data)).digest();\n        return new Uint8Array(hmac).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHmac(cryptoAlg, getCryptoKey(key).data)\n            .update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data)).digest();\n        return hmac.compare(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signature)) === 0;\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\n                break;\n            case \"raw\":\n                key = new HmacCryptoKey();\n                key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(keyData);\n                break;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = {\n            hash: { name: algorithm.hash.name },\n            name: this.name,\n            length: key.data.length << 3,\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onExportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return _peculiar_json_schema__WEBPACK_IMPORTED_MODULE_4__.JsonSerializer.toJSON(getCryptoKey(key));\n            case \"raw\":\n                return new Uint8Array(getCryptoKey(key).data).buffer;\n            default:\n                throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\n        }\n    }\n}\n\nclass HkdfCryptoKey extends CryptoKey {\n}\n\nclass HkdfProvider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.HkdfProvider {\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format.toLowerCase() !== \"raw\") {\n            throw new webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.OperationError(\"Operation not supported\");\n        }\n        const key = new HkdfCryptoKey();\n        key.data = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(keyData);\n        key.algorithm = { name: this.name };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onDeriveBits(params, baseKey, length) {\n        const hash = params.hash.name.replace(\"-\", \"\");\n        const hashLength = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(hash).digest().length;\n        const byteLength = length / 8;\n        const info = webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(params.info);\n        const PRK = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHmac(hash, webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(params.salt))\n            .update(webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))\n            .digest();\n        const blocks = [buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.alloc(0)];\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\n        for (let i = 1; i < blockCount; ++i) {\n            blocks.push(crypto__WEBPACK_IMPORTED_MODULE_2___default().createHmac(hash, PRK)\n                .update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([blocks[i - 1], info, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from([i])]))\n                .digest());\n        }\n        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat(blocks).slice(0, byteLength);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\n        }\n    }\n}\n\nclass ShakeCrypto {\n    static digest(algorithm, data) {\n        const hash = crypto__WEBPACK_IMPORTED_MODULE_2___default().createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })\n            .update(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\n\nclass Shake128Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.Shake128Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\n\nclass Shake256Provider extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.Shake256Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\n\nclass SubtleCrypto extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.SubtleCrypto {\n    constructor() {\n        var _a;\n        super();\n        this.providers.set(new AesCbcProvider());\n        this.providers.set(new AesCtrProvider());\n        this.providers.set(new AesGcmProvider());\n        this.providers.set(new AesCmacProvider());\n        this.providers.set(new AesKwProvider());\n        this.providers.set(new AesEcbProvider());\n        const ciphers = crypto__WEBPACK_IMPORTED_MODULE_2___default().getCiphers();\n        if (ciphers.includes(\"des-cbc\")) {\n            this.providers.set(new DesCbcProvider());\n        }\n        this.providers.set(new DesEde3CbcProvider());\n        this.providers.set(new RsaSsaProvider());\n        this.providers.set(new RsaPssProvider());\n        this.providers.set(new RsaOaepProvider());\n        this.providers.set(new RsaEsProvider());\n        this.providers.set(new EcdsaProvider());\n        this.providers.set(new EcdhProvider());\n        this.providers.set(new Sha1Provider());\n        this.providers.set(new Sha256Provider());\n        this.providers.set(new Sha384Provider());\n        this.providers.set(new Sha512Provider());\n        this.providers.set(new Pbkdf2Provider());\n        this.providers.set(new HmacProvider());\n        this.providers.set(new HkdfProvider());\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__WEBPACK_IMPORTED_MODULE_3__.version)) === null || _a === void 0 ? void 0 : _a[1];\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\n            this.providers.set(new Shake128Provider());\n            this.providers.set(new Shake256Provider());\n        }\n        const hashes = crypto__WEBPACK_IMPORTED_MODULE_2___default().getHashes();\n        if (hashes.includes(\"sha3-256\")) {\n            this.providers.set(new Sha3256Provider());\n        }\n        if (hashes.includes(\"sha3-384\")) {\n            this.providers.set(new Sha3384Provider());\n        }\n        if (hashes.includes(\"sha3-512\")) {\n            this.providers.set(new Sha3512Provider());\n        }\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\n            this.providers.set(new EdDsaProvider());\n            this.providers.set(new EcdhEsProvider());\n            this.providers.set(new Ed25519Provider());\n            this.providers.set(new X25519Provider());\n        }\n    }\n}\n\nclass Crypto extends webcrypto_core__WEBPACK_IMPORTED_MODULE_0__.Crypto {\n    constructor() {\n        super(...arguments);\n        this.subtle = new SubtleCrypto();\n    }\n    getRandomValues(array) {\n        if (!ArrayBuffer.isView(array)) {\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\n        }\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(array.buffer, array.byteOffset, array.byteLength);\n        crypto__WEBPACK_IMPORTED_MODULE_2___default().randomFillSync(buffer);\n        return array;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBlY3VsaWFyK3dlYmNyeXB0b0AxLjUuMC9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDMkM7QUFDdkM7QUFDQztBQUNoQjtBQUNPO0FBQ0E7QUFDeUQ7QUFDakM7QUFDa0I7O0FBRTdFO0FBQ0EseUJBQXlCLDBDQUFRLE1BQU0sOENBQU87QUFDOUMsdUJBQXVCLDhDQUFPO0FBQzlCOztBQUVBLHdCQUF3QixxREFBYztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLDBDQUFRO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFVO0FBQ1YsSUFBSSwrREFBUSxHQUFHLG1CQUFtQixnRUFBYSwwQkFBMEI7QUFDekU7QUFDQSxpREFBVTtBQUNWLElBQUksK0RBQVEsR0FBRyx1QkFBdUIsZ0VBQWEseUNBQXlDO0FBQzVGO0FBQ0EsaURBQVU7QUFDVixJQUFJLCtEQUFRLEdBQUcsTUFBTSxnRUFBYSxTQUFTO0FBQzNDO0FBQ0EsaURBQVU7QUFDVixJQUFJLCtEQUFRLEdBQUcsTUFBTSxnRUFBYSx5QkFBeUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDBCQUEwQiwwREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFVO0FBQ1YsSUFBSSwr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Q3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQVE7QUFDL0IsUUFBUSw0REFBcUI7QUFDN0I7QUFDQTtBQUNBOztBQUVrQiIsInNvdXJjZXMiOlsiL2hvbWUvYWQxOS9Eb2N1bWVudHMvYW5zYXJtLWZpbGUtc2VydmVyL25vZGVfbW9kdWxlcy8ucG5wbS9AcGVjdWxpYXIrd2ViY3J5cHRvQDEuNS4wL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvd2ViY3J5cHRvL2J1aWxkL3dlYmNyeXB0by5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnd2ViY3J5cHRvLWNvcmUnO1xuaW1wb3J0IHsgQnVmZmVyU291cmNlQ29udmVydGVyIGFzIEJ1ZmZlclNvdXJjZUNvbnZlcnRlciQxIH0gZnJvbSAnd2ViY3J5cHRvLWNvcmUnO1xuZXhwb3J0IHsgQ3J5cHRvS2V5IH0gZnJvbSAnd2ViY3J5cHRvLWNvcmUnO1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlciQxIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSAncHJvY2Vzcyc7XG5pbXBvcnQgeyBfX2RlY29yYXRlIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgSnNvblByb3AsIEpzb25Qcm9wVHlwZXMsIEpzb25TZXJpYWxpemVyLCBKc29uUGFyc2VyIH0gZnJvbSAnQHBlY3VsaWFyL2pzb24tc2NoZW1hJztcbmltcG9ydCB7IENvbnZlcnQsIEJ1ZmZlclNvdXJjZUNvbnZlcnRlciB9IGZyb20gJ3B2dHN1dGlscyc7XG5pbXBvcnQgeyBBc25QYXJzZXIsIEFzblNlcmlhbGl6ZXIsIEFzbkNvbnZlcnQgfSBmcm9tICdAcGVjdWxpYXIvYXNuMS1zY2hlbWEnO1xuXG5jb25zdCBKc29uQmFzZTY0VXJsQ29udmVydGVyID0ge1xuICAgIGZyb21KU09OOiAodmFsdWUpID0+IEJ1ZmZlciQxLmZyb20oQ29udmVydC5Gcm9tQmFzZTY0VXJsKHZhbHVlKSksXG4gICAgdG9KU09OOiAodmFsdWUpID0+IENvbnZlcnQuVG9CYXNlNjRVcmwodmFsdWUpLFxufTtcblxuY2xhc3MgQ3J5cHRvS2V5IGV4dGVuZHMgY29yZS5DcnlwdG9LZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIkMS5hbGxvYygwKTtcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSB7IG5hbWU6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5leHRyYWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3JldFwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmt0eSA9IFwib2N0XCI7XG4gICAgICAgIHRoaXMuYWxnID0gXCJcIjtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBKc29uUHJvcCh7IG5hbWU6IFwiZXh0XCIsIHR5cGU6IEpzb25Qcm9wVHlwZXMuQm9vbGVhbiwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiZXh0cmFjdGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIEpzb25Qcm9wKHsgbmFtZTogXCJrZXlfb3BzXCIsIHR5cGU6IEpzb25Qcm9wVHlwZXMuU3RyaW5nLCByZXBlYXRlZDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwidXNhZ2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBKc29uUHJvcCh7IHR5cGU6IEpzb25Qcm9wVHlwZXMuU3RyaW5nIH0pXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImt0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSnNvblByb3AoeyB0eXBlOiBKc29uUHJvcFR5cGVzLlN0cmluZywgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiYWxnXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFN5bW1ldHJpY0tleSBleHRlbmRzIENyeXB0b0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcbiAgICB9XG59XG5cbmNsYXNzIEFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xufVxuXG5jbGFzcyBBZXNDcnlwdG9LZXkgZXh0ZW5kcyBTeW1tZXRyaWNLZXkge1xuICAgIGdldCBhbGcoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNCQ2A7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNUUmA7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUdDTWA7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9S1dgO1xuICAgICAgICAgICAgY2FzZSBcIkFFUy1DTUFDXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q01BQ2A7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUVDQmA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLkFsZ29yaXRobUVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGFsZyh2YWx1ZSkge1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIEpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxuXSwgQWVzQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEFlc0NyeXB0byB7XG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgQWVzQ3J5cHRvS2V5KCk7XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhhbGdvcml0aG0ubGVuZ3RoID4+IDMpO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleTogSXMgbm90IEFlc0NyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICBrZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBBZXNDcnlwdG9LZXkgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgICAgICAgICAga2V5ID0gbmV3IEFlc0NyeXB0b0tleSgpO1xuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyJDEuZnJvbShrZXlEYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XG4gICAgICAgIH1cbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAga2V5LmFsZ29yaXRobS5sZW5ndGggPSBrZXkuZGF0YS5sZW5ndGggPDwgMztcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgY2FzZSAxOTI6XG4gICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBJcyB3cm9uZyBrZXkgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ1RSXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgQWVzQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ1RSXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFwiQUVTLUVDQlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZW5jID0gQnVmZmVyJDEuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBkZWMgPSBCdWZmZXIkMS5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWN0cmAsIGtleS5kYXRhLCBCdWZmZXIkMS5mcm9tKGFsZ29yaXRobS5jb3VudGVyKSk7XG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBlbmMgPSBCdWZmZXIkMS5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLmNvdW50ZXIpKTtcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZGVjID0gQnVmZmVyJDEuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgQnVmZmVyJDEuZnJvbShhbGdvcml0aG0uaXYpLCB7XG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSB7XG4gICAgICAgICAgICBjaXBoZXIuc2V0QUFEKEJ1ZmZlciQxLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICAgIGVuYyA9IEJ1ZmZlciQxLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKSwgY2lwaGVyLmdldEF1dGhUYWcoKV0pO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFnTGVuZ3RoID0gKGFsZ29yaXRobS50YWdMZW5ndGggfHwgMTI4KSA+PiAzO1xuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZ2NtYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdiksIHtcbiAgICAgICAgICAgIGF1dGhUYWdMZW5ndGg6IHRhZ0xlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuYyA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSB0YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB0YWcgPSBkYXRhLnNsaWNlKGRhdGEubGVuZ3RoIC0gdGFnTGVuZ3RoKTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QUFEKEJ1ZmZlciQxLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyh0YWcpO1xuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGVuYyk7XG4gICAgICAgIGRlYyA9IEJ1ZmZlciQxLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGlkLWFlcyR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LXdyYXBgLCBrZXkuZGF0YSwgdGhpcy5BRVNfS1dfSVYpO1xuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZW5jID0gQnVmZmVyJDEuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBpZC1hZXMke2tleS5hbGdvcml0aG0ubGVuZ3RofS13cmFwYCwga2V5LmRhdGEsIHRoaXMuQUVTX0tXX0lWKTtcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZGVjID0gQnVmZmVyJDEuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1lY2JgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZW5jID0gQnVmZmVyJDEuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZWNiYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KDApKTtcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgZGVjID0gQnVmZmVyJDEuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xuICAgIH1cbn1cbkFlc0NyeXB0by5BRVNfS1dfSVYgPSBCdWZmZXIkMS5mcm9tKFwiQTZBNkE2QTZBNkE2QTZBNlwiLCBcImhleFwiKTtcblxuY29uc3Qga2V5U3RvcmFnZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRDcnlwdG9LZXkoa2V5KSB7XG4gICAgY29uc3QgcmVzID0ga2V5U3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcIkNhbm5vdCBnZXQgQ3J5cHRvS2V5IGZyb20gc2VjdXJlIHN0b3JhZ2VcIik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzZXRDcnlwdG9LZXkodmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBjb3JlLkNyeXB0b0tleS5jcmVhdGUodmFsdWUuYWxnb3JpdGhtLCB2YWx1ZS50eXBlLCB2YWx1ZS5leHRyYWN0YWJsZSwgdmFsdWUudXNhZ2VzKTtcbiAgICBPYmplY3QuZnJlZXplKGtleSk7XG4gICAga2V5U3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLkFlc0NiY1Byb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgemVybyA9IEJ1ZmZlciQxLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbmNvbnN0IHJiID0gQnVmZmVyJDEuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTM1XSk7XG5jb25zdCBibG9ja1NpemUgPSAxNjtcbmZ1bmN0aW9uIGJpdFNoaWZ0TGVmdChidWZmZXIpIHtcbiAgICBjb25zdCBzaGlmdGVkID0gQnVmZmVyJDEuYWxsb2MoYnVmZmVyLmxlbmd0aCk7XG4gICAgY29uc3QgbGFzdCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0OyBpbmRleCsrKSB7XG4gICAgICAgIHNoaWZ0ZWRbaW5kZXhdID0gYnVmZmVyW2luZGV4XSA8PCAxO1xuICAgICAgICBpZiAoYnVmZmVyW2luZGV4ICsgMV0gJiAweDgwKSB7XG4gICAgICAgICAgICBzaGlmdGVkW2luZGV4XSArPSAweDAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNoaWZ0ZWRbbGFzdF0gPSBidWZmZXJbbGFzdF0gPDwgMTtcbiAgICByZXR1cm4gc2hpZnRlZDtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIkMS5hbGxvYyhsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgb3V0cHV0W2luZGV4XSA9IGFbaW5kZXhdIF4gYltpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBhZXMoa2V5LCBtZXNzYWdlKSB7XG4gICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMke2tleS5sZW5ndGggPDwgM31gLCBrZXksIHplcm8pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGNpcGhlci51cGRhdGUobWVzc2FnZSk7XG4gICAgY2lwaGVyLmZpbmFsKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIkMS5hbGxvYyhibG9ja1NpemUpO1xuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGJsb2NrU2l6ZTtcbiAgICBtZXNzYWdlLmNvcHkoYmxvY2ssIDAsIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBibG9jaztcbn1cbmZ1bmN0aW9uIGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIkMS5hbGxvYyhibG9ja1NpemUpO1xuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcbiAgICBjb25zdCBlbmQgPSBtZXNzYWdlLmxlbmd0aDtcbiAgICBibG9jay5maWxsKDApO1xuICAgIG1lc3NhZ2UuY29weShibG9jaywgMCwgc3RhcnQsIGVuZCk7XG4gICAgYmxvY2tbZW5kIC0gc3RhcnRdID0gMHg4MDtcbiAgICByZXR1cm4gYmxvY2s7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVN1YmtleXMoa2V5KSB7XG4gICAgY29uc3QgbCA9IGFlcyhrZXksIHplcm8pO1xuICAgIGxldCBzdWJrZXkxID0gYml0U2hpZnRMZWZ0KGwpO1xuICAgIGlmIChsWzBdICYgMHg4MCkge1xuICAgICAgICBzdWJrZXkxID0geG9yKHN1YmtleTEsIHJiKTtcbiAgICB9XG4gICAgbGV0IHN1YmtleTIgPSBiaXRTaGlmdExlZnQoc3Via2V5MSk7XG4gICAgaWYgKHN1YmtleTFbMF0gJiAweDgwKSB7XG4gICAgICAgIHN1YmtleTIgPSB4b3Ioc3Via2V5MiwgcmIpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWJrZXkxLCBzdWJrZXkyIH07XG59XG5mdW5jdGlvbiBhZXNDbWFjKGtleSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHN1YmtleXMgPSBnZW5lcmF0ZVN1YmtleXMoa2V5KTtcbiAgICBsZXQgYmxvY2tDb3VudCA9IE1hdGguY2VpbChtZXNzYWdlLmxlbmd0aCAvIGJsb2NrU2l6ZSk7XG4gICAgbGV0IGxhc3RCbG9ja0NvbXBsZXRlRmxhZztcbiAgICBsZXQgbGFzdEJsb2NrO1xuICAgIGlmIChibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGJsb2NrQ291bnQgPSAxO1xuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxhc3RCbG9ja0NvbXBsZXRlRmxhZyA9IChtZXNzYWdlLmxlbmd0aCAlIGJsb2NrU2l6ZSA9PT0gMCk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RCbG9ja0luZGV4ID0gYmxvY2tDb3VudCAtIDE7XG4gICAgaWYgKGxhc3RCbG9ja0NvbXBsZXRlRmxhZykge1xuICAgICAgICBsYXN0QmxvY2sgPSB4b3IoZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGxhc3RCbG9ja0luZGV4KSwgc3Via2V5cy5zdWJrZXkxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRQYWRkZWRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTIpO1xuICAgIH1cbiAgICBsZXQgeCA9IHplcm87XG4gICAgbGV0IHk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxhc3RCbG9ja0luZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHkgPSB4b3IoeCwgZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGluZGV4KSk7XG4gICAgICAgIHggPSBhZXMoa2V5LCB5KTtcbiAgICB9XG4gICAgeSA9IHhvcihsYXN0QmxvY2ssIHgpO1xuICAgIHJldHVybiBhZXMoa2V5LCB5KTtcbn1cbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIGNvcmUuQWVzQ21hY1Byb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYWVzQ21hYyhnZXRDcnlwdG9LZXkoa2V5KS5kYXRhLCBCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuYnVmZmVyO1xuICAgIH1cbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZTIgPSBhd2FpdCB0aGlzLnNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gQnVmZmVyJDEuZnJvbShzaWduYXR1cmUpLmNvbXBhcmUoQnVmZmVyJDEuZnJvbShzaWduYXR1cmUyKSkgPT09IDA7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLkFlc0N0clByb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzR2NtUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLkFlc0djbVByb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzS3dQcm92aWRlciBleHRlbmRzIGNvcmUuQWVzS3dQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XG4gICAgfVxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgY29yZS5BZXNFY2JQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XG4gICAgZ2V0IGFsZygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBERVMtQ0JDYDtcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYDNERVMtQ0JDYDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuQWxnb3JpdGhtRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gbmFtZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgYWxnKHZhbHVlKSB7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXG5dLCBEZXNDcnlwdG9LZXkucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblxuY2xhc3MgRGVzQ3J5cHRvIHtcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGFsZ29yaXRobS5sZW5ndGggPj4gMyk7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBKc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgICAgICAgICAga2V5ID0gSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogRGVzQ3J5cHRvS2V5IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlciQxLmZyb20oa2V5RGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgRGVzQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyJDEuZnJvbShkYXRhKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBlbmMgPSBCdWZmZXIkMS5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICAgIGRlYyA9IEJ1ZmZlciQxLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgZGVzLWVkZTMtY2JjYCwga2V5LmRhdGEsIEJ1ZmZlciQxLmZyb20oYWxnb3JpdGhtLml2KSk7XG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBlbmMgPSBCdWZmZXIkMS5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBkZXMtZWRlMy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICAgIGRlYyA9IEJ1ZmZlciQxLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcbiAgICB9XG59XG5cbmNsYXNzIERlc0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZS5EZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSA2NDtcbiAgICAgICAgdGhpcy5pdlNpemUgPSA4O1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkRFUy1DQkNcIjtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIGlmIChrZXkuZGF0YS5sZW5ndGggIT09ICh0aGlzLmtleVNpemVCaXRzID4+IDMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBEZXNDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERlc0VkZTNDYmNQcm92aWRlciBleHRlbmRzIGNvcmUuRGVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmtleVNpemVCaXRzID0gMTkyO1xuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiREVTLUVERTMtQ0JDXCI7XG4gICAgfVxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMsXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IHRoaXMubmFtZSwgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICBpZiAoa2V5LmRhdGEubGVuZ3RoICE9PSAodGhpcy5rZXlTaXplQml0cyA+PiAzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBXcm9uZyBrZXkgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgRGVzQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRKd2tBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOiB7XG4gICAgICAgICAgICBjb25zdCBtZFNpemUgPSAvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXTtcbiAgICAgICAgICAgIHJldHVybiBgUlNBLU9BRVAke21kU2l6ZSAhPT0gXCIxXCIgPyBgLSR7bWRTaXplfWAgOiBcIlwifWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XG4gICAgICAgICAgICByZXR1cm4gYFJTJHsvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXX1gO1xuICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxuICAgICAgICAgICAgcmV0dXJuIGBQUyR7LyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV19YDtcbiAgICAgICAgY2FzZSBcIlJTQS1QS0NTMVwiOlxuICAgICAgICAgICAgcmV0dXJuIGBSUzFgO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xuICAgIH1cbn1cblxuY2xhc3MgUnNhUHJpdmF0ZUtleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInByaXZhdGVcIjtcbiAgICB9XG4gICAgZ2V0S2V5KCkge1xuICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcbiAgICAgICAgcmV0dXJuIEFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmUuYXNuMS5Sc2FQcml2YXRlS2V5KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAga3R5OiBcIlJTQVwiLFxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBrZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIkMS5mcm9tKEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBBc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlLmFzbjEuUHVibGljS2V5SW5mbyk7XG4gICAgICAgIHJldHVybiBBc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wdWJsaWNLZXksIGNvcmUuYXNuMS5Sc2FQdWJsaWNLZXkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBrdHk6IFwiUlNBXCIsXG4gICAgICAgICAgICBhbGc6IGdldEp3a0FsZ29yaXRobSh0aGlzLmFsZ29yaXRobSksXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwgSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IEpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmUuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZS5hc24xLlB1YmxpY0tleUluZm8oKTtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIkMS5mcm9tKEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYUNyeXB0byB7XG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIHByaXZhdGVLZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IEJ1ZmZlciQxLmNvbmNhdChbXG4gICAgICAgICAgICBCdWZmZXIkMS5hbGxvYyg0IC0gYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50LmJ5dGVMZW5ndGgsIDApLFxuICAgICAgICAgICAgQnVmZmVyJDEuZnJvbShhbGdvcml0aG0ucHVibGljRXhwb25lbnQpLFxuICAgICAgICBdKS5yZWFkSW50MzJCRSgwKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwicnNhXCIsIHtcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoLFxuICAgICAgICAgICAgcHVibGljRXhwb25lbnQsXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuUnNhUHVibGljS2V5IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlLmFzbjEuUHVibGljS2V5SW5mbyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlLmFzbjEuUnNhUHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IEFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmUuYXNuMS5Sc2FQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25Sc2EoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVNTQShhbGdvcml0aG0sIGtleSwgZGF0YSwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQcml2YXRlS2V5KCk7XG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyJDEuZnJvbShBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xuICAgICAgICBrZXkuYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXNuS2V5LnB1YmxpY0V4cG9uZW50KTtcbiAgICAgICAga2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID0gYXNuS2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCA8PCAzO1xuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc3RhdGljIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmUuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFJzYVB1YmxpY0tleSgpO1xuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlciQxLmZyb20oQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcbiAgICAgICAga2V5LmFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCA9IG5ldyBVaW50OEFycmF5KGFzbktleS5wdWJsaWNFeHBvbmVudCk7XG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDcnlwdG9BbGdvcml0aG0oYWxnKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMVwiO1xuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMjU2XCI7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzODRcIjtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTUxMlwiO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtMjU2XCI7XG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0zODRcIjtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzLTUxMlwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobS5oYXNoOiBJcyBub3QgcmVjb2duaXplZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2lnblJzYShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oY3J5cHRvQWxnKTtcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcbiAgICAgICAgICAgIG9wdGlvbnMuc2FsdExlbmd0aCA9IGFsZ29yaXRobS5zYWx0TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKS5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyB2ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShjcnlwdG9BbGcpO1xuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICBpZiAoIWtleS5wZW0pIHtcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcbiAgICAgICAgICAgIG9wdGlvbnMuc2FsdExlbmd0aCA9IGFsZ29yaXRobS5zYWx0TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWAsXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9PQUVQX1BBRERJTkcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5wdWJsaWNFbmNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCxcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5sYWJlbCkgO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XG4gICAgfVxufVxuUnNhQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiLCBcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdO1xuUnNhQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXTtcblxuY2xhc3MgUnNhU3NhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLlJzYVNzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxuICAgICAgICAgICAgXCJTSEEzLTI1NlwiLCBcIlNIQTMtMzg0XCIsIFwiU0hBMy01MTJcIlxuICAgICAgICBdO1xuICAgIH1cbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFJzYVBzc1Byb3ZpZGVyIGV4dGVuZHMgY29yZS5Sc2FQc3NQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXG4gICAgICAgICAgICBcInNoYWtlMTI4XCIsIFwic2hha2UyNTZcIixcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTaGFDcnlwdG8ge1xuICAgIHN0YXRpYyBzaXplKGFsZ29yaXRobSkge1xuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAxNjA7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI1NjtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzg0O1xuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MTI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobSkge1xuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTFcIjtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMjU2XCI7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTM4NFwiO1xuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGE1MTJcIjtcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtMjU2XCI7XG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTM4NFwiO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy01MTJcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGFzaEFsZyA9IHRoaXMuZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaGFzaEFsZylcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyJDEuZnJvbShkYXRhKSkuZGlnZXN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoKS5idWZmZXI7XG4gICAgfVxufVxuXG5jbGFzcyBSc2FPYWVwUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLlJzYU9hZXBQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBjb25zdCBrZXlTaXplID0gTWF0aC5jZWlsKGludGVybmFsS2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID4+IDMpO1xuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoKSA+PiAzO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3QgcHNMZW5ndGggPSBrZXlTaXplIC0gZGF0YUxlbmd0aCAtIDIgKiBoYXNoU2l6ZSAtIDI7XG4gICAgICAgIGlmIChkYXRhTGVuZ3RoID4ga2V5U2l6ZSAtIDIgKiBoYXNoU2l6ZSAtIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgdG9vIGxhcmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShrZXlTaXplKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gbWVzc2FnZS5zdWJhcnJheShoYXNoU2l6ZSArIDEpO1xuICAgICAgICBkYXRhQmxvY2suc2V0KGRhdGFWaWV3LCBoYXNoU2l6ZSArIHBzTGVuZ3RoICsgMSk7XG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXG4gICAgICAgICAgICAudXBkYXRlKGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShhbGdvcml0aG0ubGFiZWwgfHwgbmV3IFVpbnQ4QXJyYXkoMCkpKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgICAgICBkYXRhQmxvY2suc2V0KGxhYmVsSGFzaCwgMCk7XG4gICAgICAgIGRhdGFCbG9ja1toYXNoU2l6ZSArIHBzTGVuZ3RoXSA9IDE7XG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhzZWVkKTtcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgc2VlZCwgZGF0YUJsb2NrLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgZGF0YUJsb2NrLCBzZWVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VlZFtpXSBePSBzZWVkTWFza1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xuICAgICAgICAgICAgaW50ZXJuYWxLZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtpbnRlcm5hbEtleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGtjczAgPSBjcnlwdG8ucHVibGljRW5jcnlwdCh7XG4gICAgICAgICAgICBrZXk6IGludGVybmFsS2V5LnBlbSxcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX05PX1BBRERJTkcsXG4gICAgICAgIH0sIEJ1ZmZlciQxLmZyb20obWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gpID4+IDM7XG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChkYXRhTGVuZ3RoICE9PSBrZXlTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xuICAgICAgICAgICAgaW50ZXJuYWxLZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7aW50ZXJuYWxLZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGtjczAgPSBjcnlwdG8ucHJpdmF0ZURlY3J5cHQoe1xuICAgICAgICAgICAga2V5OiBpbnRlcm5hbEtleS5wZW0sXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxuICAgICAgICB9LCBCdWZmZXIkMS5mcm9tKGRhdGEpKTtcbiAgICAgICAgY29uc3QgeiA9IHBrY3MwWzBdO1xuICAgICAgICBjb25zdCBzZWVkID0gcGtjczAuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gcGtjczAuc3ViYXJyYXkoaGFzaFNpemUgKyAxKTtcbiAgICAgICAgaWYgKHogIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWRNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBkYXRhQmxvY2ssIHNlZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFCbG9ja01hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIHNlZWQsIGRhdGFCbG9jay5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YUJsb2NrW2ldIF49IGRhdGFCbG9ja01hc2tbaV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcbiAgICAgICAgICAgIC51cGRhdGUoY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGFsZ29yaXRobS5sYWJlbCB8fCBuZXcgVWludDhBcnJheSgwKSkpXG4gICAgICAgICAgICAuZGlnZXN0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaFNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxhYmVsSGFzaFtpXSAhPT0gZGF0YUJsb2NrW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBzRW5kID0gaGFzaFNpemU7XG4gICAgICAgIGZvciAoOyBwc0VuZCA8IGRhdGFCbG9jay5sZW5ndGg7IHBzRW5kKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBzeiA9IGRhdGFCbG9ja1twc0VuZF07XG4gICAgICAgICAgICBpZiAocHN6ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHN6ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBzRW5kID09PSBkYXRhQmxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwa2NzMCA9IGRhdGFCbG9jay5zdWJhcnJheShwc0VuZCArIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IFJzYUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVB1YmxpY0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1nZjEoYWxnb3JpdGhtLCBzZWVkLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoYWxnb3JpdGhtKSA+PiAzO1xuICAgICAgICBjb25zdCBtYXNrID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaFNpemUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyWzBdID0gaSA+Pj4gMjQ7XG4gICAgICAgICAgICBjb3VudGVyWzFdID0gKGkgPj4+IDE2KSAmIDI1NTtcbiAgICAgICAgICAgIGNvdW50ZXJbMl0gPSAoaSA+Pj4gOCkgJiAyNTU7XG4gICAgICAgICAgICBjb3VudGVyWzNdID0gaSAmIDI1NTtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1hc2sgPSBtYXNrLnN1YmFycmF5KGkgKiBoYXNoU2l6ZSk7XG4gICAgICAgICAgICBsZXQgY2h1bmsgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0ubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShjb3VudGVyKVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBzdWJtYXNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkoMCwgc3VibWFzay5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VibWFzay5zZXQoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXNrO1xuICAgIH1cbn1cblxuY2xhc3MgUnNhRXNQcm92aWRlciBleHRlbmRzIGNvcmUuUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQUVTLVBLQ1MxLXYxXzVcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNFeHBvbmVudFwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ICYmIGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IENvbnZlcnQuVG9CYXNlNjQoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50KTtcbiAgICAgICAgaWYgKCEocHVibGljRXhwb25lbnQgPT09IFwiQXc9PVwiIHx8IHB1YmxpY0V4cG9uZW50ID09PSBcIkFRQUJcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTXVzdCBiZSBbM10gb3IgWzEsMCwxXVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibW9kdWx1c0xlbmd0aFwiKTtcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9kdWx1c0xlbmd0aDogTXVzdCBiZSAxMDI0LCAyMDQ4LCBvciA0MDk2XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcbiAgICAgICAgY29uc3QgZW5jID0gY3J5cHRvLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcbiAgICAgICAgY29uc3QgZGVjID0gY3J5cHRvLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFJTQSBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9DcnlwdG9PcHRpb25zKGtleSkge1xuICAgICAgICBjb25zdCB0eXBlID0ga2V5LnR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gJHt0eXBlfSBLRVktLS0tLVxcbiR7Z2V0Q3J5cHRvS2V5KGtleSkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCAke3R5cGV9IEtFWS0tLS0tYCxcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BBRERJTkcsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBuYW1lZE9JRHMgPSB7XG4gICAgXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI6IFwiUC0yNTZcIixcbiAgICBcIlAtMjU2XCI6IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiLFxuICAgIFwiMS4zLjEzMi4wLjM0XCI6IFwiUC0zODRcIixcbiAgICBcIlAtMzg0XCI6IFwiMS4zLjEzMi4wLjM0XCIsXG4gICAgXCIxLjMuMTMyLjAuMzVcIjogXCJQLTUyMVwiLFxuICAgIFwiUC01MjFcIjogXCIxLjMuMTMyLjAuMzVcIixcbiAgICBcIjEuMy4xMzIuMC4xMFwiOiBcIkstMjU2XCIsXG4gICAgXCJLLTI1NlwiOiBcIjEuMy4xMzIuMC4xMFwiLFxuICAgIFwiYnJhaW5wb29sUDE2MHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjFcIixcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xXCI6IFwiYnJhaW5wb29sUDE2MHIxXCIsXG4gICAgXCJicmFpbnBvb2xQMTYwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiLFxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjJcIjogXCJicmFpbnBvb2xQMTYwdDFcIixcbiAgICBcImJyYWlucG9vbFAxOTJyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4zXCIsXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiOiBcImJyYWlucG9vbFAxOTJyMVwiLFxuICAgIFwiYnJhaW5wb29sUDE5MnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjRcIixcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS40XCI6IFwiYnJhaW5wb29sUDE5MnQxXCIsXG4gICAgXCJicmFpbnBvb2xQMjI0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiLFxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjVcIjogXCJicmFpbnBvb2xQMjI0cjFcIixcbiAgICBcImJyYWlucG9vbFAyMjR0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS42XCIsXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiOiBcImJyYWlucG9vbFAyMjR0MVwiLFxuICAgIFwiYnJhaW5wb29sUDI1NnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjdcIixcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS43XCI6IFwiYnJhaW5wb29sUDI1NnIxXCIsXG4gICAgXCJicmFpbnBvb2xQMjU2dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiLFxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjhcIjogXCJicmFpbnBvb2xQMjU2dDFcIixcbiAgICBcImJyYWlucG9vbFAzMjByMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS45XCIsXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiOiBcImJyYWlucG9vbFAzMjByMVwiLFxuICAgIFwiYnJhaW5wb29sUDMyMHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCIsXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTBcIjogXCJicmFpbnBvb2xQMzIwdDFcIixcbiAgICBcImJyYWlucG9vbFAzODRyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMVwiLFxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjExXCI6IFwiYnJhaW5wb29sUDM4NHIxXCIsXG4gICAgXCJicmFpbnBvb2xQMzg0dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTJcIixcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiOiBcImJyYWlucG9vbFAzODR0MVwiLFxuICAgIFwiYnJhaW5wb29sUDUxMnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCIsXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTNcIjogXCJicmFpbnBvb2xQNTEycjFcIixcbiAgICBcImJyYWlucG9vbFA1MTJ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xNFwiLFxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjE0XCI6IFwiYnJhaW5wb29sUDUxMnQxXCIsXG59O1xuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlJDEobmFtZWRDdXJ2ZSkge1xuICAgIGNvbnN0IG9pZCA9IG5hbWVkT0lEc1tuYW1lZEN1cnZlXTtcbiAgICBpZiAoIW9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGNvbnZlcnQgV2ViQ3J5cHRvIG5hbWVkIGN1cnZlICcke25hbWVkQ3VydmV9JyB0byBPSURgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9pZDtcbn1cblxuY2xhc3MgRWNQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBBc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xuICAgICAgICByZXR1cm4gQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZS5hc24xLkVjUHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGt0eTogXCJFQ1wiLFxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShqc29uLmNydikpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZS5hc24xLkVjUHJpdmF0ZUtleSB9KTtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyJDEuZnJvbShBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgRWNQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcbiAgICB9XG4gICAgZ2V0S2V5KCkge1xuICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZS5hc24xLlB1YmxpY0tleUluZm8pO1xuICAgICAgICByZXR1cm4gbmV3IGNvcmUuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGt0eTogXCJFQ1wiLFxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuRWNQdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZS5hc24xLlB1YmxpY0tleUluZm8oKTtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmUuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGpzb24uY3J2KSkpO1xuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IEFzblNlcmlhbGl6ZXIudG9BU04oa2V5KS52YWx1ZUhleDtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyJDEuZnJvbShBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgU2hhMVByb3ZpZGVyIGV4dGVuZHMgY29yZS5Qcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTFcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBTaGEyNTZQcm92aWRlciBleHRlbmRzIGNvcmUuUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0yNTZcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBTaGEzODRQcm92aWRlciBleHRlbmRzIGNvcmUuUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0zODRcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBTaGE1MTJQcm92aWRlciBleHRlbmRzIGNvcmUuUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS01MTJcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBTaGEzMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlLlByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTI1NlwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xuICAgIH1cbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcbiAgICB9XG59XG5cbmNsYXNzIFNoYTMzODRQcm92aWRlciBleHRlbmRzIGNvcmUuUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtMzg0XCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XG4gICAgfVxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgIH1cbn1cblxuY2xhc3MgU2hhMzUxMlByb3ZpZGVyIGV4dGVuZHMgY29yZS5Qcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy01MTJcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBFY0NyeXB0byB7XG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IEVjUHJpdmF0ZUtleSgpO1xuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBwcml2YXRlS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnByaXZhdGVLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIHB1YmxpY0tleS5leHRyYWN0YWJsZSA9IHRydWU7XG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwiZWNcIiwge1xuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogdGhpcy5nZXRPcGVuU1NMTmFtZWRDdXJ2ZShhbGdvcml0aG0ubmFtZWRDdXJ2ZSksXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtLmhhc2gpO1xuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICBpZiAoIWtleS5wZW0pIHtcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZXIuc2lnbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBBc25QYXJzZXIucGFyc2Uoc2lnbmF0dXJlLCBjb3JlLmFzbjEuRWNEc2FTaWduYXR1cmUpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVSYXcgPSBjb3JlLkVjVXRpbHMuZW5jb2RlU2lnbmF0dXJlKGVjU2lnbmF0dXJlLCBjb3JlLkVjQ3VydmVzLmdldChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpLnNpemUpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlUmF3LmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShjcnlwdG9BbGcpO1xuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlciQxLmZyb20oZGF0YSkpO1xuICAgICAgICBpZiAoIWtleS5wZW0pIHtcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBuZXcgY29yZS5hc24xLkVjRHNhU2lnbmF0dXJlKCk7XG4gICAgICAgIGNvbnN0IG5hbWVkQ3VydmUgPSBjb3JlLkVjQ3VydmVzLmdldChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVQb2ludCA9IGNvcmUuRWNVdGlscy5kZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBuYW1lZEN1cnZlLnNpemUpO1xuICAgICAgICBlY1NpZ25hdHVyZS5yID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlUG9pbnQucik7XG4gICAgICAgIGVjU2lnbmF0dXJlLnMgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5zKTtcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmVSYXcgPSBCdWZmZXIkMS5mcm9tKEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGVjU2lnbmF0dXJlKSk7XG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBlY1NpZ25hdHVyZVJhdyk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRPcGVuU1NMTmFtZWRDdXJ2ZShiYXNlS2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcbiAgICAgICAgY29uc3QgZWNkaCA9IGNyeXB0by5jcmVhdGVFQ0RIKGNyeXB0b0FsZyk7XG4gICAgICAgIGNvbnN0IGFzblByaXZhdGVLZXkgPSBBc25QYXJzZXIucGFyc2UoYmFzZUtleS5kYXRhLCBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xuICAgICAgICBjb25zdCBhc25FY1ByaXZhdGVLZXkgPSBBc25QYXJzZXIucGFyc2UoYXNuUHJpdmF0ZUtleS5wcml2YXRlS2V5LCBjb3JlLmFzbjEuRWNQcml2YXRlS2V5KTtcbiAgICAgICAgZWNkaC5zZXRQcml2YXRlS2V5KEJ1ZmZlciQxLmZyb20oYXNuRWNQcml2YXRlS2V5LnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3QgYXNuUHVibGljS2V5ID0gQXNuUGFyc2VyLnBhcnNlKGFsZ29yaXRobS5wdWJsaWMuZGF0YSwgY29yZS5hc24xLlB1YmxpY0tleUluZm8pO1xuICAgICAgICBjb25zdCBiaXRzID0gZWNkaC5jb21wdXRlU2VjcmV0KEJ1ZmZlciQxLmZyb20oYXNuUHVibGljS2V5LnB1YmxpY0tleSkpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYml0cykuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCA+PiAzKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SW5mbyA9IEFzblBhcnNlci5wYXJzZShrZXkuZGF0YSwgY29yZS5hc24xLlB1YmxpY0tleUluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNLZXlJbmZvLnB1YmxpY0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCBwa2NzOCcgb3IgJ3Nwa2knXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZS5hc24xLkVjUHJpdmF0ZUtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuRWNQdWJsaWNLZXkgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmUuYXNuMS5FY1B1YmxpY0tleShrZXlEYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBBc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmUuYXNuMS5QdWJsaWNLZXlJbmZvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBuZXcgY29yZS5hc24xLkVjUHVibGljS2V5KGtleUluZm8ucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydEtleVBhcmFtZXRlcnMoa2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSBBc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZS5hc24xLkVjUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRLZXlQYXJhbWV0ZXJzKGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzLCBhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzc2VydEtleVBhcmFtZXRlcnMocGFyYW1ldGVycywgbmFtZWRDdXJ2ZSkge1xuICAgICAgICBpZiAoIXBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gZG9lc24ndCBoYXZlIHJlcXVpcmVkIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWVkQ3VydmVJZGVudGlmaWVyID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hbWVkQ3VydmVJZGVudGlmaWVyID0gQXNuUGFyc2VyLnBhcnNlKHBhcmFtZXRlcnMsIGNvcmUuYXNuMS5PYmplY3RJZGVudGlmaWVyKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuQ3J5cHRvRXJyb3IoXCJDYW5ub3QgcmVhZCBrZXkgaW5mbyBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRPaWRCeU5hbWVkQ3VydmUkMShuYW1lZEN1cnZlKSAhPT0gbmFtZWRDdXJ2ZUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gcGFyYW1ldGVyIGRvZXNuJ3QgbWF0Y2ggdG8gbmFtZWQgY3VydmVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpKSk7XG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIkMS5mcm9tKEFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZS5hc24xLlB1YmxpY0tleUluZm8oKTtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xuICAgICAgICBjb25zdCBuYW1lZEN1cnZlID0gZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmUuYXNuMS5PYmplY3RJZGVudGlmaWVyKG5hbWVkQ3VydmUpKTtcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc25LZXkudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlciQxLmZyb20oQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRPcGVuU1NMTmFtZWRDdXJ2ZShjdXJ2ZSkge1xuICAgICAgICBzd2l0Y2ggKGN1cnZlLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQLTI1NlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInByaW1lMjU2djFcIjtcbiAgICAgICAgICAgIGNhc2UgXCJLLTI1NlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3AyNTZrMVwiO1xuICAgICAgICAgICAgY2FzZSBcIlAtMzg0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDM4NHIxXCI7XG4gICAgICAgICAgICBjYXNlIFwiUC01MjFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWNwNTIxcjFcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnZlO1xuICAgICAgICB9XG4gICAgfVxufVxuRWNDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xuRWNDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgY29yZS5FY2RzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IGNvcmUuRWNDdXJ2ZXMubmFtZXM7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXG4gICAgICAgICAgICBcInNoYWtlMTI4XCIsIFwic2hha2UyNTZcIixcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVjQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBFY0NyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gRWNDcnlwdG8udmVyaWZ5KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgY29yZS5FY2RoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZS5FY0N1cnZlcy5uYW1lcztcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVjQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYml0cyA9IGF3YWl0IEVjQ3J5cHRvLmRlcml2ZUJpdHMoeyAuLi5hbGdvcml0aG0sIHB1YmxpYzogZ2V0Q3J5cHRvS2V5KGFsZ29yaXRobS5wdWJsaWMpIH0sIGdldENyeXB0b0tleShiYXNlS2V5KSwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxufVxuXG5jb25zdCBlZE9JRHMgPSB7XG4gICAgW2NvcmUuYXNuMS5pZEVkNDQ4XTogXCJFZDQ0OFwiLFxuICAgIFwiZWQ0NDhcIjogY29yZS5hc24xLmlkRWQ0NDgsXG4gICAgW2NvcmUuYXNuMS5pZFg0NDhdOiBcIlg0NDhcIixcbiAgICBcIng0NDhcIjogY29yZS5hc24xLmlkWDQ0OCxcbiAgICBbY29yZS5hc24xLmlkRWQyNTUxOV06IFwiRWQyNTUxOVwiLFxuICAgIFwiZWQyNTUxOVwiOiBjb3JlLmFzbjEuaWRFZDI1NTE5LFxuICAgIFtjb3JlLmFzbjEuaWRYMjU1MTldOiBcIlgyNTUxOVwiLFxuICAgIFwieDI1NTE5XCI6IGNvcmUuYXNuMS5pZFgyNTUxOSxcbn07XG5mdW5jdGlvbiBnZXRPaWRCeU5hbWVkQ3VydmUobmFtZWRDdXJ2ZSkge1xuICAgIGNvbnN0IG9pZCA9IGVkT0lEc1tuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghb2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xuICAgIH1cbiAgICByZXR1cm4gb2lkO1xufVxuXG5jbGFzcyBFZFByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XG4gICAgfVxuICAgIGdldEtleSgpIHtcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IEFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XG4gICAgICAgIHJldHVybiBBc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlLmFzbjEuQ3VydmVQcml2YXRlS2V5KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAga3R5OiBcIk9LUFwiLFxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIEpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcbiAgICAgICAgY29uc3Qga2V5ID0gSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyJDEuZnJvbShBc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgRWRQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcbiAgICB9XG4gICAgZ2V0S2V5KCkge1xuICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZS5hc24xLlB1YmxpY0tleUluZm8pO1xuICAgICAgICByZXR1cm4ga2V5SW5mby5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGt0eTogXCJPS1BcIixcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCB7XG4gICAgICAgICAgICB4OiBDb252ZXJ0LlRvQmFzZTY0VXJsKGtleSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLngpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IHByb3BlcnR5IGZyb20gSldLLiBQcm9wZXJ0eSAneCcgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmUuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZShqc29uLmNydik7XG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlciQxLmZyb20oQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIEVkQ3J5cHRvIHtcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XG4gICAgICAgIHByaXZhdGVLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xuICAgICAgICBjb25zdCB0eXBlID0gYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKHR5cGUsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcHJpdmF0ZUtleS5kYXRhID0ga2V5cy5wcml2YXRlS2V5O1xuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICBpZiAoIWtleS5wZW0pIHtcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBjcnlwdG8uc2lnbihudWxsLCBCdWZmZXIkMS5mcm9tKGRhdGEpLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XG4gICAgICAgIGlmICgha2V5LnBlbSkge1xuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvayA9IGNyeXB0by52ZXJpZnkobnVsbCwgQnVmZmVyJDEuZnJvbShkYXRhKSwgb3B0aW9ucywgQnVmZmVyJDEuZnJvbShzaWduYXR1cmUpKTtcbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcbiAgICAgICAgICAgIGtleTogYWxnb3JpdGhtLnB1YmxpYy5kYXRhLFxuICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxuICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoe1xuICAgICAgICAgICAga2V5OiBiYXNlS2V5LmRhdGEsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXG4gICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiaXRzID0gY3J5cHRvLmRpZmZpZUhlbGxtYW4oe1xuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaXRzKS5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoID4+IDMpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKGtleS5kYXRhLCBjb3JlLmFzbjEuUHVibGljS2V5SW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsIHBrY3M4JyBvciAnc3BraSdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBKc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlLmFzbjEuQ3VydmVQcml2YXRlS2V5IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghandrLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBDYW5ub3QgZ2V0IHJlcXVpcmVkICd4JyBmaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoQ29udmVydC5Gcm9tQmFzZTY0VXJsKGp3ay54KSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoa2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlLmFzbjEuUHVibGljS2V5SW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleUluZm8ucHVibGljS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IEFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmUuYXNuMS5DdXJ2ZVByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFZFByaXZhdGVLZXkoKTtcbiAgICAgICAga2V5LmZyb21KU09OKHtcbiAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWVkQ3VydmUsXG4gICAgICAgICAgICBkOiBDb252ZXJ0LlRvQmFzZTY0VXJsKGFzbktleS5kKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcbiAgICAgICAga2V5LmZyb21KU09OKHtcbiAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWVkQ3VydmUsXG4gICAgICAgICAgICB4OiBDb252ZXJ0LlRvQmFzZTY0VXJsKGFzbktleSksXG4gICAgICAgIH0pO1xuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxufVxuRWRDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xuRWRDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFZERzYVByb3ZpZGVyIGV4dGVuZHMgY29yZS5FZERzYVByb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWRDcnlwdG8uZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogYWxnb3JpdGhtLm5hbWVkQ3VydmUucmVwbGFjZSgvXmVkL2ksIFwiRWRcIiksXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gRWRDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICB9XG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZS5FY2RoRXNQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IGFsZ29yaXRobS5uYW1lZEN1cnZlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgRWRDcnlwdG8uZGVyaXZlQml0cyh7IC4uLmFsZ29yaXRobSwgcHVibGljOiBnZXRDcnlwdG9LZXkoYWxnb3JpdGhtLnB1YmxpYykgfSwgZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWRDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbn1cblxuY2xhc3MgRWQyNTUxOUNyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XG4gICAgY29uc3RydWN0b3IoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwgdXNhZ2VzLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gdXNhZ2VzO1xuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB9XG4gICAgdG9KV0soKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIEVkMjU1MTlQcml2YXRlS2V5IGV4dGVuZHMgRWQyNTUxOUNyeXB0b0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xuICAgIH1cbiAgICB0b0pXSygpIHtcbiAgICAgICAgY29uc3QgcHViSndrID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXk6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIixcbiAgICAgICAgfSkuZXhwb3J0KHsgZm9ybWF0OiBcImp3a1wiIH0pO1xuICAgICAgICBjb25zdCByYXcgPSBjb3JlLlBlbUNvbnZlcnRlci50b1VpbnQ4QXJyYXkodGhpcy5kYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBwa2NzOCA9IEFzbkNvbnZlcnQucGFyc2UocmF3LCBjb3JlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xuICAgICAgICBjb25zdCBkID0gQXNuQ29udmVydC5wYXJzZShwa2NzOC5wcml2YXRlS2V5LCBjb3JlLmFzbjEuRWRQcml2YXRlS2V5KS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSldLKCksXG4gICAgICAgICAgICAuLi5wdWJKd2ssXG4gICAgICAgICAgICBkOiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShkKSkudG9TdHJpbmcoXCJiYXNlNjR1cmxcIiksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBFZDI1NTE5UHVibGljS2V5IGV4dGVuZHMgRWQyNTUxOUNyeXB0b0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XG4gICAgfVxuICAgIHRvSldLKCkge1xuICAgICAgICBjb25zdCBqd2sgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgZm9ybWF0OiBcInBlbVwiLFxuICAgICAgICB9KS5leHBvcnQoeyBmb3JtYXQ6IFwiandrXCIgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pXSygpLFxuICAgICAgICAgICAgLi4uandrLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgRWQyNTUxOUNyeXB0byB7XG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCB0eXBlID0gYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKHR5cGUsIHtcbiAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInBlbVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qga2V5QWxnID0ge1xuICAgICAgICAgICAgbmFtZTogdHlwZSA9PT0gXCJlZDI1NTE5XCIgPyBcIkVkMjU1MTlcIiA6IFwiWDI1NTE5XCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXlVc2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluY2x1ZGVzKHVzYWdlKSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleVVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmNsdWRlcyh1c2FnZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogbmV3IEVkMjU1MTlQcml2YXRlS2V5KGtleUFsZywgZXh0cmFjdGFibGUsIHByaXZhdGVLZXlVc2FnZXMsIGtleXMucHJpdmF0ZUtleSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IG5ldyBFZDI1NTE5UHVibGljS2V5KGtleUFsZywgdHJ1ZSwgcHVibGljS2V5VXNhZ2VzLCBrZXlzLnB1YmxpY0tleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGNyeXB0by5zaWduKG51bGwsIEJ1ZmZlci5mcm9tKGRhdGEpLCBrZXkuZGF0YSk7XG4gICAgICAgIHJldHVybiBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnZlcmlmeShudWxsLCBCdWZmZXIuZnJvbShkYXRhKSwga2V5LmRhdGEsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnRvSldLKCk7XG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlBlbUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleS5kYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlBlbUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleS5kYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5LnRvSldLKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnZlcnQuRnJvbUJhc2U2NFVybChqd2sueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsIHBrY3M4JyBvciAnc3BraSdcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVEYXRhID0gbmV3IGNvcmUuYXNuMS5FZFByaXZhdGVLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZURhdGEudmFsdWUgPSBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKEJ1ZmZlci5mcm9tKGp3ay5kLCBcImJhc2U2NHVybFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrY3M4ID0gbmV3IGNvcmUuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBwa2NzOC5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZWQyNTUxOVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvcmUuYXNuMS5pZEVkMjU1MTlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29yZS5hc24xLmlkWDI1NTE5O1xuICAgICAgICAgICAgICAgICAgICBwa2NzOC5wcml2YXRlS2V5ID0gQXNuQ29udmVydC5zZXJpYWxpemUocHJpdmF0ZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBBc25Db252ZXJ0LnNlcmlhbGl6ZShwa2NzOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbSA9IGNvcmUuUGVtQ29udmVydGVyLmZyb21CdWZmZXJTb3VyY2UocmF3LCBcIlBSSVZBVEUgS0VZXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQcml2YXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgcGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoandrLngpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiandrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGp3ayxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbSA9IHB1YktleS5leHBvcnQoeyBmb3JtYXQ6IFwicGVtXCIsIHR5cGU6IFwic3BraVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCBwZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBDYW5ub3QgaW1wb3J0IEpXSy4gJ2QnIG9yICd4JyBtdXN0IGJlIHByZXNlbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbSA9IGNvcmUuUGVtQ29udmVydGVyLmZyb21CdWZmZXJTb3VyY2Uoa2V5RGF0YSwgXCJQUklWQVRFIEtFWVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQcml2YXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgcGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW0gPSBjb3JlLlBlbUNvbnZlcnRlci5mcm9tQnVmZmVyU291cmNlKGtleURhdGEsIFwiUFVCTElDIEtFWVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCBwZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0ga2V5RGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImp3a1wiLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGt0eTogXCJPS1BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJlZDI1NTE5XCIgPyBcIkVkMjU1MTlcIiA6IFwiWDI1NTE5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBDb252ZXJ0LlRvQmFzZTY0VXJsKHJhdyksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVtID0ga2V5LmV4cG9ydCh7IGZvcm1hdDogXCJwZW1cIiwgdHlwZTogXCJzcGtpXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5UHVibGljS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgcGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5FZDI1NTE5Q3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlQml0c1wiLCBcImRlcml2ZUtleVwiXTtcbkVkMjU1MTlDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xuXG5jbGFzcyBFZDI1NTE5UHJvdmlkZXIgZXh0ZW5kcyBjb3JlLkVkMjU1MTlQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkMjU1MTlDcnlwdG8uZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gRWQyNTUxOUNyeXB0by5zaWduKGFsZ29yaXRobSwgaW50ZXJuYWxLZXksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9XG4gICAgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xuICAgICAgICByZXR1cm4gRWQyNTUxOUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBpbnRlcm5hbEtleSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xuICAgICAgICByZXR1cm4gRWQyNTUxOUNyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBpbnRlcm5hbEtleSk7XG4gICAgfVxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gYXdhaXQgRWQyNTUxOUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGludGVybmFsS2V5KTtcbiAgICB9XG59XG5cbmNsYXNzIFgyNTUxOVByb3ZpZGVyIGV4dGVuZHMgY29yZS5YMjU1MTlQcm92aWRlciB7XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkMjU1MTlDcnlwdG8uZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxCYXNlS2V5ID0gZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFB1YmxpY0tleSA9IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXk6IGludGVybmFsUHVibGljS2V5LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIixcbiAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0by5jcmVhdGVQcml2YXRlS2V5KHtcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxCYXNlS2V5LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIixcbiAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBjcnlwdG8uZGlmZmllSGVsbG1hbih7XG4gICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgICAgIHJldHVybiBFZDI1NTE5Q3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGludGVybmFsS2V5KTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWQyNTUxOUNyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgRWQyNTUxOUNyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEVkMjU1MTlDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFBia2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcbn1cblxuY2xhc3MgUGJrZGYyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLlBia2RmMlByb3ZpZGVyIHtcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGFsZ29yaXRobS5zYWx0KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICAgICAgICAgICAgY3J5cHRvLnBia2RmMihnZXRDcnlwdG9LZXkoYmFzZUtleSkuZGF0YSwgQnVmZmVyJDEuZnJvbShzYWx0KSwgYWxnb3JpdGhtLml0ZXJhdGlvbnMsIGxlbmd0aCA+PiAzLCBoYXNoLCAoZXJyLCBkZXJpdmVkQml0cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRlcml2ZWRCaXRzKS5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyYXdcIikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IFBia2RmQ3J5cHRvS2V5KCk7XG4gICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlciQxLmZyb20oa2V5RGF0YSk7XG4gICAgICAgICAgICBrZXkuYWxnb3JpdGhtID0geyBuYW1lOiB0aGlzLm5hbWUgfTtcbiAgICAgICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcbiAgICAgICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAncmF3J1wiKTtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBQYmtkZkNyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBQQktERiBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEhtYWNDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xuICAgIGdldCBhbGcoKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmFsZ29yaXRobS5oYXNoLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGBIUyR7aGFzaC5yZXBsYWNlKFwiU0hBLVwiLCBcIlwiKX1gO1xuICAgIH1cbiAgICBzZXQgYWxnKHZhbHVlKSB7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXG5dLCBIbWFjQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIGNvcmUuSG1hY1Byb3ZpZGVyIHtcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoYWxnb3JpdGhtLmxlbmd0aCB8fCB0aGlzLmdldERlZmF1bHRMZW5ndGgoYWxnb3JpdGhtLmhhc2gubmFtZSkpID4+IDMgPDwgMztcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhtYWNDcnlwdG9LZXkoKTtcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHtcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCA+PiAzKTtcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyeXB0b0FsZywgZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSlcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyJDEuZnJvbShkYXRhKSkuZGlnZXN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShobWFjKS5idWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyeXB0b0FsZywgZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSlcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyJDEuZnJvbShkYXRhKSkuZGlnZXN0KCk7XG4gICAgICAgIHJldHVybiBobWFjLmNvbXBhcmUoQnVmZmVyJDEuZnJvbShzaWduYXR1cmUpKSA9PT0gMDtcbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxuICAgICAgICAgICAgICAgIGtleSA9IEpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IEhtYWNDcnlwdG9LZXkgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgICAgICAgICAga2V5ID0gbmV3IEhtYWNDcnlwdG9LZXkoKTtcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlciQxLmZyb20oa2V5RGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7XG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6IGFsZ29yaXRobS5oYXNoLm5hbWUgfSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGxlbmd0aDoga2V5LmRhdGEubGVuZ3RoIDw8IDMsXG4gICAgICAgIH07XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gSnNvblNlcmlhbGl6ZXIudG9KU09OKGdldENyeXB0b0tleShrZXkpKTtcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSkuYnVmZmVyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhtYWNDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgSE1BQyBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEhrZGZDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBjb3JlLkhrZGZQcm92aWRlciB7XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcbiAgICAgICAgaWYgKGZvcm1hdC50b0xvd2VyQ2FzZSgpICE9PSBcInJhd1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5PcGVyYXRpb25FcnJvcihcIk9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBIa2RmQ3J5cHRvS2V5KCk7XG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyJDEuZnJvbShrZXlEYXRhKTtcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHsgbmFtZTogdGhpcy5uYW1lIH07XG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhwYXJhbXMsIGJhc2VLZXksIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBoYXNoID0gcGFyYW1zLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGNyeXB0by5jcmVhdGVIYXNoKGhhc2gpLmRpZ2VzdCgpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGxlbmd0aCAvIDg7XG4gICAgICAgIGNvbnN0IGluZm8gPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIkMS50b1VpbnQ4QXJyYXkocGFyYW1zLmluZm8pO1xuICAgICAgICBjb25zdCBQUksgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIkMS50b1VpbnQ4QXJyYXkocGFyYW1zLnNhbHQpKVxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXJTb3VyY2VDb252ZXJ0ZXIkMS50b1VpbnQ4QXJyYXkoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEpKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgICAgICBjb25zdCBibG9ja3MgPSBbQnVmZmVyJDEuYWxsb2MoMCldO1xuICAgICAgICBjb25zdCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVMZW5ndGggLyBoYXNoTGVuZ3RoKSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBQUkspXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIkMS5jb25jYXQoW2Jsb2Nrc1tpIC0gMV0sIGluZm8sIEJ1ZmZlciQxLmZyb20oW2ldKV0pKVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlciQxLmNvbmNhdChibG9ja3MpLnNsaWNlKDAsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhrZGZDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgSEtERiBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNoYWtlQ3J5cHRvIHtcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSwgeyBvdXRwdXRMZW5ndGg6IGFsZ29yaXRobS5sZW5ndGggfSlcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyJDEuZnJvbShkYXRhKSkuZGlnZXN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoKS5idWZmZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZTEyOFByb3ZpZGVyIGV4dGVuZHMgY29yZS5TaGFrZTEyOFByb3ZpZGVyIHtcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFNoYWtlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgIH1cbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIGNvcmUuU2hha2UyNTZQcm92aWRlciB7XG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBTaGFrZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcbiAgICB9XG59XG5cbmNsYXNzIFN1YnRsZUNyeXB0byBleHRlbmRzIGNvcmUuU3VidGxlQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NiY1Byb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0N0clByb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0djbVByb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NtYWNQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNLd1Byb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0VjYlByb3ZpZGVyKCkpO1xuICAgICAgICBjb25zdCBjaXBoZXJzID0gY3J5cHRvLmdldENpcGhlcnMoKTtcbiAgICAgICAgaWYgKGNpcGhlcnMuaW5jbHVkZXMoXCJkZXMtY2JjXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IERlc0NiY1Byb3ZpZGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzRWRlM0NiY1Byb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVNzYVByb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVBzc1Byb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYU9hZXBQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FFc1Byb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZHNhUHJvdmlkZXIoKSk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaFByb3ZpZGVyKCkpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTFQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEyNTZQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzODRQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGE1MTJQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBQYmtkZjJQcm92aWRlcigpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBIbWFjUHJvdmlkZXIoKSk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgSGtkZlByb3ZpZGVyKCkpO1xuICAgICAgICBjb25zdCBub2RlTWFqb3JWZXJzaW9uID0gKF9hID0gL152KFxcZCspLy5leGVjKHByb2Nlc3MudmVyc2lvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbiAgICAgICAgaWYgKG5vZGVNYWpvclZlcnNpb24gJiYgcGFyc2VJbnQobm9kZU1ham9yVmVyc2lvbiwgMTApID49IDEyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMTI4UHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMjU2UHJvdmlkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzaGVzID0gY3J5cHRvLmdldEhhc2hlcygpO1xuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy0yNTZcIikpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzI1NlByb3ZpZGVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTM4NFwiKSkge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzMzg0UHJvdmlkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtNTEyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM1MTJQcm92aWRlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU1ham9yVmVyc2lvbiAmJiBwYXJzZUludChub2RlTWFqb3JWZXJzaW9uLCAxMCkgPj0gMTQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWREc2FQcm92aWRlcigpKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaEVzUHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVkMjU1MTlQcm92aWRlcigpKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgWDI1NTE5UHJvdmlkZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENyeXB0byBleHRlbmRzIGNvcmUuQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdWJ0bGUgPSBuZXcgU3VidGxlQ3J5cHRvKCk7XG4gICAgfVxuICAgIGdldFJhbmRvbVZhbHVlcyhhcnJheSkge1xuICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UmFuZG9tVmFsdWVzJyBvbiAnQ3J5cHRvJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0FycmF5QnVmZmVyVmlldydcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyJDEuZnJvbShhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xuICAgICAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ3J5cHRvIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@peculiar+webcrypto@1.5.0/node_modules/@peculiar/webcrypto/build/webcrypto.es.js\n");

/***/ })

};
;