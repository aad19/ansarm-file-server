"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-url-parser@1.1.3";
exports.ids = ["vendor-chunks/fast-url-parser@1.1.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/fast-url-parser@1.1.3/node_modules/fast-url-parser/src/urlparser.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-url-parser@1.1.3/node_modules/fast-url-parser/src/urlparser.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\nCopyright (c) 2014 Petka Antonov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nfunction Url() {\n    //For more efficient internal representation and laziness.\n    //The non-underscore versions of these properties are accessor functions\n    //defined on the prototype.\n    this._protocol = null;\n    this._href = \"\";\n    this._port = -1;\n    this._query = null;\n\n    this.auth = null;\n    this.slashes = null;\n    this.host = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.pathname = null;\n\n    this._prependSlash = false;\n}\n\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\");\n\nUrl.queryString = querystring;\n\nUrl.prototype.parse =\nfunction Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n    if (typeof str !== \"string\") {\n        throw new TypeError(\"Parameter 'url' must be a string, not \" +\n            typeof str);\n    }\n    var start = 0;\n    var end = str.length - 1;\n\n    //Trim leading and trailing ws\n    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;\n    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;\n\n    start = this._parseProtocol(str, start, end);\n\n    //Javascript doesn't have host\n    if (this._protocol !== \"javascript\") {\n        start = this._parseHost(str, start, end, hostDenotesSlash);\n        var proto = this._protocol;\n        if (!this.hostname &&\n            (this.slashes || (proto && !slashProtocols[proto]))) {\n            this.hostname = this.host = \"\";\n        }\n    }\n\n    if (start <= end) {\n        var ch = str.charCodeAt(start);\n\n        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\\'*/) {\n            this._parsePath(str, start, end, disableAutoEscapeChars);\n        }\n        else if (ch === 0x3F /*'?'*/) {\n            this._parseQuery(str, start, end, disableAutoEscapeChars);\n        }\n        else if (ch === 0x23 /*'#'*/) {\n          this._parseHash(str, start, end, disableAutoEscapeChars);\n        }\n        else if (this._protocol !== \"javascript\") {\n            this._parsePath(str, start, end, disableAutoEscapeChars);\n        }\n        else { //For javascript the pathname is just the rest of it\n            this.pathname = str.slice(start, end + 1 );\n        }\n\n    }\n\n    if (!this.pathname && this.hostname &&\n        this._slashProtocols[this._protocol]) {\n        this.pathname = \"/\";\n    }\n\n    if (parseQueryString) {\n        var search = this.search;\n        if (search == null) {\n            search = this.search = \"\";\n        }\n        if (search.charCodeAt(0) === 0x3F /*'?'*/) {\n            search = search.slice(1);\n        }\n        //This calls a setter function, there is no .query data property\n        this.query = Url.queryString.parse(search);\n    }\n};\n\nUrl.prototype.resolve = function Url$resolve(relative) {\n    return this.resolveObject(Url.parse(relative, false, true)).format();\n};\n\nUrl.prototype.format = function Url$format() {\n    var auth = this.auth || \"\";\n\n    if (auth) {\n        auth = encodeURIComponent(auth);\n        auth = auth.replace(/%3A/i, \":\");\n        auth += \"@\";\n    }\n\n    var protocol = this.protocol || \"\";\n    var pathname = this.pathname || \"\";\n    var hash = this.hash || \"\";\n    var search = this.search || \"\";\n    var query = \"\";\n    var hostname = this.hostname || \"\";\n    var port = this.port || \"\";\n    var host = false;\n    var scheme = \"\";\n\n    //Cache the result of the getter function\n    var q = this.query;\n    if (q && typeof q === \"object\") {\n        query = Url.queryString.stringify(q);\n    }\n\n    if (!search) {\n        search = query ? \"?\" + query : \"\";\n    }\n\n    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)\n        protocol += \":\";\n\n    if (this.host) {\n        host = auth + this.host;\n    }\n    else if (hostname) {\n        var ip6 = hostname.indexOf(\":\") > -1;\n        if (ip6) hostname = \"[\" + hostname + \"]\";\n        host = auth + hostname + (port ? \":\" + port : \"\");\n    }\n\n    var slashes = this.slashes ||\n        ((!protocol ||\n        slashProtocols[protocol]) && host !== false);\n\n\n    if (protocol) scheme = protocol + (slashes ? \"//\" : \"\");\n    else if (slashes) scheme = \"//\";\n\n    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {\n        pathname = \"/\" + pathname;\n    }\n    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)\n        search = \"?\" + search;\n    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)\n        hash = \"#\" + hash;\n\n    pathname = escapePathName(pathname);\n    search = escapeSearch(search);\n\n    return scheme + (host === false ? \"\" : host) + pathname + search + hash;\n};\n\nUrl.prototype.resolveObject = function Url$resolveObject(relative) {\n    if (typeof relative === \"string\")\n        relative = Url.parse(relative, false, true);\n\n    var result = this._clone();\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there\"s nothing left to do here.\n    if (!relative.href) {\n        result._href = \"\";\n        return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative._protocol) {\n        relative._copyPropsTo(result, true);\n\n        if (slashProtocols[result._protocol] &&\n            result.hostname && !result.pathname) {\n            result.pathname = \"/\";\n        }\n        result._href = \"\";\n        return result;\n    }\n\n    if (relative._protocol && relative._protocol !== result._protocol) {\n        // if it\"s a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it\"s not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that\"s known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashProtocols[relative._protocol]) {\n            relative._copyPropsTo(result, false);\n            result._href = \"\";\n            return result;\n        }\n\n        result._protocol = relative._protocol;\n        if (!relative.host && relative._protocol !== \"javascript\") {\n            var relPath = (relative.pathname || \"\").split(\"/\");\n            while (relPath.length && !(relative.host = relPath.shift()));\n            if (!relative.host) relative.host = \"\";\n            if (!relative.hostname) relative.hostname = \"\";\n            if (relPath[0] !== \"\") relPath.unshift(\"\");\n            if (relPath.length < 2) relPath.unshift(\"\");\n            result.pathname = relPath.join(\"/\");\n        } else {\n            result.pathname = relative.pathname;\n        }\n\n        result.search = relative.search;\n        result.host = relative.host || \"\";\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result._port = relative._port;\n        result.slashes = result.slashes || relative.slashes;\n        result._href = \"\";\n        return result;\n    }\n\n    var isSourceAbs =\n        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);\n    var isRelAbs = (\n            relative.host ||\n            (relative.pathname &&\n            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)\n        );\n    var mustEndAbs = (isRelAbs || isSourceAbs ||\n                        (result.host && relative.pathname));\n\n    var removeAllDots = mustEndAbs;\n\n    var srcPath = result.pathname && result.pathname.split(\"/\") || [];\n    var relPath = relative.pathname && relative.pathname.split(\"/\") || [];\n    var psychotic = result._protocol && !slashProtocols[result._protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n        result.hostname = \"\";\n        result._port = -1;\n        if (result.host) {\n            if (srcPath[0] === \"\") srcPath[0] = result.host;\n            else srcPath.unshift(result.host);\n        }\n        result.host = \"\";\n        if (relative._protocol) {\n            relative.hostname = \"\";\n            relative._port = -1;\n            if (relative.host) {\n                if (relPath[0] === \"\") relPath[0] = relative.host;\n                else relPath.unshift(relative.host);\n            }\n            relative.host = \"\";\n        }\n        mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n    }\n\n    if (isRelAbs) {\n        // it\"s absolute.\n        result.host = relative.host ?\n            relative.host : result.host;\n        result.hostname = relative.hostname ?\n            relative.hostname : result.hostname;\n        result.search = relative.search;\n        srcPath = relPath;\n        // fall through to the dot-handling below.\n    } else if (relPath.length) {\n        // it\"s relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) srcPath = [];\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n    } else if (relative.search) {\n        // just pull out the search.\n        // like href=\"?foo\".\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especialy happens in cases like\n            //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n            var authInHost = result.host && result.host.indexOf(\"@\") > 0 ?\n                result.host.split(\"@\") : false;\n            if (authInHost) {\n                result.auth = authInHost.shift();\n                result.host = result.hostname = authInHost.shift();\n            }\n        }\n        result.search = relative.search;\n        result._href = \"\";\n        return result;\n    }\n\n    if (!srcPath.length) {\n        // no path at all.  easy.\n        // we\"ve already handled the other stuff above.\n        result.pathname = null;\n        result._href = \"\";\n        return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    var last = srcPath.slice(-1)[0];\n    var hasTrailingSlash = (\n        (result.host || relative.host) && (last === \".\" || last === \"..\") ||\n        last === \"\");\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n    for (var i = srcPath.length; i >= 0; i--) {\n        last = srcPath[i];\n        if (last === \".\") {\n            srcPath.splice(i, 1);\n        } else if (last === \"..\") {\n            srcPath.splice(i, 1);\n            up++;\n        } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n        }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n            srcPath.unshift(\"..\");\n        }\n    }\n\n    if (mustEndAbs && srcPath[0] !== \"\" &&\n        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {\n        srcPath.unshift(\"\");\n    }\n\n    if (hasTrailingSlash && (srcPath.join(\"/\").substr(-1) !== \"/\")) {\n        srcPath.push(\"\");\n    }\n\n    var isAbsolute = srcPath[0] === \"\" ||\n        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);\n\n    // put the host back\n    if (psychotic) {\n        result.hostname = result.host = isAbsolute ? \"\" :\n            srcPath.length ? srcPath.shift() : \"\";\n        //occationaly the auth can get stuck only in host\n        //this especialy happens in cases like\n        //url.resolveObject(\"mailto:local1@domain1\", \"local2@domain2\")\n        var authInHost = result.host && result.host.indexOf(\"@\") > 0 ?\n            result.host.split(\"@\") : false;\n        if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n        }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift(\"\");\n    }\n\n    result.pathname = srcPath.length === 0 ? null : srcPath.join(\"/\");\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result._href = \"\";\n    return result;\n};\n\nvar punycode = __webpack_require__(/*! punycode */ \"punycode\");\nUrl.prototype._hostIdna = function Url$_hostIdna(hostname) {\n    // IDNA Support: Returns a punycoded representation of \"domain\".\n    // It only converts parts of the domain name that\n    // have non-ASCII characters, i.e. it doesn't matter if\n    // you call it with a domain that already is ASCII-only.\n    return punycode.toASCII(hostname);\n};\n\nvar escapePathName = Url.prototype._escapePathName =\nfunction Url$_escapePathName(pathname) {\n    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {\n        return pathname;\n    }\n    //Avoid closure creation to keep this inlinable\n    return _escapePath(pathname);\n};\n\nvar escapeSearch = Url.prototype._escapeSearch =\nfunction Url$_escapeSearch(search) {\n    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;\n    //Avoid closure creation to keep this inlinable\n    return _escapeSearch(search);\n};\n\nUrl.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {\n    var doLowerCase = false;\n    var protocolCharacters = this._protocolCharacters;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x3A /*':'*/) {\n            var protocol = str.slice(start, i);\n            if (doLowerCase) protocol = protocol.toLowerCase();\n            this._protocol = protocol;\n            return i + 1;\n        }\n        else if (protocolCharacters[ch] === 1) {\n            if (ch < 0x61 /*'a'*/)\n                doLowerCase = true;\n        }\n        else {\n            return start;\n        }\n\n    }\n    return start;\n};\n\nUrl.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {\n    var auth = str.slice(start, end + 1);\n    if (decode) {\n        auth = decodeURIComponent(auth);\n    }\n    this.auth = auth;\n};\n\nUrl.prototype._parsePort = function Url$_parsePort(str, start, end) {\n    //Internal format is integer for more efficient parsing\n    //and for efficient trimming of leading zeros\n    var port = 0;\n    //Distinguish between :0 and : (no port number at all)\n    var hadChars = false;\n    var validPort = true;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {\n            port = (10 * port) + (ch - 0x30 /*'0'*/);\n            hadChars = true;\n        }\n        else {\n            validPort = false;\n            if (ch === 0x5C/*'\\'*/ || ch === 0x2F/*'/'*/) {\n                validPort = true;\n            }\n            break;\n        }\n\n    }\n    if ((port === 0 && !hadChars) || !validPort) {\n        if (!validPort) {\n            this._port = -2;\n        }\n        return 0;\n    }\n\n    this._port = port;\n    return i - start;\n};\n\nUrl.prototype._parseHost =\nfunction Url$_parseHost(str, start, end, slashesDenoteHost) {\n    var hostEndingCharacters = this._hostEndingCharacters;\n    var first = str.charCodeAt(start);\n    var second = str.charCodeAt(start + 1);\n    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\\'*/) &&\n        (second === 0x2F /*'/'*/ || second === 0x5C /*'\\'*/)) {\n        this.slashes = true;\n\n        //The string starts with //\n        if (start === 0) {\n            //The string is just \"//\"\n            if (end < 2) return start;\n            //If slashes do not denote host and there is no auth,\n            //there is no host when the string starts with //\n            var hasAuth =\n                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);\n            if (!hasAuth && !slashesDenoteHost) {\n                this.slashes = null;\n                return start;\n            }\n        }\n        //There is a host that starts after the //\n        start += 2;\n    }\n    //If there is no slashes, there is no hostname if\n    //1. there was no protocol at all\n    else if (!this._protocol ||\n        //2. there was a protocol that requires slashes\n        //e.g. in 'http:asd' 'asd' is not a hostname\n        slashProtocols[this._protocol]\n    ) {\n        return start;\n    }\n\n    var doLowerCase = false;\n    var idna = false;\n    var hostNameStart = start;\n    var hostNameEnd = end;\n    var lastCh = -1;\n    var portLength = 0;\n    var charsAfterDot = 0;\n    var authNeedsDecoding = false;\n\n    var j = -1;\n\n    //Find the last occurrence of an @-sign until hostending character is met\n    //also mark if decoding is needed for the auth portion\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x40 /*'@'*/) {\n            j = i;\n        }\n        //This check is very, very cheap. Unneeded decodeURIComponent is very\n        //very expensive\n        else if (ch === 0x25 /*'%'*/) {\n            authNeedsDecoding = true;\n        }\n        else if (hostEndingCharacters[ch] === 1) {\n            break;\n        }\n    }\n\n    //@-sign was found at index j, everything to the left from it\n    //is auth part\n    if (j > -1) {\n        this._parseAuth(str, start, j - 1, authNeedsDecoding);\n        //hostname starts after the last @-sign\n        start = hostNameStart = j + 1;\n    }\n\n    //Host name is starting with a [\n    if (str.charCodeAt(start) === 0x5B /*'['*/) {\n        for (var i = start + 1; i <= end; ++i) {\n            var ch = str.charCodeAt(i);\n\n            //Assume valid IP6 is between the brackets\n            if (ch === 0x5D /*']'*/) {\n                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {\n                    portLength = this._parsePort(str, i + 2, end) + 1;\n                }\n                var hostname = str.slice(start + 1, i).toLowerCase();\n                this.hostname = hostname;\n                this.host = this._port > 0 ?\n                    \"[\" + hostname + \"]:\" + this._port :\n                    \"[\" + hostname + \"]\";\n                this.pathname = \"/\";\n                return i + portLength + 1;\n            }\n        }\n        //Empty hostname, [ starts a path\n        return start;\n    }\n\n    for (var i = start; i <= end; ++i) {\n        if (charsAfterDot > 62) {\n            this.hostname = this.host = str.slice(start, i);\n            return i;\n        }\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x3A /*':'*/) {\n            portLength = this._parsePort(str, i + 1, end) + 1;\n            hostNameEnd = i - 1;\n            break;\n        }\n        else if (ch < 0x61 /*'a'*/) {\n            if (ch === 0x2E /*'.'*/) {\n                //Node.js ignores this error\n                /*\n                if (lastCh === DOT || lastCh === -1) {\n                    this.hostname = this.host = \"\";\n                    return start;\n                }\n                */\n                charsAfterDot = -1;\n            }\n            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {\n                doLowerCase = true;\n            }\n            //Valid characters other than ASCII letters -, _, +, 0-9\n            else if (!(ch === 0x2D /*'-'*/ ||\n                       ch === 0x5F /*'_'*/ ||\n                       ch === 0x2B /*'+'*/ ||\n                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))\n                ) {\n                if (hostEndingCharacters[ch] === 0 &&\n                    this._noPrependSlashHostEnders[ch] === 0) {\n                    this._prependSlash = true;\n                }\n                hostNameEnd = i - 1;\n                break;\n            }\n        }\n        else if (ch >= 0x7B /*'{'*/) {\n            if (ch <= 0x7E /*'~'*/) {\n                if (this._noPrependSlashHostEnders[ch] === 0) {\n                    this._prependSlash = true;\n                }\n                hostNameEnd = i - 1;\n                break;\n            }\n            idna = true;\n        }\n        lastCh = ch;\n        charsAfterDot++;\n    }\n\n    //Node.js ignores this error\n    /*\n    if (lastCh === DOT) {\n        hostNameEnd--;\n    }\n    */\n\n    if (hostNameEnd + 1 !== start &&\n        hostNameEnd - hostNameStart <= 256) {\n        var hostname = str.slice(hostNameStart, hostNameEnd + 1);\n        if (doLowerCase) hostname = hostname.toLowerCase();\n        if (idna) hostname = this._hostIdna(hostname);\n        this.hostname = hostname;\n        this.host = this._port > 0 ? hostname + \":\" + this._port : hostname;\n    }\n\n    return hostNameEnd + 1 + portLength;\n\n};\n\nUrl.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {\n    if (!noProtocol) {\n        input._protocol = this._protocol;\n    }\n    input._href = this._href;\n    input._port = this._port;\n    input._prependSlash = this._prependSlash;\n    input.auth = this.auth;\n    input.slashes = this.slashes;\n    input.host = this.host;\n    input.hostname = this.hostname;\n    input.hash = this.hash;\n    input.search = this.search;\n    input.pathname = this.pathname;\n};\n\nUrl.prototype._clone = function Url$_clone() {\n    var ret = new Url();\n    ret._protocol = this._protocol;\n    ret._href = this._href;\n    ret._port = this._port;\n    ret._prependSlash = this._prependSlash;\n    ret.auth = this.auth;\n    ret.slashes = this.slashes;\n    ret.host = this.host;\n    ret.hostname = this.hostname;\n    ret.hash = this.hash;\n    ret.search = this.search;\n    ret.pathname = this.pathname;\n    return ret;\n};\n\nUrl.prototype._getComponentEscaped =\nfunction Url$_getComponentEscaped(str, start, end, isAfterQuery) {\n    var cur = start;\n    var i = start;\n    var ret = \"\";\n    var autoEscapeMap = isAfterQuery ?\n        this._afterQueryAutoEscapeMap : this._autoEscapeMap;\n    for (; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n        var escaped = autoEscapeMap[ch];\n\n        if (escaped !== \"\" && escaped !== undefined) {\n            if (cur < i) ret += str.slice(cur, i);\n            ret += escaped;\n            cur = i + 1;\n        }\n    }\n    if (cur < i + 1) ret += str.slice(cur, i);\n    return ret;\n};\n\nUrl.prototype._parsePath =\nfunction Url$_parsePath(str, start, end, disableAutoEscapeChars) {\n    var pathStart = start;\n    var pathEnd = end;\n    var escape = false;\n    var autoEscapeCharacters = this._autoEscapeCharacters;\n    var prePath = this._port === -2 ? \"/:\" : \"\";\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n        if (ch === 0x23 /*'#'*/) {\n          this._parseHash(str, i, end, disableAutoEscapeChars);\n            pathEnd = i - 1;\n            break;\n        }\n        else if (ch === 0x3F /*'?'*/) {\n            this._parseQuery(str, i, end, disableAutoEscapeChars);\n            pathEnd = i - 1;\n            break;\n        }\n        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n            escape = true;\n        }\n    }\n\n    if (pathStart > pathEnd) {\n        this.pathname = prePath === \"\" ? \"/\" : prePath;\n        return;\n    }\n\n    var path;\n    if (escape) {\n        path = this._getComponentEscaped(str, pathStart, pathEnd, false);\n    }\n    else {\n        path = str.slice(pathStart, pathEnd + 1);\n    }\n    this.pathname = prePath === \"\"\n        ? (this._prependSlash ? \"/\" + path : path)\n        : prePath + path;\n};\n\nUrl.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {\n    var queryStart = start;\n    var queryEnd = end;\n    var escape = false;\n    var autoEscapeCharacters = this._autoEscapeCharacters;\n\n    for (var i = start; i <= end; ++i) {\n        var ch = str.charCodeAt(i);\n\n        if (ch === 0x23 /*'#'*/) {\n            this._parseHash(str, i, end, disableAutoEscapeChars);\n            queryEnd = i - 1;\n            break;\n        }\n        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {\n            escape = true;\n        }\n    }\n\n    if (queryStart > queryEnd) {\n        this.search = \"\";\n        return;\n    }\n\n    var query;\n    if (escape) {\n        query = this._getComponentEscaped(str, queryStart, queryEnd, true);\n    }\n    else {\n        query = str.slice(queryStart, queryEnd + 1);\n    }\n    this.search = query;\n};\n\nUrl.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {\n    if (start > end) {\n        this.hash = \"\";\n        return;\n    }\n\n    this.hash = disableAutoEscapeChars ?\n        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);\n};\n\nObject.defineProperty(Url.prototype, \"port\", {\n    get: function() {\n        if (this._port >= 0) {\n            return (\"\" + this._port);\n        }\n        return null;\n    },\n    set: function(v) {\n        if (v == null) {\n            this._port = -1;\n        }\n        else {\n            this._port = parseInt(v, 10);\n        }\n    }\n});\n\nObject.defineProperty(Url.prototype, \"query\", {\n    get: function() {\n        var query = this._query;\n        if (query != null) {\n            return query;\n        }\n        var search = this.search;\n\n        if (search) {\n            if (search.charCodeAt(0) === 0x3F /*'?'*/) {\n                search = search.slice(1);\n            }\n            if (search !== \"\") {\n                this._query = search;\n                return search;\n            }\n        }\n        return search;\n    },\n    set: function(v) {\n        this._query = v;\n    }\n});\n\nObject.defineProperty(Url.prototype, \"path\", {\n    get: function() {\n        var p = this.pathname || \"\";\n        var s = this.search || \"\";\n        if (p || s) {\n            return p + s;\n        }\n        return (p == null && s) ? (\"/\" + s) : null;\n    },\n    set: function() {}\n});\n\nObject.defineProperty(Url.prototype, \"protocol\", {\n    get: function() {\n        var proto = this._protocol;\n        return proto ? proto + \":\" : proto;\n    },\n    set: function(v) {\n        if (typeof v === \"string\") {\n            var end = v.length - 1;\n            if (v.charCodeAt(end) === 0x3A /*':'*/) {\n                this._protocol = v.slice(0, end);\n            }\n            else {\n                this._protocol = v;\n            }\n        }\n        else if (v == null) {\n            this._protocol = null;\n        }\n    }\n});\n\nObject.defineProperty(Url.prototype, \"href\", {\n    get: function() {\n        var href = this._href;\n        if (!href) {\n            href = this._href = this.format();\n        }\n        return href;\n    },\n    set: function(v) {\n        this._href = v;\n    }\n});\n\nUrl.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {\n    if (str instanceof Url) return str;\n    var ret = new Url();\n    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);\n    return ret;\n};\n\nUrl.format = function Url$Format(obj) {\n    if (typeof obj === \"string\") {\n        obj = Url.parse(obj);\n    }\n    if (!(obj instanceof Url)) {\n        return Url.prototype.format.call(obj);\n    }\n    return obj.format();\n};\n\nUrl.resolve = function Url$Resolve(source, relative) {\n    return Url.parse(source, false, true).resolve(relative);\n};\n\nUrl.resolveObject = function Url$ResolveObject(source, relative) {\n    if (!source) return relative;\n    return Url.parse(source, false, true).resolveObject(relative);\n};\n\nfunction _escapePath(pathname) {\n    return pathname.replace(/[?#]/g, function(match) {\n        return encodeURIComponent(match);\n    });\n}\n\nfunction _escapeSearch(search) {\n    return search.replace(/#/g, function(match) {\n        return encodeURIComponent(match);\n    });\n}\n\n//Search `char1` (integer code for a character) in `string`\n//starting from `fromIndex` and ending at `string.length - 1`\n//or when a stop character is found\nfunction containsCharacter(string, char1, fromIndex, stopCharacterTable) {\n    var len = string.length;\n    for (var i = fromIndex; i < len; ++i) {\n        var ch = string.charCodeAt(i);\n\n        if (ch === char1) {\n            return true;\n        }\n        else if (stopCharacterTable[ch] === 1) {\n            return false;\n        }\n    }\n    return false;\n}\n\n//See if `char1` or `char2` (integer codes for characters)\n//is contained in `string`\nfunction containsCharacter2(string, char1, char2) {\n    for (var i = 0, len = string.length; i < len; ++i) {\n        var ch = string.charCodeAt(i);\n        if (ch === char1 || ch === char2) return true;\n    }\n    return false;\n}\n\n//Makes an array of 128 uint8's which represent boolean values.\n//Spec is an array of ascii code points or ascii code point ranges\n//ranges are expressed as [start, end]\n\n//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and\n//0x7A (lowercaseletter 'z') as `true`:\n//\n//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);\n//a[0x30]; //1\n//a[0x15]; //0\n//a[0x35]; //1\nfunction makeAsciiTable(spec) {\n    var ret = new Uint8Array(128);\n    spec.forEach(function(item){\n        if (typeof item === \"number\") {\n            ret[item] = 1;\n        }\n        else {\n            var start = item[0];\n            var end = item[1];\n            for (var j = start; j <= end; ++j) {\n                ret[j] = 1;\n            }\n        }\n    });\n\n    return ret;\n}\n\n\nvar autoEscape = [\"<\", \">\", \"\\\"\", \"`\", \" \", \"\\r\", \"\\n\",\n    \"\\t\", \"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\", \"'\"];\n\nvar autoEscapeMap = new Array(128);\n\n\n\nfor (var i = 0, len = autoEscapeMap.length; i < len; ++i) {\n    autoEscapeMap[i] = \"\";\n}\n\nfor (var i = 0, len = autoEscape.length; i < len; ++i) {\n    var c = autoEscape[i];\n    var esc = encodeURIComponent(c);\n    if (esc === c) {\n        esc = escape(c);\n    }\n    autoEscapeMap[c.charCodeAt(0)] = esc;\n}\nvar afterQueryAutoEscapeMap = autoEscapeMap.slice();\nautoEscapeMap[0x5C /*'\\'*/] = \"/\";\n\nvar slashProtocols = Url.prototype._slashProtocols = {\n    http: true,\n    https: true,\n    gopher: true,\n    file: true,\n    ftp: true,\n\n    \"http:\": true,\n    \"https:\": true,\n    \"gopher:\": true,\n    \"file:\": true,\n    \"ftp:\": true\n};\n\n//Optimize back from normalized object caused by non-identifier keys\nfunction f(){}\nf.prototype = slashProtocols;\n\nUrl.prototype._protocolCharacters = makeAsciiTable([\n    [0x61 /*'a'*/, 0x7A /*'z'*/],\n    [0x41 /*'A'*/, 0x5A /*'Z'*/],\n    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/\n]);\n\nUrl.prototype._hostEndingCharacters = makeAsciiTable([\n    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\\'*/\n]);\n\nUrl.prototype._autoEscapeCharacters = makeAsciiTable(\n    autoEscape.map(function(v) {\n        return v.charCodeAt(0);\n    })\n);\n\n//If these characters end a host name, the path will not be prepended a /\nUrl.prototype._noPrependSlashHostEnders = makeAsciiTable(\n    [\n        \"<\", \">\", \"'\", \"`\", \" \", \"\\r\",\n        \"\\n\", \"\\t\", \"{\", \"}\", \"|\",\n        \"^\", \"`\", \"\\\"\", \"%\", \";\"\n    ].map(function(v) {\n        return v.charCodeAt(0);\n    })\n);\n\nUrl.prototype._autoEscapeMap = autoEscapeMap;\nUrl.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;\n\nmodule.exports = Url;\n\nUrl.replace = function Url$Replace() {\n    __webpack_require__.c.url = {\n        exports: Url\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmwtcGFyc2VyQDEuMS4zL25vZGVfbW9kdWxlcy9mYXN0LXVybC1wYXJzZXIvc3JjL3VybHBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDBCQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsVUFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsVUFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBLFlBQVksS0FBSzs7QUFFakI7Ozs7QUFJQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxxQkFBYTtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FkMTkvRG9jdW1lbnRzL2Fuc2FybS1maWxlLXNlcnZlci9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmwtcGFyc2VyQDEuMS4zL25vZGVfbW9kdWxlcy9mYXN0LXVybC1wYXJzZXIvc3JjL3VybHBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cbmZ1bmN0aW9uIFVybCgpIHtcbiAgICAvL0ZvciBtb3JlIGVmZmljaWVudCBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBhbmQgbGF6aW5lc3MuXG4gICAgLy9UaGUgbm9uLXVuZGVyc2NvcmUgdmVyc2lvbnMgb2YgdGhlc2UgcHJvcGVydGllcyBhcmUgYWNjZXNzb3IgZnVuY3Rpb25zXG4gICAgLy9kZWZpbmVkIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgdGhpcy5fcHJvdG9jb2wgPSBudWxsO1xuICAgIHRoaXMuX2hyZWYgPSBcIlwiO1xuICAgIHRoaXMuX3BvcnQgPSAtMTtcbiAgICB0aGlzLl9xdWVyeSA9IG51bGw7XG5cbiAgICB0aGlzLmF1dGggPSBudWxsO1xuICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3ByZXBlbmRTbGFzaCA9IGZhbHNlO1xufVxuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5cblVybC5xdWVyeVN0cmluZyA9IHF1ZXJ5c3RyaW5nO1xuXG5VcmwucHJvdG90eXBlLnBhcnNlID1cbmZ1bmN0aW9uIFVybCRwYXJzZShzdHIsIHBhcnNlUXVlcnlTdHJpbmcsIGhvc3REZW5vdGVzU2xhc2gsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArXG4gICAgICAgICAgICB0eXBlb2Ygc3RyKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgICAvL1RyaW0gbGVhZGluZyBhbmQgdHJhaWxpbmcgd3NcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpIDw9IDB4MjAgLyonICcqLykgc3RhcnQrKztcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoZW5kKSA8PSAweDIwIC8qJyAnKi8pIGVuZC0tO1xuXG4gICAgc3RhcnQgPSB0aGlzLl9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCk7XG5cbiAgICAvL0phdmFzY3JpcHQgZG9lc24ndCBoYXZlIGhvc3RcbiAgICBpZiAodGhpcy5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgaG9zdERlbm90ZXNTbGFzaCk7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICBpZiAoIXRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaFByb3RvY29sc1twcm90b10pKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MkYgLyonLycqLyB8fCBjaCA9PT0gMHg1QyAvKidcXCcqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0YgLyonPycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZUhhc2goc3RyLCBzdGFydCwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUGF0aChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL0ZvciBqYXZhc2NyaXB0IHRoZSBwYXRobmFtZSBpcyBqdXN0IHRoZSByZXN0IG9mIGl0XG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxICk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXRobmFtZSAmJiB0aGlzLmhvc3RuYW1lICYmXG4gICAgICAgIHRoaXMuX3NsYXNoUHJvdG9jb2xzW3RoaXMuX3Byb3RvY29sXSkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgICAgICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoLmNoYXJDb2RlQXQoMCkgPT09IDB4M0YgLyonPycqLykge1xuICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBjYWxscyBhIHNldHRlciBmdW5jdGlvbiwgdGhlcmUgaXMgbm8gLnF1ZXJ5IGRhdGEgcHJvcGVydHlcbiAgICAgICAgdGhpcy5xdWVyeSA9IFVybC5xdWVyeVN0cmluZy5wYXJzZShzZWFyY2gpO1xuICAgIH1cbn07XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIFVybCRyZXNvbHZlKHJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdChVcmwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIFVybCRmb3JtYXQoKSB7XG4gICAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgXCJcIjtcblxuICAgIGlmIChhdXRoKSB7XG4gICAgICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCBcIjpcIik7XG4gICAgICAgIGF1dGggKz0gXCJAXCI7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCBcIlwiO1xuICAgIHZhciBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgXCJcIjtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCB8fCBcIlwiO1xuICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCBcIlwiO1xuICAgIHZhciBxdWVyeSA9IFwiXCI7XG4gICAgdmFyIGhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCBcIlwiO1xuICAgIHZhciBwb3J0ID0gdGhpcy5wb3J0IHx8IFwiXCI7XG4gICAgdmFyIGhvc3QgPSBmYWxzZTtcbiAgICB2YXIgc2NoZW1lID0gXCJcIjtcblxuICAgIC8vQ2FjaGUgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0dGVyIGZ1bmN0aW9uXG4gICAgdmFyIHEgPSB0aGlzLnF1ZXJ5O1xuICAgIGlmIChxICYmIHR5cGVvZiBxID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHF1ZXJ5ID0gVXJsLnF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShxKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICBzZWFyY2ggPSBxdWVyeSA/IFwiP1wiICsgcXVlcnkgOiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQ29kZUF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAweDNBIC8qJzonKi8pXG4gICAgICAgIHByb3RvY29sICs9IFwiOlwiO1xuXG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgdmFyIGlwNiA9IGhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID4gLTE7XG4gICAgICAgIGlmIChpcDYpIGhvc3RuYW1lID0gXCJbXCIgKyBob3N0bmFtZSArIFwiXVwiO1xuICAgICAgICBob3N0ID0gYXV0aCArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc2xhc2hlcyA9IHRoaXMuc2xhc2hlcyB8fFxuICAgICAgICAoKCFwcm90b2NvbCB8fFxuICAgICAgICBzbGFzaFByb3RvY29sc1twcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKTtcblxuXG4gICAgaWYgKHByb3RvY29sKSBzY2hlbWUgPSBwcm90b2NvbCArIChzbGFzaGVzID8gXCIvL1wiIDogXCJcIik7XG4gICAgZWxzZSBpZiAoc2xhc2hlcykgc2NoZW1lID0gXCIvL1wiO1xuXG4gICAgaWYgKHNsYXNoZXMgJiYgcGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckNvZGVBdCgwKSAhPT0gMHgyRiAvKicvJyovKSB7XG4gICAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckNvZGVBdCgwKSAhPT0gMHgzRiAvKic/JyovKVxuICAgICAgICBzZWFyY2ggPSBcIj9cIiArIHNlYXJjaDtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJDb2RlQXQoMCkgIT09IDB4MjMgLyonIycqLylcbiAgICAgICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcblxuICAgIHBhdGhuYW1lID0gZXNjYXBlUGF0aE5hbWUocGF0aG5hbWUpO1xuICAgIHNlYXJjaCA9IGVzY2FwZVNlYXJjaChzZWFyY2gpO1xuXG4gICAgcmV0dXJuIHNjaGVtZSArIChob3N0ID09PSBmYWxzZSA/IFwiXCIgOiBob3N0KSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRyZXNvbHZlT2JqZWN0KHJlbGF0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiByZWxhdGl2ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVsYXRpdmUgPSBVcmwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9jbG9uZSgpO1xuXG4gICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gICAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZVwicyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgICBpZiAoIXJlbGF0aXZlLmhyZWYpIHtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IHJlc3VsdC5fcHJvdG9jb2wpIHtcbiAgICAgICAgLy8gaWYgaXRcInMgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICAgIC8vIGZpcnN0LCBpZiBpdFwicyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAgICAvLyBiZWNhdXNlIHRoYXRcInMga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgICAgaWYgKCFzbGFzaFByb3RvY29sc1tyZWxhdGl2ZS5fcHJvdG9jb2xdKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5fY29weVByb3BzVG8ocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5fcHJvdG9jb2wgPSByZWxhdGl2ZS5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09IFwiXCIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbihcIi9cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCBcIlwiO1xuICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IHJlbGF0aXZlLl9wb3J0O1xuICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzU291cmNlQWJzID1cbiAgICAgICAgKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKTtcbiAgICB2YXIgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgICAocmVsYXRpdmUucGF0aG5hbWUgJiZcbiAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLylcbiAgICAgICAgKTtcbiAgICB2YXIgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSk7XG5cbiAgICB2YXIgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnM7XG5cbiAgICB2YXIgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciBwc3ljaG90aWMgPSByZXN1bHQuX3Byb3RvY29sICYmICFzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXTtcblxuICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gICAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICByZXN1bHQuX3BvcnQgPSAtMTtcbiAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gXCJcIikgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gXCJcIjtcbiAgICAgICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCkge1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgcmVsYXRpdmUuX3BvcnQgPSAtMTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09IFwiXCIpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09IFwiXCIgfHwgc3JjUGF0aFswXSA9PT0gXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgIC8vIGl0XCJzIGFic29sdXRlLlxuICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgP1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICAgIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gaXRcInMgcmVsYXRpdmVcbiAgICAgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgICAgICBzcmNQYXRoLnBvcCgpO1xuICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgfSBlbHNlIGlmIChyZWxhdGl2ZS5zZWFyY2gpIHtcbiAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAgICAvLyBsaWtlIGhyZWY9XCI/Zm9vXCIuXG4gICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KFwibWFpbHRvOmxvY2FsMUBkb21haW4xXCIsIFwibG9jYWwyQGRvbWFpbjJcIilcbiAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdChcIkBcIikgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgLy8gd2VcInZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICAgIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09IFwiLlwiIHx8IGxhc3QgPT09IFwiLi5cIikgfHxcbiAgICAgICAgbGFzdCA9PT0gXCJcIik7XG5cbiAgICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgICAgIGlmIChsYXN0ID09PSBcIi5cIikge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCIuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09IFwiXCIgJiZcbiAgICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckNvZGVBdCgwKSAhPT0gMHgyRiAvKicvJyovKSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbihcIi9cIikuc3Vic3RyKC0xKSAhPT0gXCIvXCIpKSB7XG4gICAgICAgIHNyY1BhdGgucHVzaChcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09IFwiXCIgfHxcbiAgICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApID09PSAweDJGIC8qJy8nKi8pO1xuXG4gICAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/IFwiXCIgOlxuICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiBcIlwiO1xuICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoXCJtYWlsdG86bG9jYWwxQGRvbWFpbjFcIiwgXCJsb2NhbDJAZG9tYWluMlwiKVxuICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoXCJAXCIpID4gMCA/XG4gICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdChcIkBcIikgOiBmYWxzZTtcbiAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgc3JjUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGgubGVuZ3RoID09PSAwID8gbnVsbCA6IHNyY1BhdGguam9pbihcIi9cIik7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKFwicHVueWNvZGVcIik7XG5VcmwucHJvdG90eXBlLl9ob3N0SWRuYSA9IGZ1bmN0aW9uIFVybCRfaG9zdElkbmEoaG9zdG5hbWUpIHtcbiAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgcmV0dXJuIHB1bnljb2RlLnRvQVNDSUkoaG9zdG5hbWUpO1xufTtcblxudmFyIGVzY2FwZVBhdGhOYW1lID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlUGF0aE5hbWUgPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVQYXRoTmFtZShwYXRobmFtZSkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHBhdGhuYW1lLCAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlUGF0aChwYXRobmFtZSk7XG59O1xuXG52YXIgZXNjYXBlU2VhcmNoID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlU2VhcmNoID1cbmZ1bmN0aW9uIFVybCRfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHNlYXJjaCwgMHgyMyAvKicjJyovLCAtMSkpIHJldHVybiBzZWFyY2g7XG4gICAgLy9Bdm9pZCBjbG9zdXJlIGNyZWF0aW9uIHRvIGtlZXAgdGhpcyBpbmxpbmFibGVcbiAgICByZXR1cm4gX2VzY2FwZVNlYXJjaChzZWFyY2gpO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQcm90b2NvbCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQcm90b2NvbChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgcHJvdG9jb2xDaGFyYWN0ZXJzID0gdGhpcy5fcHJvdG9jb2xDaGFyYWN0ZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBzdHIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaWYgKGRvTG93ZXJDYXNlKSBwcm90b2NvbCA9IHByb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3RvY29sQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChjaCA8IDB4NjEgLyonYScqLylcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUF1dGggPSBmdW5jdGlvbiBVcmwkX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBlbmQsIGRlY29kZSkge1xuICAgIHZhciBhdXRoID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICBpZiAoZGVjb2RlKSB7XG4gICAgICAgIGF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVBvcnQgPSBmdW5jdGlvbiBVcmwkX3BhcnNlUG9ydChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAvL0ludGVybmFsIGZvcm1hdCBpcyBpbnRlZ2VyIGZvciBtb3JlIGVmZmljaWVudCBwYXJzaW5nXG4gICAgLy9hbmQgZm9yIGVmZmljaWVudCB0cmltbWluZyBvZiBsZWFkaW5nIHplcm9zXG4gICAgdmFyIHBvcnQgPSAwO1xuICAgIC8vRGlzdGluZ3Vpc2ggYmV0d2VlbiA6MCBhbmQgOiAobm8gcG9ydCBudW1iZXIgYXQgYWxsKVxuICAgIHZhciBoYWRDaGFycyA9IGZhbHNlO1xuICAgIHZhciB2YWxpZFBvcnQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSB7XG4gICAgICAgICAgICBwb3J0ID0gKDEwICogcG9ydCkgKyAoY2ggLSAweDMwIC8qJzAnKi8pO1xuICAgICAgICAgICAgaGFkQ2hhcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRQb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMvKidcXCcqLyB8fCBjaCA9PT0gMHgyRi8qJy8nKi8pIHtcbiAgICAgICAgICAgICAgICB2YWxpZFBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICBpZiAoKHBvcnQgPT09IDAgJiYgIWhhZENoYXJzKSB8fCAhdmFsaWRQb3J0KSB7XG4gICAgICAgIGlmICghdmFsaWRQb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgcmV0dXJuIGkgLSBzdGFydDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlSG9zdCA9XG5mdW5jdGlvbiBVcmwkX3BhcnNlSG9zdChzdHIsIHN0YXJ0LCBlbmQsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgdmFyIGhvc3RFbmRpbmdDaGFyYWN0ZXJzID0gdGhpcy5faG9zdEVuZGluZ0NoYXJhY3RlcnM7XG4gICAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgIHZhciBzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChzdGFydCArIDEpO1xuICAgIGlmICgoZmlyc3QgPT09IDB4MkYgLyonLycqLyB8fCBmaXJzdCA9PT0gMHg1QyAvKidcXCcqLykgJiZcbiAgICAgICAgKHNlY29uZCA9PT0gMHgyRiAvKicvJyovIHx8IHNlY29uZCA9PT0gMHg1QyAvKidcXCcqLykpIHtcbiAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcblxuICAgICAgICAvL1RoZSBzdHJpbmcgc3RhcnRzIHdpdGggLy9cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAvL1RoZSBzdHJpbmcgaXMganVzdCBcIi8vXCJcbiAgICAgICAgICAgIGlmIChlbmQgPCAyKSByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAvL0lmIHNsYXNoZXMgZG8gbm90IGRlbm90ZSBob3N0IGFuZCB0aGVyZSBpcyBubyBhdXRoLFxuICAgICAgICAgICAgLy90aGVyZSBpcyBubyBob3N0IHdoZW4gdGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICAgICAgdmFyIGhhc0F1dGggPVxuICAgICAgICAgICAgICAgIGNvbnRhaW5zQ2hhcmFjdGVyKHN0ciwgMHg0MCAvKidAJyovLCAyLCBob3N0RW5kaW5nQ2hhcmFjdGVycyk7XG4gICAgICAgICAgICBpZiAoIWhhc0F1dGggJiYgIXNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGVyZSBpcyBhIGhvc3QgdGhhdCBzdGFydHMgYWZ0ZXIgdGhlIC8vXG4gICAgICAgIHN0YXJ0ICs9IDI7XG4gICAgfVxuICAgIC8vSWYgdGhlcmUgaXMgbm8gc2xhc2hlcywgdGhlcmUgaXMgbm8gaG9zdG5hbWUgaWZcbiAgICAvLzEuIHRoZXJlIHdhcyBubyBwcm90b2NvbCBhdCBhbGxcbiAgICBlbHNlIGlmICghdGhpcy5fcHJvdG9jb2wgfHxcbiAgICAgICAgLy8yLiB0aGVyZSB3YXMgYSBwcm90b2NvbCB0aGF0IHJlcXVpcmVzIHNsYXNoZXNcbiAgICAgICAgLy9lLmcuIGluICdodHRwOmFzZCcgJ2FzZCcgaXMgbm90IGEgaG9zdG5hbWVcbiAgICAgICAgc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgaWRuYSA9IGZhbHNlO1xuICAgIHZhciBob3N0TmFtZVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIGhvc3ROYW1lRW5kID0gZW5kO1xuICAgIHZhciBsYXN0Q2ggPSAtMTtcbiAgICB2YXIgcG9ydExlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXJzQWZ0ZXJEb3QgPSAwO1xuICAgIHZhciBhdXRoTmVlZHNEZWNvZGluZyA9IGZhbHNlO1xuXG4gICAgdmFyIGogPSAtMTtcblxuICAgIC8vRmluZCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIEAtc2lnbiB1bnRpbCBob3N0ZW5kaW5nIGNoYXJhY3RlciBpcyBtZXRcbiAgICAvL2Fsc28gbWFyayBpZiBkZWNvZGluZyBpcyBuZWVkZWQgZm9yIHRoZSBhdXRoIHBvcnRpb25cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDQwIC8qJ0AnKi8pIHtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBjaGVjayBpcyB2ZXJ5LCB2ZXJ5IGNoZWFwLiBVbm5lZWRlZCBkZWNvZGVVUklDb21wb25lbnQgaXMgdmVyeVxuICAgICAgICAvL3ZlcnkgZXhwZW5zaXZlXG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDI1IC8qJyUnKi8pIHtcbiAgICAgICAgICAgIGF1dGhOZWVkc0RlY29kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob3N0RW5kaW5nQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9ALXNpZ24gd2FzIGZvdW5kIGF0IGluZGV4IGosIGV2ZXJ5dGhpbmcgdG8gdGhlIGxlZnQgZnJvbSBpdFxuICAgIC8vaXMgYXV0aCBwYXJ0XG4gICAgaWYgKGogPiAtMSkge1xuICAgICAgICB0aGlzLl9wYXJzZUF1dGgoc3RyLCBzdGFydCwgaiAtIDEsIGF1dGhOZWVkc0RlY29kaW5nKTtcbiAgICAgICAgLy9ob3N0bmFtZSBzdGFydHMgYWZ0ZXIgdGhlIGxhc3QgQC1zaWduXG4gICAgICAgIHN0YXJ0ID0gaG9zdE5hbWVTdGFydCA9IGogKyAxO1xuICAgIH1cblxuICAgIC8vSG9zdCBuYW1lIGlzIHN0YXJ0aW5nIHdpdGggYSBbXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QiAvKidbJyovKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAvL0Fzc3VtZSB2YWxpZCBJUDYgaXMgYmV0d2VlbiB0aGUgYnJhY2tldHNcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1RCAvKiddJyovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRMZW5ndGggPSB0aGlzLl9wYXJzZVBvcnQoc3RyLCBpICsgMiwgZW5kKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBob3N0bmFtZSA9IHN0ci5zbGljZShzdGFydCArIDEsIGkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IHRoaXMuX3BvcnQgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgXCJbXCIgKyBob3N0bmFtZSArIFwiXTpcIiArIHRoaXMuX3BvcnQgOlxuICAgICAgICAgICAgICAgICAgICBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgcG9ydExlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9FbXB0eSBob3N0bmFtZSwgWyBzdGFydHMgYSBwYXRoXG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJzQWZ0ZXJEb3QgPiA2Mikge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EgLyonOicqLykge1xuICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAxLCBlbmQpICsgMTtcbiAgICAgICAgICAgIGhvc3ROYW1lRW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA8IDB4NjEgLyonYScqLykge1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDJFIC8qJy4nKi8pIHtcbiAgICAgICAgICAgICAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoID09PSBET1QgfHwgbGFzdENoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNoYXJzQWZ0ZXJEb3QgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDB4NDEgLyonQScqLyA8PSBjaCAmJiBjaCA8PSAweDVBIC8qJ1onKi8pIHtcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1ZhbGlkIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBBU0NJSSBsZXR0ZXJzIC0sIF8sICssIDAtOVxuICAgICAgICAgICAgZWxzZSBpZiAoIShjaCA9PT0gMHgyRCAvKictJyovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoID09PSAweDVGIC8qJ18nKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2ggPT09IDB4MkIgLyonKycqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAoMHgzMCAvKicwJyovIDw9IGNoICYmIGNoIDw9IDB4MzkgLyonOScqLykpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RFbmRpbmdDaGFyYWN0ZXJzW2NoXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub1ByZXBlbmRTbGFzaEhvc3RFbmRlcnNbY2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBlbmRTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3ROYW1lRW5kID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPj0gMHg3QiAvKid7JyovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPD0gMHg3RSAvKid+JyovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkbmEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDaCA9IGNoO1xuICAgICAgICBjaGFyc0FmdGVyRG90Kys7XG4gICAgfVxuXG4gICAgLy9Ob2RlLmpzIGlnbm9yZXMgdGhpcyBlcnJvclxuICAgIC8qXG4gICAgaWYgKGxhc3RDaCA9PT0gRE9UKSB7XG4gICAgICAgIGhvc3ROYW1lRW5kLS07XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAoaG9zdE5hbWVFbmQgKyAxICE9PSBzdGFydCAmJlxuICAgICAgICBob3N0TmFtZUVuZCAtIGhvc3ROYW1lU3RhcnQgPD0gMjU2KSB7XG4gICAgICAgIHZhciBob3N0bmFtZSA9IHN0ci5zbGljZShob3N0TmFtZVN0YXJ0LCBob3N0TmFtZUVuZCArIDEpO1xuICAgICAgICBpZiAoZG9Mb3dlckNhc2UpIGhvc3RuYW1lID0gaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGlkbmEpIGhvc3RuYW1lID0gdGhpcy5faG9zdElkbmEoaG9zdG5hbWUpO1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IHRoaXMuX3BvcnQgPiAwID8gaG9zdG5hbWUgKyBcIjpcIiArIHRoaXMuX3BvcnQgOiBob3N0bmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdE5hbWVFbmQgKyAxICsgcG9ydExlbmd0aDtcblxufTtcblxuVXJsLnByb3RvdHlwZS5fY29weVByb3BzVG8gPSBmdW5jdGlvbiBVcmwkX2NvcHlQcm9wc1RvKGlucHV0LCBub1Byb3RvY29sKSB7XG4gICAgaWYgKCFub1Byb3RvY29sKSB7XG4gICAgICAgIGlucHV0Ll9wcm90b2NvbCA9IHRoaXMuX3Byb3RvY29sO1xuICAgIH1cbiAgICBpbnB1dC5faHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgaW5wdXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIGlucHV0Ll9wcmVwZW5kU2xhc2ggPSB0aGlzLl9wcmVwZW5kU2xhc2g7XG4gICAgaW5wdXQuYXV0aCA9IHRoaXMuYXV0aDtcbiAgICBpbnB1dC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIGlucHV0Lmhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgaW5wdXQuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lO1xuICAgIGlucHV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgaW5wdXQuc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgaW5wdXQucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lO1xufTtcblxuVXJsLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiBVcmwkX2Nsb25lKCkge1xuICAgIHZhciByZXQgPSBuZXcgVXJsKCk7XG4gICAgcmV0Ll9wcm90b2NvbCA9IHRoaXMuX3Byb3RvY29sO1xuICAgIHJldC5faHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgcmV0Ll9wb3J0ID0gdGhpcy5fcG9ydDtcbiAgICByZXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICByZXQuYXV0aCA9IHRoaXMuYXV0aDtcbiAgICByZXQuc2xhc2hlcyA9IHRoaXMuc2xhc2hlcztcbiAgICByZXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICByZXQuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lO1xuICAgIHJldC5oYXNoID0gdGhpcy5oYXNoO1xuICAgIHJldC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICByZXQucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9nZXRDb21wb25lbnRFc2NhcGVkID1cbmZ1bmN0aW9uIFVybCRfZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHN0YXJ0LCBlbmQsIGlzQWZ0ZXJRdWVyeSkge1xuICAgIHZhciBjdXIgPSBzdGFydDtcbiAgICB2YXIgaSA9IHN0YXJ0O1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBhdXRvRXNjYXBlTWFwID0gaXNBZnRlclF1ZXJ5ID9cbiAgICAgICAgdGhpcy5fYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXAgOiB0aGlzLl9hdXRvRXNjYXBlTWFwO1xuICAgIGZvciAoOyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgZXNjYXBlZCA9IGF1dG9Fc2NhcGVNYXBbY2hdO1xuXG4gICAgICAgIGlmIChlc2NhcGVkICE9PSBcIlwiICYmIGVzY2FwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGN1ciA8IGkpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICAgICAgICAgIHJldCArPSBlc2NhcGVkO1xuICAgICAgICAgICAgY3VyID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1ciA8IGkgKyAxKSByZXQgKz0gc3RyLnNsaWNlKGN1ciwgaSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUGF0aCA9XG5mdW5jdGlvbiBVcmwkX3BhcnNlUGF0aChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICB2YXIgcGF0aFN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHBhdGhFbmQgPSBlbmQ7XG4gICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xuICAgIHZhciBhdXRvRXNjYXBlQ2hhcmFjdGVycyA9IHRoaXMuX2F1dG9Fc2NhcGVDaGFyYWN0ZXJzO1xuICAgIHZhciBwcmVQYXRoID0gdGhpcy5fcG9ydCA9PT0gLTIgPyBcIi86XCIgOiBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIGksIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgICAgICBwYXRoRW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVF1ZXJ5KHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkaXNhYmxlQXV0b0VzY2FwZUNoYXJzICYmICFlc2NhcGUgJiYgYXV0b0VzY2FwZUNoYXJhY3RlcnNbY2hdID09PSAxKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGhTdGFydCA+IHBhdGhFbmQpIHtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHByZVBhdGggPT09IFwiXCIgPyBcIi9cIiA6IHByZVBhdGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aDtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcGF0aFN0YXJ0LCBwYXRoRW5kLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXRoID0gc3RyLnNsaWNlKHBhdGhTdGFydCwgcGF0aEVuZCArIDEpO1xuICAgIH1cbiAgICB0aGlzLnBhdGhuYW1lID0gcHJlUGF0aCA9PT0gXCJcIlxuICAgICAgICA/ICh0aGlzLl9wcmVwZW5kU2xhc2ggPyBcIi9cIiArIHBhdGggOiBwYXRoKVxuICAgICAgICA6IHByZVBhdGggKyBwYXRoO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VRdWVyeSA9IGZ1bmN0aW9uIFVybCRfcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICB2YXIgcXVlcnlTdGFydCA9IHN0YXJ0O1xuICAgIHZhciBxdWVyeUVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIGksIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgICAgICBxdWVyeUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgJiYgIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVlcnlTdGFydCA+IHF1ZXJ5RW5kKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWVyeTtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5fZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXJ5ID0gc3RyLnNsaWNlKHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoID0gcXVlcnk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUhhc2ggPSBmdW5jdGlvbiBVcmwkX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzaCA9IGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgP1xuICAgICAgICBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpIDogdGhpcy5fZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHN0YXJ0LCBlbmQsIHRydWUpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicG9ydFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnQgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIlwiICsgdGhpcy5fcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcG9ydCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHBhcnNlSW50KHYsIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJxdWVyeVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnk7XG4gICAgICAgIGlmIChxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuXG4gICAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlYXJjaCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9xdWVyeSA9IHY7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCBcIlwiO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8IFwiXCI7XG4gICAgICAgIGlmIChwIHx8IHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwICsgcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHAgPT0gbnVsbCAmJiBzKSA/IChcIi9cIiArIHMpIDogbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oKSB7fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLl9wcm90b2NvbDtcbiAgICAgICAgcmV0dXJuIHByb3RvID8gcHJvdG8gKyBcIjpcIiA6IHByb3RvO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGVuZCA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmICh2LmNoYXJDb2RlQXQoZW5kKSA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSB2LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwiaHJlZlwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB0aGlzLl9ocmVmO1xuICAgICAgICBpZiAoIWhyZWYpIHtcbiAgICAgICAgICAgIGhyZWYgPSB0aGlzLl9ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9ocmVmID0gdjtcbiAgICB9XG59KTtcblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gVXJsJFBhcnNlKHN0ciwgcGFyc2VRdWVyeVN0cmluZywgaG9zdERlbm90ZXNTbGFzaCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmIChzdHIgaW5zdGFuY2VvZiBVcmwpIHJldHVybiBzdHI7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQucGFyc2Uoc3RyLCAhIXBhcnNlUXVlcnlTdHJpbmcsICEhaG9zdERlbm90ZXNTbGFzaCwgISFkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLmZvcm1hdCA9IGZ1bmN0aW9uIFVybCRGb3JtYXQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb2JqID0gVXJsLnBhcnNlKG9iaik7XG4gICAgfVxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICAgICAgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn07XG5cblVybC5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59O1xuXG5VcmwucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59O1xuXG5mdW5jdGlvbiBfZXNjYXBlUGF0aChwYXRobmFtZSkge1xuICAgIHJldHVybiBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIHJldHVybiBzZWFyY2gucmVwbGFjZSgvIy9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgICB9KTtcbn1cblxuLy9TZWFyY2ggYGNoYXIxYCAoaW50ZWdlciBjb2RlIGZvciBhIGNoYXJhY3RlcikgaW4gYHN0cmluZ2Bcbi8vc3RhcnRpbmcgZnJvbSBgZnJvbUluZGV4YCBhbmQgZW5kaW5nIGF0IGBzdHJpbmcubGVuZ3RoIC0gMWBcbi8vb3Igd2hlbiBhIHN0b3AgY2hhcmFjdGVyIGlzIGZvdW5kXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcihzdHJpbmcsIGNoYXIxLCBmcm9tSW5kZXgsIHN0b3BDaGFyYWN0ZXJUYWJsZSkge1xuICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IGNoYXIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG9wQ2hhcmFjdGVyVGFibGVbY2hdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1NlZSBpZiBgY2hhcjFgIG9yIGBjaGFyMmAgKGludGVnZXIgY29kZXMgZm9yIGNoYXJhY3RlcnMpXG4vL2lzIGNvbnRhaW5lZCBpbiBgc3RyaW5nYFxuZnVuY3Rpb24gY29udGFpbnNDaGFyYWN0ZXIyKHN0cmluZywgY2hhcjEsIGNoYXIyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSBjaGFyMSB8fCBjaCA9PT0gY2hhcjIpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vTWFrZXMgYW4gYXJyYXkgb2YgMTI4IHVpbnQ4J3Mgd2hpY2ggcmVwcmVzZW50IGJvb2xlYW4gdmFsdWVzLlxuLy9TcGVjIGlzIGFuIGFycmF5IG9mIGFzY2lpIGNvZGUgcG9pbnRzIG9yIGFzY2lpIGNvZGUgcG9pbnQgcmFuZ2VzXG4vL3JhbmdlcyBhcmUgZXhwcmVzc2VkIGFzIFtzdGFydCwgZW5kXVxuXG4vL0NyZWF0ZSBhIHRhYmxlIHdpdGggdGhlIGNoYXJhY3RlcnMgMHgzMC0weDM5IChkZWNpbWFscyAnMCcgLSAnOScpIGFuZFxuLy8weDdBIChsb3dlcmNhc2VsZXR0ZXIgJ3onKSBhcyBgdHJ1ZWA6XG4vL1xuLy92YXIgYSA9IG1ha2VBc2NpaVRhYmxlKFtbMHgzMCwgMHgzOV0sIDB4N0FdKTtcbi8vYVsweDMwXTsgLy8xXG4vL2FbMHgxNV07IC8vMFxuLy9hWzB4MzVdOyAvLzFcbmZ1bmN0aW9uIG1ha2VBc2NpaVRhYmxlKHNwZWMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoMTI4KTtcbiAgICBzcGVjLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0W2l0ZW1dID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGl0ZW1bMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gaXRlbVsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7ICsraikge1xuICAgICAgICAgICAgICAgIHJldFtqXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cblxudmFyIGF1dG9Fc2NhcGUgPSBbXCI8XCIsIFwiPlwiLCBcIlxcXCJcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLCBcIlxcblwiLFxuICAgIFwiXFx0XCIsIFwie1wiLCBcIn1cIiwgXCJ8XCIsIFwiXFxcXFwiLCBcIl5cIiwgXCJgXCIsIFwiJ1wiXTtcblxudmFyIGF1dG9Fc2NhcGVNYXAgPSBuZXcgQXJyYXkoMTI4KTtcblxuXG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXV0b0VzY2FwZU1hcFtpXSA9IFwiXCI7XG59XG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBhdXRvRXNjYXBlW2ldO1xuICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYyk7XG4gICAgaWYgKGVzYyA9PT0gYykge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYyk7XG4gICAgfVxuICAgIGF1dG9Fc2NhcGVNYXBbYy5jaGFyQ29kZUF0KDApXSA9IGVzYztcbn1cbnZhciBhZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcCA9IGF1dG9Fc2NhcGVNYXAuc2xpY2UoKTtcbmF1dG9Fc2NhcGVNYXBbMHg1QyAvKidcXCcqL10gPSBcIi9cIjtcblxudmFyIHNsYXNoUHJvdG9jb2xzID0gVXJsLnByb3RvdHlwZS5fc2xhc2hQcm90b2NvbHMgPSB7XG4gICAgaHR0cDogdHJ1ZSxcbiAgICBodHRwczogdHJ1ZSxcbiAgICBnb3BoZXI6IHRydWUsXG4gICAgZmlsZTogdHJ1ZSxcbiAgICBmdHA6IHRydWUsXG5cbiAgICBcImh0dHA6XCI6IHRydWUsXG4gICAgXCJodHRwczpcIjogdHJ1ZSxcbiAgICBcImdvcGhlcjpcIjogdHJ1ZSxcbiAgICBcImZpbGU6XCI6IHRydWUsXG4gICAgXCJmdHA6XCI6IHRydWVcbn07XG5cbi8vT3B0aW1pemUgYmFjayBmcm9tIG5vcm1hbGl6ZWQgb2JqZWN0IGNhdXNlZCBieSBub24taWRlbnRpZmllciBrZXlzXG5mdW5jdGlvbiBmKCl7fVxuZi5wcm90b3R5cGUgPSBzbGFzaFByb3RvY29scztcblxuVXJsLnByb3RvdHlwZS5fcHJvdG9jb2xDaGFyYWN0ZXJzID0gbWFrZUFzY2lpVGFibGUoW1xuICAgIFsweDYxIC8qJ2EnKi8sIDB4N0EgLyoneicqL10sXG4gICAgWzB4NDEgLyonQScqLywgMHg1QSAvKidaJyovXSxcbiAgICAweDJFIC8qJy4nKi8sIDB4MkIgLyonKycqLywgMHgyRCAvKictJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5faG9zdEVuZGluZ0NoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgMHgyMyAvKicjJyovLCAweDNGIC8qJz8nKi8sIDB4MkYgLyonLycqLywgMHg1QyAvKidcXCcqL1xuXSk7XG5cblVybC5wcm90b3R5cGUuX2F1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gbWFrZUFzY2lpVGFibGUoXG4gICAgYXV0b0VzY2FwZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jaGFyQ29kZUF0KDApO1xuICAgIH0pXG4pO1xuXG4vL0lmIHRoZXNlIGNoYXJhY3RlcnMgZW5kIGEgaG9zdCBuYW1lLCB0aGUgcGF0aCB3aWxsIG5vdCBiZSBwcmVwZW5kZWQgYSAvXG5VcmwucHJvdG90eXBlLl9ub1ByZXBlbmRTbGFzaEhvc3RFbmRlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBbXG4gICAgICAgIFwiPFwiLCBcIj5cIiwgXCInXCIsIFwiYFwiLCBcIiBcIiwgXCJcXHJcIixcbiAgICAgICAgXCJcXG5cIiwgXCJcXHRcIiwgXCJ7XCIsIFwifVwiLCBcInxcIixcbiAgICAgICAgXCJeXCIsIFwiYFwiLCBcIlxcXCJcIiwgXCIlXCIsIFwiO1wiXG4gICAgXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jaGFyQ29kZUF0KDApO1xuICAgIH0pXG4pO1xuXG5VcmwucHJvdG90eXBlLl9hdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcDtcblVybC5wcm90b3R5cGUuX2FmdGVyUXVlcnlBdXRvRXNjYXBlTWFwID0gYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG5VcmwucmVwbGFjZSA9IGZ1bmN0aW9uIFVybCRSZXBsYWNlKCkge1xuICAgIHJlcXVpcmUuY2FjaGUudXJsID0ge1xuICAgICAgICBleHBvcnRzOiBVcmxcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/fast-url-parser@1.1.3/node_modules/fast-url-parser/src/urlparser.js\n");

/***/ })

};
;