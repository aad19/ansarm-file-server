"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar+json-schema@1.1.12";
exports.ids = ["vendor-chunks/@peculiar+json-schema@1.1.12"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@peculiar+json-schema@1.1.12/node_modules/@peculiar/json-schema/build/index.es.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@peculiar+json-schema@1.1.12/node_modules/@peculiar/json-schema/build/index.es.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonError: () => (/* binding */ JsonError),\n/* harmony export */   JsonParser: () => (/* binding */ JsonParser),\n/* harmony export */   JsonProp: () => (/* binding */ JsonProp),\n/* harmony export */   JsonPropTypes: () => (/* binding */ JsonPropTypes),\n/* harmony export */   JsonSerializer: () => (/* binding */ JsonSerializer),\n/* harmony export */   KeyError: () => (/* binding */ KeyError),\n/* harmony export */   ParserError: () => (/* binding */ ParserError),\n/* harmony export */   SerializerError: () => (/* binding */ SerializerError),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError)\n/* harmony export */ });\n/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */\n\nclass JsonError extends Error {\r\n    constructor(message, innerError) {\r\n        super(innerError\r\n            ? `${message}. See the inner exception for more details.`\r\n            : message);\r\n        this.message = message;\r\n        this.innerError = innerError;\r\n    }\r\n}\n\nclass TransformError extends JsonError {\r\n    constructor(schema, message, innerError) {\r\n        super(message, innerError);\r\n        this.schema = schema;\r\n    }\r\n}\n\nclass ParserError extends TransformError {\r\n    constructor(schema, message, innerError) {\r\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\r\n    }\r\n}\n\nclass ValidationError extends JsonError {\r\n}\n\nclass SerializerError extends JsonError {\r\n    constructor(schemaName, message, innerError) {\r\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\r\n        this.schemaName = schemaName;\r\n    }\r\n}\n\nclass KeyError extends ParserError {\r\n    constructor(schema, keys, errors = {}) {\r\n        super(schema, \"Some keys doesn't match to schema\");\r\n        this.keys = keys;\r\n        this.errors = errors;\r\n    }\r\n}\n\nvar JsonPropTypes;\r\n(function (JsonPropTypes) {\r\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\r\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\r\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\r\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\r\n})(JsonPropTypes || (JsonPropTypes = {}));\n\nfunction checkType(value, type) {\r\n    switch (type) {\r\n        case JsonPropTypes.Boolean:\r\n            return typeof value === \"boolean\";\r\n        case JsonPropTypes.Number:\r\n            return typeof value === \"number\";\r\n        case JsonPropTypes.String:\r\n            return typeof value === \"string\";\r\n    }\r\n    return true;\r\n}\r\nfunction throwIfTypeIsWrong(value, type) {\r\n    if (!checkType(value, type)) {\r\n        throw new TypeError(`Value must be ${JsonPropTypes[type]}`);\r\n    }\r\n}\r\nfunction isConvertible(target) {\r\n    if (target && target.prototype) {\r\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isConvertible(target.prototype);\r\n        }\r\n    }\r\n    else {\r\n        return !!(target && target.toJSON && target.fromJSON);\r\n    }\r\n}\n\nclass JsonSchemaStorage {\r\n    constructor() {\r\n        this.items = new Map();\r\n    }\r\n    has(target) {\r\n        return this.items.has(target) || !!this.findParentSchema(target);\r\n    }\r\n    get(target) {\r\n        const schema = this.items.get(target) || this.findParentSchema(target);\r\n        if (!schema) {\r\n            throw new Error(\"Cannot get schema for current target\");\r\n        }\r\n        return schema;\r\n    }\r\n    create(target) {\r\n        const schema = { names: {} };\r\n        const parentSchema = this.findParentSchema(target);\r\n        if (parentSchema) {\r\n            Object.assign(schema, parentSchema);\r\n            schema.names = {};\r\n            for (const name in parentSchema.names) {\r\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\r\n            }\r\n        }\r\n        schema.target = target;\r\n        return schema;\r\n    }\r\n    set(target, schema) {\r\n        this.items.set(target, schema);\r\n        return this;\r\n    }\r\n    findParentSchema(target) {\r\n        const parent = target.__proto__;\r\n        if (parent) {\r\n            const schema = this.items.get(parent);\r\n            return schema || this.findParentSchema(parent);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nconst DEFAULT_SCHEMA = \"default\";\r\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\r\n    constructor(pattern) {\r\n        this.pattern = new RegExp(pattern);\r\n    }\r\n    validate(value) {\r\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\r\n        if (typeof value !== \"string\") {\r\n            throw new ValidationError(\"Incoming value must be string\");\r\n        }\r\n        if (!pattern.exec(value)) {\r\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\r\n        }\r\n    }\r\n}\n\nclass InclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.Number);\r\n        if (!(this.min <= value && value <= this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\r\n        }\r\n    }\r\n}\n\nclass ExclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.Number);\r\n        if (!(this.min < value && value < this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\r\n        }\r\n    }\r\n}\n\nclass LengthValidation {\r\n    constructor(length, minLength, maxLength) {\r\n        this.length = length;\r\n        this.minLength = minLength;\r\n        this.maxLength = maxLength;\r\n    }\r\n    validate(value) {\r\n        if (this.length !== undefined) {\r\n            if (value.length !== this.length) {\r\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\r\n            }\r\n            return;\r\n        }\r\n        if (this.minLength !== undefined) {\r\n            if (value.length < this.minLength) {\r\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\r\n            }\r\n        }\r\n        if (this.maxLength !== undefined) {\r\n            if (value.length > this.maxLength) {\r\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass EnumerationValidation {\r\n    constructor(enumeration) {\r\n        this.enumeration = enumeration;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, JsonPropTypes.String);\r\n        if (!this.enumeration.includes(value)) {\r\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(\", \")}`);\r\n        }\r\n    }\r\n}\n\nclass JsonTransform {\r\n    static checkValues(data, schemaItem) {\r\n        const values = Array.isArray(data) ? data : [data];\r\n        for (const value of values) {\r\n            for (const validation of schemaItem.validations) {\r\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\r\n                    validation.validate(data);\r\n                }\r\n                else {\r\n                    validation.validate(value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static checkTypes(value, schemaItem) {\r\n        if (schemaItem.repeated && !Array.isArray(value)) {\r\n            throw new TypeError(\"Value must be Array\");\r\n        }\r\n        if (typeof schemaItem.type === \"number\") {\r\n            const values = Array.isArray(value) ? value : [value];\r\n            for (const v of values) {\r\n                throwIfTypeIsWrong(v, schemaItem.type);\r\n            }\r\n        }\r\n    }\r\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\r\n        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\r\n    }\r\n}\n\nclass JsonSerializer extends JsonTransform {\r\n    static serialize(obj, options, replacer, space) {\r\n        const json = this.toJSON(obj, options);\r\n        return JSON.stringify(json, replacer, space);\r\n    }\r\n    static toJSON(obj, options = {}) {\r\n        let res;\r\n        let targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        if (isConvertible(obj)) {\r\n            return obj.toJSON();\r\n        }\r\n        if (Array.isArray(obj)) {\r\n            res = [];\r\n            for (const item of obj) {\r\n                res.push(this.toJSON(item, options));\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\r\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\r\n            }\r\n            targetSchema = (targetSchema || obj.constructor);\r\n            if (schemaStorage.has(targetSchema)) {\r\n                const schema = schemaStorage.get(targetSchema);\r\n                res = {};\r\n                const namedSchema = this.getSchemaByName(schema, schemaName);\r\n                for (const key in namedSchema) {\r\n                    try {\r\n                        const item = namedSchema[key];\r\n                        const objItem = obj[key];\r\n                        let value;\r\n                        if ((item.optional && objItem === undefined)\r\n                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {\r\n                            continue;\r\n                        }\r\n                        if (!item.optional && objItem === undefined) {\r\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\r\n                        }\r\n                        if (typeof item.type === \"number\") {\r\n                            if (item.converter) {\r\n                                if (item.repeated) {\r\n                                    value = objItem.map((el) => item.converter.toJSON(el, obj));\r\n                                }\r\n                                else {\r\n                                    value = item.converter.toJSON(objItem, obj);\r\n                                }\r\n                            }\r\n                            else {\r\n                                value = objItem;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (item.repeated) {\r\n                                value = objItem.map((el) => this.toJSON(el, { schemaName }));\r\n                            }\r\n                            else {\r\n                                value = this.toJSON(objItem, { schemaName });\r\n                            }\r\n                        }\r\n                        this.checkTypes(value, item);\r\n                        this.checkValues(value, item);\r\n                        res[item.name || key] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (e instanceof SerializerError) {\r\n                            throw e;\r\n                        }\r\n                        else {\r\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                res = {};\r\n                for (const key in obj) {\r\n                    res[key] = this.toJSON(obj[key], { schemaName });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res = obj;\r\n        }\r\n        return res;\r\n    }\r\n}\n\nclass JsonParser extends JsonTransform {\r\n    static parse(data, options) {\r\n        const obj = JSON.parse(data);\r\n        return this.fromJSON(obj, options);\r\n    }\r\n    static fromJSON(target, options) {\r\n        const targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        const obj = new targetSchema();\r\n        if (isConvertible(obj)) {\r\n            return obj.fromJSON(target);\r\n        }\r\n        const schema = schemaStorage.get(targetSchema);\r\n        const namedSchema = this.getSchemaByName(schema, schemaName);\r\n        const keyErrors = {};\r\n        if (options.strictProperty && !Array.isArray(target)) {\r\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\r\n        }\r\n        for (const key in namedSchema) {\r\n            try {\r\n                const item = namedSchema[key];\r\n                const name = item.name || key;\r\n                const value = target[name];\r\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\r\n                    continue;\r\n                }\r\n                if (!item.optional && value === undefined) {\r\n                    throw new ParserError(schema, `Property '${name}' is required.`);\r\n                }\r\n                this.checkTypes(value, item);\r\n                this.checkValues(value, item);\r\n                if (typeof (item.type) === \"number\") {\r\n                    if (item.converter) {\r\n                        if (item.repeated) {\r\n                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\r\n                        }\r\n                        else {\r\n                            obj[key] = item.converter.fromJSON(value, obj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj[key] = value;\r\n                    }\r\n                }\r\n                else {\r\n                    const newOptions = {\r\n                        ...options,\r\n                        targetSchema: item.type,\r\n                        schemaName,\r\n                    };\r\n                    if (item.repeated) {\r\n                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));\r\n                    }\r\n                    else {\r\n                        obj[key] = this.fromJSON(value, newOptions);\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof ParserError)) {\r\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\r\n                }\r\n                if (options.strictAllKeys) {\r\n                    keyErrors[key] = e;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const keys = Object.keys(keyErrors);\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys, keyErrors);\r\n        }\r\n        return obj;\r\n    }\r\n    static checkStrictProperty(target, namedSchema, schema) {\r\n        const jsonProps = Object.keys(target);\r\n        const schemaProps = Object.keys(namedSchema);\r\n        const keys = [];\r\n        for (const key of jsonProps) {\r\n            if (schemaProps.indexOf(key) === -1) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys);\r\n        }\r\n    }\r\n}\n\nfunction getValidations(item) {\r\n    const validations = [];\r\n    if (item.pattern) {\r\n        validations.push(new PatternValidation(item.pattern));\r\n    }\r\n    if (item.type === JsonPropTypes.Number || item.type === JsonPropTypes.Any) {\r\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\r\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\r\n        }\r\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\r\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\r\n        }\r\n        if (item.enumeration !== undefined) {\r\n            validations.push(new EnumerationValidation(item.enumeration));\r\n        }\r\n    }\r\n    if (item.type === JsonPropTypes.String || item.repeated || item.type === JsonPropTypes.Any) {\r\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\r\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\r\n        }\r\n    }\r\n    return validations;\r\n}\r\nconst JsonProp = (options = {}) => (target, propertyKey) => {\r\n    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\r\n    let schema;\r\n    if (!schemaStorage.has(target.constructor)) {\r\n        schema = schemaStorage.create(target.constructor);\r\n        schemaStorage.set(target.constructor, schema);\r\n    }\r\n    else {\r\n        schema = schemaStorage.get(target.constructor);\r\n        if (schema.target !== target.constructor) {\r\n            schema = schemaStorage.create(target.constructor);\r\n            schemaStorage.set(target.constructor, schema);\r\n        }\r\n    }\r\n    const defaultSchema = {\r\n        type: JsonPropTypes.Any,\r\n        validations: [],\r\n    };\r\n    const copyOptions = Object.assign(defaultSchema, options);\r\n    copyOptions.validations = getValidations(copyOptions);\r\n    if (typeof copyOptions.type !== \"number\") {\r\n        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\r\n            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\r\n        }\r\n    }\r\n    let schemaNames;\r\n    if (Array.isArray(options.schema)) {\r\n        schemaNames = options.schema;\r\n    }\r\n    else {\r\n        schemaNames = [options.schema || DEFAULT_SCHEMA];\r\n    }\r\n    for (const schemaName of schemaNames) {\r\n        if (!schema.names[schemaName]) {\r\n            schema.names[schemaName] = {};\r\n        }\r\n        const namedSchema = schema.names[schemaName];\r\n        namedSchema[propertyKey] = copyOptions;\r\n    }\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBlY3VsaWFyK2pzb24tc2NoZW1hQDEuMS4xMi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2pzb24tc2NoZW1hL2J1aWxkL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUIsWUFBWSxRQUFRO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVcsWUFBWSxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1KIiwic291cmNlcyI6WyIvaG9tZS9hZDE5L0RvY3VtZW50cy9hbnNhcm0tZmlsZS1zZXJ2ZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BwZWN1bGlhcitqc29uLXNjaGVtYUAxLjEuMTIvbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyMCwgUGVjdWxpYXIgVmVudHVyZXMsIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuY2xhc3MgSnNvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKGlubmVyRXJyb3JcclxuICAgICAgICAgICAgPyBgJHttZXNzYWdlfS4gU2VlIHRoZSBpbm5lciBleGNlcHRpb24gZm9yIG1vcmUgZGV0YWlscy5gXHJcbiAgICAgICAgICAgIDogbWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB0aGlzLmlubmVyRXJyb3IgPSBpbm5lckVycm9yO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFRyYW5zZm9ybUVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgVHJhbnNmb3JtRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoc2NoZW1hLCBgSlNPTiBkb2Vzbid0IG1hdGNoIHRvICcke3NjaGVtYS50YXJnZXQubmFtZX0nIHNjaGVtYS4gJHttZXNzYWdlfWAsIGlubmVyRXJyb3IpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbn1cblxuY2xhc3MgU2VyaWFsaXplckVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYU5hbWUsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihgQ2Fubm90IHNlcmlhbGl6ZSBieSAnJHtzY2hlbWFOYW1lfScgc2NoZW1hLiAke21lc3NhZ2V9YCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hTmFtZTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBLZXlFcnJvciBleHRlbmRzIFBhcnNlckVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwga2V5cywgZXJyb3JzID0ge30pIHtcclxuICAgICAgICBzdXBlcihzY2hlbWEsIFwiU29tZSBrZXlzIGRvZXNuJ3QgbWF0Y2ggdG8gc2NoZW1hXCIpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbn1cblxudmFyIEpzb25Qcm9wVHlwZXM7XHJcbihmdW5jdGlvbiAoSnNvblByb3BUeXBlcykge1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQW55XCJdID0gMF0gPSBcIkFueVwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDFdID0gXCJCb29sZWFuXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJOdW1iZXJcIl0gPSAyXSA9IFwiTnVtYmVyXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XHJcbn0pKEpzb25Qcm9wVHlwZXMgfHwgKEpzb25Qcm9wVHlwZXMgPSB7fSkpO1xuXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgSnNvblByb3BUeXBlcy5Cb29sZWFuOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcclxuICAgICAgICBjYXNlIEpzb25Qcm9wVHlwZXMuTnVtYmVyOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xyXG4gICAgICAgIGNhc2UgSnNvblByb3BUeXBlcy5TdHJpbmc6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICghY2hlY2tUeXBlKHZhbHVlLCB0eXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFZhbHVlIG11c3QgYmUgJHtKc29uUHJvcFR5cGVzW3R5cGVdfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29udmVydGlibGUodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0pTT04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tSlNPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdGFyZ2V0LnRvSlNPTiAmJiB0YXJnZXQuZnJvbUpTT04pO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TY2hlbWFTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBoYXModGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKHRhcmdldCkgfHwgISF0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGdldCh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghc2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgc2NoZW1hIGZvciBjdXJyZW50IHRhcmdldFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIGNyZWF0ZSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB7IG5hbWVzOiB7fSB9O1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcGFyZW50U2NoZW1hLm5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWEubmFtZXNbbmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRTY2hlbWEubmFtZXNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjaGVtYS50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0Ll9fcHJvdG9fXztcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHBhcmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfU0NIRU1BID0gXCJkZWZhdWx0XCI7XHJcbmNvbnN0IHNjaGVtYVN0b3JhZ2UgPSBuZXcgSnNvblNjaGVtYVN0b3JhZ2UoKTtcblxuY2xhc3MgUGF0dGVyblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xyXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybi5zb3VyY2UsIHRoaXMucGF0dGVybi5mbGFncyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiSW5jb21pbmcgdmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGF0dGVybi5leGVjKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIHBhdHRlcm4gJyR7cGF0dGVybi50b1N0cmluZygpfSdgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSW5jbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgSnNvblByb3BUeXBlcy5OdW1iZXIpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gWyR7bWlufSwke21heH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEV4Y2x1c2l2ZVZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluID0gTnVtYmVyLk1JTl9WQUxVRSwgbWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIEpzb25Qcm9wVHlwZXMuTnVtYmVyKTtcclxuICAgICAgICBpZiAoISh0aGlzLm1pbiA8IHZhbHVlICYmIHZhbHVlIDwgdGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gXCJNSU5cIiA6IHRoaXMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLm1heCA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/IFwiTUFYXCIgOiB0aGlzLm1heDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBkaWFwYXNvbiAoJHttaW59LCR7bWF4fSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgTGVuZ3RoVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBtaW5MZW5ndGg7XHJcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBleGFjdGx5ICR7dGhpcy5sZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHRoaXMubWluTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBtb3JlIHRoYW4gJHt0aGlzLm1pbkxlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gJHt0aGlzLm1heExlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRW51bWVyYXRpb25WYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudW1lcmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5lbnVtZXJhdGlvbiA9IGVudW1lcmF0aW9uO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIEpzb25Qcm9wVHlwZXMuU3RyaW5nKTtcclxuICAgICAgICBpZiAoIXRoaXMuZW51bWVyYXRpb24uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIG11c3QgYmUgb25lIG9mICR7dGhpcy5lbnVtZXJhdGlvbi5tYXAoKHYpID0+IGAnJHt2fSdgKS5qb2luKFwiLCBcIil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIGNoZWNrVmFsdWVzKGRhdGEsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb24gb2Ygc2NoZW1hSXRlbS52YWxpZGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gaW5zdGFuY2VvZiBMZW5ndGhWYWxpZGF0aW9uICYmIHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tUeXBlcyh2YWx1ZSwgc2NoZW1hSXRlbSkge1xyXG4gICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgbXVzdCBiZSBBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2LCBzY2hlbWFJdGVtLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIG5hbWUgPSBERUZBVUxUX1NDSEVNQSkge1xyXG4gICAgICAgIHJldHVybiB7IC4uLnNjaGVtYS5uYW1lc1tERUZBVUxUX1NDSEVNQV0sIC4uLnNjaGVtYS5uYW1lc1tuYW1lXSB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TZXJpYWxpemVyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgb3B0aW9ucywgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHRoaXMudG9KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24sIHJlcGxhY2VyLCBzcGFjZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9KU09OKG9iaiwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgbGV0IHJlcztcclxuICAgICAgICBsZXQgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgcmVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudG9KU09OKGl0ZW0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRTY2hlbWEgJiYgIXNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgYHRhcmdldFNjaGVtYWAgcGFyYW1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gKHRhcmdldFNjaGVtYSB8fCBvYmouY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0U2NoZW1hKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqSXRlbSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmpJdGVtID09PSBpdGVtLmRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3IodGFyZ2V0U2NoZW1hLm5hbWUsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyByZXF1aXJlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLnRvSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW0uY29udmVydGVyLnRvSlNPTihvYmpJdGVtLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IHRoaXMudG9KU09OKGVsLCB7IHNjaGVtYU5hbWUgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRvSlNPTihvYmpJdGVtLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpdGVtLm5hbWUgfHwga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3Ioc2NoZW1hLnRhcmdldC5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRoaXMudG9KU09OKG9ialtrZXldLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uUGFyc2VyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04ob2JqLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTY2hlbWEgPSBvcHRpb25zLnRhcmdldFNjaGVtYTtcclxuICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gb3B0aW9ucy5zY2hlbWFOYW1lIHx8IERFRkFVTFRfU0NIRU1BO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyB0YXJnZXRTY2hlbWEoKTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouZnJvbUpTT04odGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgc2NoZW1hTmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5RXJyb3JzID0ge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0UHJvcGVydHkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBKc29uUGFyc2VyLmNoZWNrU3RyaWN0UHJvcGVydHkodGFyZ2V0LCBuYW1lZFNjaGVtYSwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lZFNjaGVtYVtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ubmFtZSB8fCBrZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIChpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtuYW1lfScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLmZyb21KU09OKGVsLCBvYmopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gaXRlbS5jb252ZXJ0ZXIuZnJvbUpTT04odmFsdWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hOiBpdGVtLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IHRoaXMuZnJvbUpTT04oZWwsIG5ld09wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5mcm9tSlNPTih2YWx1ZSwgbmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VyRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyB3cm9uZy4gJHtlLm1lc3NhZ2V9YCwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3RBbGxLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5RXJyb3JzW2tleV0gPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa2V5RXJyb3JzKTtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKHNjaGVtYSwga2V5cywga2V5RXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSkge1xyXG4gICAgICAgIGNvbnN0IGpzb25Qcm9wcyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcHMgPSBPYmplY3Qua2V5cyhuYW1lZFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGpzb25Qcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9ucyhpdGVtKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9ucyA9IFtdO1xyXG4gICAgaWYgKGl0ZW0ucGF0dGVybikge1xyXG4gICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IFBhdHRlcm5WYWxpZGF0aW9uKGl0ZW0ucGF0dGVybikpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gSnNvblByb3BUeXBlcy5OdW1iZXIgfHwgaXRlbS50eXBlID09PSBKc29uUHJvcFR5cGVzLkFueSkge1xyXG4gICAgICAgIGlmIChpdGVtLm1pbkluY2x1c2l2ZSAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4SW5jbHVzaXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgSW5jbHVzaXZlVmFsaWRhdGlvbihpdGVtLm1pbkluY2x1c2l2ZSwgaXRlbS5tYXhJbmNsdXNpdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0ubWluRXhjbHVzaXZlICE9PSB1bmRlZmluZWQgfHwgaXRlbS5tYXhFeGNsdXNpdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBFeGNsdXNpdmVWYWxpZGF0aW9uKGl0ZW0ubWluRXhjbHVzaXZlLCBpdGVtLm1heEV4Y2x1c2l2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5lbnVtZXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEVudW1lcmF0aW9uVmFsaWRhdGlvbihpdGVtLmVudW1lcmF0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gSnNvblByb3BUeXBlcy5TdHJpbmcgfHwgaXRlbS5yZXBlYXRlZCB8fCBpdGVtLnR5cGUgPT09IEpzb25Qcm9wVHlwZXMuQW55KSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSB1bmRlZmluZWQgfHwgaXRlbS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IExlbmd0aFZhbGlkYXRpb24oaXRlbS5sZW5ndGgsIGl0ZW0ubWluTGVuZ3RoLCBpdGVtLm1heExlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWxpZGF0aW9ucztcclxufVxyXG5jb25zdCBKc29uUHJvcCA9IChvcHRpb25zID0ge30pID0+ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQ2Fubm90IHNldCB0eXBlIGZvciAke3Byb3BlcnR5S2V5fSBwcm9wZXJ0eSBvZiAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBzY2hlbWFgO1xyXG4gICAgbGV0IHNjaGVtYTtcclxuICAgIGlmICghc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoc2NoZW1hLnRhcmdldCAhPT0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIHNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldC5jb25zdHJ1Y3Rvciwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0U2NoZW1hID0ge1xyXG4gICAgICAgIHR5cGU6IEpzb25Qcm9wVHlwZXMuQW55LFxyXG4gICAgICAgIHZhbGlkYXRpb25zOiBbXSxcclxuICAgIH07XHJcbiAgICBjb25zdCBjb3B5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdFNjaGVtYSwgb3B0aW9ucyk7XHJcbiAgICBjb3B5T3B0aW9ucy52YWxpZGF0aW9ucyA9IGdldFZhbGlkYXRpb25zKGNvcHlPcHRpb25zKTtcclxuICAgIGlmICh0eXBlb2YgY29weU9wdGlvbnMudHlwZSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGlmICghc2NoZW1hU3RvcmFnZS5oYXMoY29weU9wdGlvbnMudHlwZSkgJiYgIWlzQ29udmVydGlibGUoY29weU9wdGlvbnMudHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX0uIEFzc2lnbmluZyB0eXBlIGRvZXNuJ3QgaGF2ZSBzY2hlbWEuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHNjaGVtYU5hbWVzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zY2hlbWEpKSB7XHJcbiAgICAgICAgc2NoZW1hTmFtZXMgPSBvcHRpb25zLnNjaGVtYTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjaGVtYU5hbWVzID0gW29wdGlvbnMuc2NoZW1hIHx8IERFRkFVTFRfU0NIRU1BXTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc2NoZW1hTmFtZSBvZiBzY2hlbWFOYW1lcykge1xyXG4gICAgICAgIGlmICghc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXTtcclxuICAgICAgICBuYW1lZFNjaGVtYVtwcm9wZXJ0eUtleV0gPSBjb3B5T3B0aW9ucztcclxuICAgIH1cclxufTtcblxuZXhwb3J0IHsgSnNvbkVycm9yLCBKc29uUGFyc2VyLCBKc29uUHJvcCwgSnNvblByb3BUeXBlcywgSnNvblNlcmlhbGl6ZXIsIEtleUVycm9yLCBQYXJzZXJFcnJvciwgU2VyaWFsaXplckVycm9yLCBUcmFuc2Zvcm1FcnJvciwgVmFsaWRhdGlvbkVycm9yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@peculiar+json-schema@1.1.12/node_modules/@peculiar/json-schema/build/index.es.js\n");

/***/ })

};
;