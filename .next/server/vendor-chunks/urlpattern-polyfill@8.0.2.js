/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/urlpattern-polyfill@8.0.2";
exports.ids = ["vendor-chunks/urlpattern-polyfill@8.0.2"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/dist/urlpattern.cjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/dist/urlpattern.cjs ***!
  \***********************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/url-pattern.ts\nvar url_pattern_exports = {};\n__export(url_pattern_exports, {\n  URLPattern: () => URLPattern\n});\nmodule.exports = __toCommonJS(url_pattern_exports);\n\n// src/path-to-regex-modified.ts\nvar Part = class {\n  constructor(type, name, prefix, value, suffix, modifier) {\n    this.type = 3 /* kFixed */;\n    this.name = \"\";\n    this.prefix = \"\";\n    this.value = \"\";\n    this.suffix = \"\";\n    this.modifier = 3 /* kNone */;\n    this.type = type;\n    this.name = name;\n    this.prefix = prefix;\n    this.value = value;\n    this.suffix = suffix;\n    this.modifier = modifier;\n  }\n  hasCustomName() {\n    return this.name !== \"\" && typeof this.name !== \"number\";\n  }\n};\nvar regexIdentifierStart = /[$_\\p{ID_Start}]/u;\nvar regexIdentifierPart = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\nvar kFullWildcardRegex = \".*\";\nfunction isASCII(str, extended) {\n  return (extended ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(str);\n}\nfunction lexer(str, lenient = false) {\n  const tokens = [];\n  let i = 0;\n  while (i < str.length) {\n    const char = str[i];\n    const ErrorOrInvalid = function(msg) {\n      if (!lenient)\n        throw new TypeError(msg);\n      tokens.push({ type: \"INVALID_CHAR\", index: i, value: str[i++] });\n    };\n    if (char === \"*\") {\n      tokens.push({ type: \"ASTERISK\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"OTHER_MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n      while (j < str.length) {\n        const code = str.substr(j, 1);\n        if (j === i + 1 && regexIdentifierStart.test(code) || j !== i + 1 && regexIdentifierPart.test(code)) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) {\n        ErrorOrInvalid(`Missing parameter name at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n      let error = false;\n      if (str[j] === \"?\") {\n        ErrorOrInvalid(`Pattern cannot start with \"?\" at ${j}`);\n        continue;\n      }\n      while (j < str.length) {\n        if (!isASCII(str[j], false)) {\n          ErrorOrInvalid(`Invalid character '${str[j]}' at ${j}.`);\n          error = true;\n          break;\n        }\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            ErrorOrInvalid(`Capturing groups are not allowed at ${j}`);\n            error = true;\n            break;\n          }\n        }\n        pattern += str[j++];\n      }\n      if (error) {\n        continue;\n      }\n      if (count) {\n        ErrorOrInvalid(`Unbalanced pattern at ${i}`);\n        continue;\n      }\n      if (!pattern) {\n        ErrorOrInvalid(`Missing pattern at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"REGEX\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n  return tokens;\n}\nfunction parse(str, options = {}) {\n  const tokens = lexer(str);\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  const segmentWildcardRegex = `[^${escapeString(options.delimiter)}]+?`;\n  const result = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n  let nameSet = /* @__PURE__ */ new Set();\n  const tryConsume = (type) => {\n    if (i < tokens.length && tokens[i].type === type)\n      return tokens[i++].value;\n  };\n  const tryConsumeModifier = () => {\n    return tryConsume(\"OTHER_MODIFIER\") ?? tryConsume(\"ASTERISK\");\n  };\n  const mustConsume = (type) => {\n    const value = tryConsume(type);\n    if (value !== void 0)\n      return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n  const consumeText = () => {\n    let result2 = \"\";\n    let value;\n    while (value = tryConsume(\"CHAR\") ?? tryConsume(\"ESCAPED_CHAR\")) {\n      result2 += value;\n    }\n    return result2;\n  };\n  const DefaultEncodePart = (value) => {\n    return value;\n  };\n  const encodePart = options.encodePart || DefaultEncodePart;\n  let pendingFixedValue = \"\";\n  const appendToPendingFixedValue = (value) => {\n    pendingFixedValue += value;\n  };\n  const maybeAddPartFromPendingFixedValue = () => {\n    if (!pendingFixedValue.length) {\n      return;\n    }\n    result.push(new Part(3 /* kFixed */, \"\", \"\", encodePart(pendingFixedValue), \"\", 3 /* kNone */));\n    pendingFixedValue = \"\";\n  };\n  const addPart = (prefix, nameToken, regexOrWildcardToken, suffix, modifierToken) => {\n    let modifier = 3 /* kNone */;\n    switch (modifierToken) {\n      case \"?\":\n        modifier = 1 /* kOptional */;\n        break;\n      case \"*\":\n        modifier = 0 /* kZeroOrMore */;\n        break;\n      case \"+\":\n        modifier = 2 /* kOneOrMore */;\n        break;\n    }\n    if (!nameToken && !regexOrWildcardToken && modifier === 3 /* kNone */) {\n      appendToPendingFixedValue(prefix);\n      return;\n    }\n    maybeAddPartFromPendingFixedValue();\n    if (!nameToken && !regexOrWildcardToken) {\n      if (!prefix) {\n        return;\n      }\n      result.push(new Part(3 /* kFixed */, \"\", \"\", encodePart(prefix), \"\", modifier));\n      return;\n    }\n    let regexValue;\n    if (!regexOrWildcardToken) {\n      regexValue = segmentWildcardRegex;\n    } else if (regexOrWildcardToken === \"*\") {\n      regexValue = kFullWildcardRegex;\n    } else {\n      regexValue = regexOrWildcardToken;\n    }\n    let type = 2 /* kRegex */;\n    if (regexValue === segmentWildcardRegex) {\n      type = 1 /* kSegmentWildcard */;\n      regexValue = \"\";\n    } else if (regexValue === kFullWildcardRegex) {\n      type = 0 /* kFullWildcard */;\n      regexValue = \"\";\n    }\n    let name;\n    if (nameToken) {\n      name = nameToken;\n    } else if (regexOrWildcardToken) {\n      name = key++;\n    }\n    if (nameSet.has(name)) {\n      throw new TypeError(`Duplicate name '${name}'.`);\n    }\n    nameSet.add(name);\n    result.push(new Part(type, name, encodePart(prefix), regexValue, encodePart(suffix), modifier));\n  };\n  while (i < tokens.length) {\n    const charToken = tryConsume(\"CHAR\");\n    const nameToken = tryConsume(\"NAME\");\n    let regexOrWildcardToken = tryConsume(\"REGEX\");\n    if (!nameToken && !regexOrWildcardToken) {\n      regexOrWildcardToken = tryConsume(\"ASTERISK\");\n    }\n    if (nameToken || regexOrWildcardToken) {\n      let prefix = charToken ?? \"\";\n      if (options.prefixes.indexOf(prefix) === -1) {\n        appendToPendingFixedValue(prefix);\n        prefix = \"\";\n      }\n      maybeAddPartFromPendingFixedValue();\n      let modifierToken = tryConsumeModifier();\n      addPart(prefix, nameToken, regexOrWildcardToken, \"\", modifierToken);\n      continue;\n    }\n    const value = charToken ?? tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      appendToPendingFixedValue(value);\n      continue;\n    }\n    const openToken = tryConsume(\"OPEN\");\n    if (openToken) {\n      const prefix = consumeText();\n      const nameToken2 = tryConsume(\"NAME\");\n      let regexOrWildcardToken2 = tryConsume(\"REGEX\");\n      if (!nameToken2 && !regexOrWildcardToken2) {\n        regexOrWildcardToken2 = tryConsume(\"ASTERISK\");\n      }\n      const suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      const modifierToken = tryConsumeModifier();\n      addPart(prefix, nameToken2, regexOrWildcardToken2, suffix, modifierToken);\n      continue;\n    }\n    maybeAddPartFromPendingFixedValue();\n    mustConsume(\"END\");\n  }\n  return result;\n}\nfunction escapeString(str) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction flags(options) {\n  return options && options.ignoreCase ? \"ui\" : \"u\";\n}\nfunction stringToRegexp(path, names, options) {\n  return partsToRegexp(parse(path, options), names, options);\n}\nfunction modifierToString(modifier) {\n  switch (modifier) {\n    case 0 /* kZeroOrMore */:\n      return \"*\";\n    case 1 /* kOptional */:\n      return \"?\";\n    case 2 /* kOneOrMore */:\n      return \"+\";\n    case 3 /* kNone */:\n      return \"\";\n  }\n}\nfunction partsToRegexp(parts, names, options = {}) {\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  options.sensitive ?? (options.sensitive = false);\n  options.strict ?? (options.strict = false);\n  options.end ?? (options.end = true);\n  options.start ?? (options.start = true);\n  options.endsWith = \"\";\n  let result = options.start ? \"^\" : \"\";\n  for (const part of parts) {\n    if (part.type === 3 /* kFixed */) {\n      if (part.modifier === 3 /* kNone */) {\n        result += escapeString(part.value);\n      } else {\n        result += `(?:${escapeString(part.value)})${modifierToString(part.modifier)}`;\n      }\n      continue;\n    }\n    if (names)\n      names.push(part.name);\n    const segmentWildcardRegex = `[^${escapeString(options.delimiter)}]+?`;\n    let regexValue = part.value;\n    if (part.type === 1 /* kSegmentWildcard */)\n      regexValue = segmentWildcardRegex;\n    else if (part.type === 0 /* kFullWildcard */)\n      regexValue = kFullWildcardRegex;\n    if (!part.prefix.length && !part.suffix.length) {\n      if (part.modifier === 3 /* kNone */ || part.modifier === 1 /* kOptional */) {\n        result += `(${regexValue})${modifierToString(part.modifier)}`;\n      } else {\n        result += `((?:${regexValue})${modifierToString(part.modifier)})`;\n      }\n      continue;\n    }\n    if (part.modifier === 3 /* kNone */ || part.modifier === 1 /* kOptional */) {\n      result += `(?:${escapeString(part.prefix)}(${regexValue})${escapeString(part.suffix)})`;\n      result += modifierToString(part.modifier);\n      continue;\n    }\n    result += `(?:${escapeString(part.prefix)}`;\n    result += `((?:${regexValue})(?:`;\n    result += escapeString(part.suffix);\n    result += escapeString(part.prefix);\n    result += `(?:${regexValue}))*)${escapeString(part.suffix)})`;\n    if (part.modifier === 0 /* kZeroOrMore */) {\n      result += \"?\";\n    }\n  }\n  const endsWith = `[${escapeString(options.endsWith)}]|$`;\n  const delimiter = `[${escapeString(options.delimiter)}]`;\n  if (options.end) {\n    if (!options.strict) {\n      result += `${delimiter}?`;\n    }\n    if (!options.endsWith.length) {\n      result += \"$\";\n    } else {\n      result += `(?=${endsWith})`;\n    }\n    return new RegExp(result, flags(options));\n  }\n  if (!options.strict) {\n    result += `(?:${delimiter}(?=${endsWith}))?`;\n  }\n  let isEndDelimited = false;\n  if (parts.length) {\n    const lastPart = parts[parts.length - 1];\n    if (lastPart.type === 3 /* kFixed */ && lastPart.modifier === 3 /* kNone */) {\n      isEndDelimited = options.delimiter.indexOf(lastPart) > -1;\n    }\n  }\n  if (!isEndDelimited) {\n    result += `(?=${delimiter}|${endsWith})`;\n  }\n  return new RegExp(result, flags(options));\n}\n\n// src/url-utils.ts\nvar DEFAULT_OPTIONS = {\n  delimiter: \"\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar HOSTNAME_OPTIONS = {\n  delimiter: \".\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar PATHNAME_OPTIONS = {\n  delimiter: \"/\",\n  prefixes: \"/\",\n  sensitive: true,\n  strict: true\n};\nfunction isAbsolutePathname(pathname, isPattern) {\n  if (!pathname.length) {\n    return false;\n  }\n  if (pathname[0] === \"/\") {\n    return true;\n  }\n  if (!isPattern) {\n    return false;\n  }\n  if (pathname.length < 2) {\n    return false;\n  }\n  if ((pathname[0] == \"\\\\\" || pathname[0] == \"{\") && pathname[1] == \"/\") {\n    return true;\n  }\n  return false;\n}\nfunction maybeStripPrefix(value, prefix) {\n  if (value.startsWith(prefix)) {\n    return value.substring(prefix.length, value.length);\n  }\n  return value;\n}\nfunction maybeStripSuffix(value, suffix) {\n  if (value.endsWith(suffix)) {\n    return value.substr(0, value.length - suffix.length);\n  }\n  return value;\n}\nfunction treatAsIPv6Hostname(value) {\n  if (!value || value.length < 2) {\n    return false;\n  }\n  if (value[0] === \"[\") {\n    return true;\n  }\n  if ((value[0] === \"\\\\\" || value[0] === \"{\") && value[1] === \"[\") {\n    return true;\n  }\n  return false;\n}\nvar SPECIAL_SCHEMES = [\n  \"ftp\",\n  \"file\",\n  \"http\",\n  \"https\",\n  \"ws\",\n  \"wss\"\n];\nfunction isSpecialScheme(protocol_regexp) {\n  if (!protocol_regexp) {\n    return true;\n  }\n  for (const scheme of SPECIAL_SCHEMES) {\n    if (protocol_regexp.test(scheme)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction canonicalizeHash(hash, isPattern) {\n  hash = maybeStripPrefix(hash, \"#\");\n  if (isPattern || hash === \"\") {\n    return hash;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = hash;\n  return url.hash ? url.hash.substring(1, url.hash.length) : \"\";\n}\nfunction canonicalizeSearch(search, isPattern) {\n  search = maybeStripPrefix(search, \"?\");\n  if (isPattern || search === \"\") {\n    return search;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.search ? url.search.substring(1, url.search.length) : \"\";\n}\nfunction canonicalizeHostname(hostname, isPattern) {\n  if (isPattern || hostname === \"\") {\n    return hostname;\n  }\n  if (treatAsIPv6Hostname(hostname)) {\n    return ipv6HostnameEncodeCallback(hostname);\n  } else {\n    return hostnameEncodeCallback(hostname);\n  }\n}\nfunction canonicalizePassword(password, isPattern) {\n  if (isPattern || password === \"\") {\n    return password;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = password;\n  return url.password;\n}\nfunction canonicalizeUsername(username, isPattern) {\n  if (isPattern || username === \"\") {\n    return username;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = username;\n  return url.username;\n}\nfunction canonicalizePathname(pathname, protocol, isPattern) {\n  if (isPattern || pathname === \"\") {\n    return pathname;\n  }\n  if (protocol && !SPECIAL_SCHEMES.includes(protocol)) {\n    const url = new URL(`${protocol}:${pathname}`);\n    return url.pathname;\n  }\n  const leadingSlash = pathname[0] == \"/\";\n  pathname = new URL(\n    !leadingSlash ? \"/-\" + pathname : pathname,\n    \"https://example.com\"\n  ).pathname;\n  if (!leadingSlash) {\n    pathname = pathname.substring(2, pathname.length);\n  }\n  return pathname;\n}\nfunction canonicalizePort(port, protocol, isPattern) {\n  if (defaultPortForProtocol(protocol) === port) {\n    port = \"\";\n  }\n  if (isPattern || port === \"\") {\n    return port;\n  }\n  return portEncodeCallback(port);\n}\nfunction canonicalizeProtocol(protocol, isPattern) {\n  protocol = maybeStripSuffix(protocol, \":\");\n  if (isPattern || protocol === \"\") {\n    return protocol;\n  }\n  return protocolEncodeCallback(protocol);\n}\nfunction defaultPortForProtocol(protocol) {\n  switch (protocol) {\n    case \"ws\":\n    case \"http\":\n      return \"80\";\n    case \"wws\":\n    case \"https\":\n      return \"443\";\n    case \"ftp\":\n      return \"21\";\n    default:\n      return \"\";\n  }\n}\nfunction protocolEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[-+.A-Za-z0-9]*$/.test(input))\n    return input.toLowerCase();\n  throw new TypeError(`Invalid protocol '${input}'.`);\n}\nfunction usernameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = input;\n  return url.username;\n}\nfunction passwordEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = input;\n  return url.password;\n}\nfunction hostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(input)) {\n    throw new TypeError(`Invalid hostname '${input}'`);\n  }\n  const url = new URL(\"https://example.com\");\n  url.hostname = input;\n  return url.hostname;\n}\nfunction ipv6HostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[^0-9a-fA-F[\\]:]/g.test(input)) {\n    throw new TypeError(`Invalid IPv6 hostname '${input}'`);\n  }\n  return input.toLowerCase();\n}\nfunction portEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[0-9]*$/.test(input) && parseInt(input) <= 65535) {\n    return input;\n  }\n  throw new TypeError(`Invalid port '${input}'.`);\n}\nfunction standardURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.pathname = input[0] !== \"/\" ? \"/-\" + input : input;\n  if (input[0] !== \"/\") {\n    return url.pathname.substring(2, url.pathname.length);\n  }\n  return url.pathname;\n}\nfunction pathURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(`data:${input}`);\n  return url.pathname;\n}\nfunction searchEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = input;\n  return url.search.substring(1, url.search.length);\n}\nfunction hashEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = input;\n  return url.hash.substring(1, url.hash.length);\n}\n\n// src/url-pattern-parser.ts\nvar Parser = class {\n  constructor(input) {\n    // The list of `LexToken`s produced by the path-to-regexp `lexer()` function\n    // when passed `input` with lenient mode enabled.\n    this.tokenList = [];\n    // As we parse the input string we populate a `URLPatternInit` dictionary\n    // with each component pattern.  This is then the final result of the parse.\n    this.internalResult = {};\n    // The index of the current `LexToken` being considered.\n    this.tokenIndex = 0;\n    // The value to add to `tokenIndex` on each turn through the parse loop.\n    // While typically this is `1`, it is also set to `0` at times for things\n    // like state transitions, etc.  It is automatically reset back to `1` at\n    // the top of the parse loop.\n    this.tokenIncrement = 1;\n    // The index of the first `LexToken` to include in the component string.\n    this.componentStart = 0;\n    // The current parse state.  This should only be changed via `changeState()`\n    // or `rewindAndSetState()`.\n    this.state = 0 /* INIT */;\n    // The current nest depth of `{ }` pattern groupings.\n    this.groupDepth = 0;\n    // The current nesting depth of `[ ]` in hostname patterns.\n    this.hostnameIPv6BracketDepth = 0;\n    // True if we should apply parse rules as if this is a \"standard\" URL.  If\n    // false then this is treated as a \"not a base URL\".\n    this.shouldTreatAsStandardURL = false;\n    this.input = input;\n  }\n  // Return the parse result.  The result is only available after the\n  // `parse()` method completes.\n  get result() {\n    return this.internalResult;\n  }\n  // Attempt to parse the input string used to construct the Parser object.\n  // This method may only be called once.  Any errors will be thrown as an\n  // exception.  Retrieve the parse result by accessing the `Parser.result`\n  // property getter.\n  parse() {\n    this.tokenList = lexer(\n      this.input,\n      /*lenient=*/\n      true\n    );\n    for (; this.tokenIndex < this.tokenList.length; this.tokenIndex += this.tokenIncrement) {\n      this.tokenIncrement = 1;\n      if (this.tokenList[this.tokenIndex].type === \"END\") {\n        if (this.state === 0 /* INIT */) {\n          this.rewind();\n          if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n            this.internalResult.hash = \"\";\n          } else {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n          }\n          continue;\n        } else if (this.state === 2 /* AUTHORITY */) {\n          this.rewindAndSetState(5 /* HOSTNAME */);\n          continue;\n        }\n        this.changeState(\n          10 /* DONE */,\n          /*skip=*/\n          0\n        );\n        break;\n      }\n      if (this.groupDepth > 0) {\n        if (this.isGroupClose()) {\n          this.groupDepth -= 1;\n        } else {\n          continue;\n        }\n      }\n      if (this.isGroupOpen()) {\n        this.groupDepth += 1;\n        continue;\n      }\n      switch (this.state) {\n        case 0 /* INIT */:\n          if (this.isProtocolSuffix()) {\n            this.internalResult.username = \"\";\n            this.internalResult.password = \"\";\n            this.internalResult.hostname = \"\";\n            this.internalResult.port = \"\";\n            this.internalResult.pathname = \"\";\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n            this.rewindAndSetState(1 /* PROTOCOL */);\n          }\n          break;\n        case 1 /* PROTOCOL */:\n          if (this.isProtocolSuffix()) {\n            this.computeShouldTreatAsStandardURL();\n            let nextState = 7 /* PATHNAME */;\n            let skip = 1;\n            if (this.shouldTreatAsStandardURL) {\n              this.internalResult.pathname = \"/\";\n            }\n            if (this.nextIsAuthoritySlashes()) {\n              nextState = 2 /* AUTHORITY */;\n              skip = 3;\n            } else if (this.shouldTreatAsStandardURL) {\n              nextState = 2 /* AUTHORITY */;\n            }\n            this.changeState(nextState, skip);\n          }\n          break;\n        case 2 /* AUTHORITY */:\n          if (this.isIdentityTerminator()) {\n            this.rewindAndSetState(3 /* USERNAME */);\n          } else if (this.isPathnameStart() || this.isSearchPrefix() || this.isHashPrefix()) {\n            this.rewindAndSetState(5 /* HOSTNAME */);\n          }\n          break;\n        case 3 /* USERNAME */:\n          if (this.isPasswordPrefix()) {\n            this.changeState(\n              4 /* PASSWORD */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isIdentityTerminator()) {\n            this.changeState(\n              5 /* HOSTNAME */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 4 /* PASSWORD */:\n          if (this.isIdentityTerminator()) {\n            this.changeState(\n              5 /* HOSTNAME */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 5 /* HOSTNAME */:\n          if (this.isIPv6Open()) {\n            this.hostnameIPv6BracketDepth += 1;\n          } else if (this.isIPv6Close()) {\n            this.hostnameIPv6BracketDepth -= 1;\n          }\n          if (this.isPortPrefix() && !this.hostnameIPv6BracketDepth) {\n            this.changeState(\n              6 /* PORT */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isPathnameStart()) {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 6 /* PORT */:\n          if (this.isPathnameStart()) {\n            this.changeState(\n              7 /* PATHNAME */,\n              /*skip=*/\n              0\n            );\n          } else if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 7 /* PATHNAME */:\n          if (this.isSearchPrefix()) {\n            this.changeState(\n              8 /* SEARCH */,\n              /*skip=*/\n              1\n            );\n          } else if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 8 /* SEARCH */:\n          if (this.isHashPrefix()) {\n            this.changeState(\n              9 /* HASH */,\n              /*skip=*/\n              1\n            );\n          }\n          break;\n        case 9 /* HASH */:\n          break;\n        case 10 /* DONE */:\n          break;\n      }\n    }\n  }\n  changeState(newState, skip) {\n    switch (this.state) {\n      case 0 /* INIT */:\n        break;\n      case 1 /* PROTOCOL */:\n        this.internalResult.protocol = this.makeComponentString();\n        break;\n      case 2 /* AUTHORITY */:\n        break;\n      case 3 /* USERNAME */:\n        this.internalResult.username = this.makeComponentString();\n        break;\n      case 4 /* PASSWORD */:\n        this.internalResult.password = this.makeComponentString();\n        break;\n      case 5 /* HOSTNAME */:\n        this.internalResult.hostname = this.makeComponentString();\n        break;\n      case 6 /* PORT */:\n        this.internalResult.port = this.makeComponentString();\n        break;\n      case 7 /* PATHNAME */:\n        this.internalResult.pathname = this.makeComponentString();\n        break;\n      case 8 /* SEARCH */:\n        this.internalResult.search = this.makeComponentString();\n        break;\n      case 9 /* HASH */:\n        this.internalResult.hash = this.makeComponentString();\n        break;\n      case 10 /* DONE */:\n        break;\n    }\n    this.changeStateWithoutSettingComponent(newState, skip);\n  }\n  changeStateWithoutSettingComponent(newState, skip) {\n    this.state = newState;\n    this.componentStart = this.tokenIndex + skip;\n    this.tokenIndex += skip;\n    this.tokenIncrement = 0;\n  }\n  rewind() {\n    this.tokenIndex = this.componentStart;\n    this.tokenIncrement = 0;\n  }\n  rewindAndSetState(newState) {\n    this.rewind();\n    this.state = newState;\n  }\n  safeToken(index) {\n    if (index < 0) {\n      index = this.tokenList.length - index;\n    }\n    if (index < this.tokenList.length) {\n      return this.tokenList[index];\n    }\n    return this.tokenList[this.tokenList.length - 1];\n  }\n  isNonSpecialPatternChar(index, value) {\n    const token = this.safeToken(index);\n    return token.value === value && (token.type === \"CHAR\" || token.type === \"ESCAPED_CHAR\" || token.type === \"INVALID_CHAR\");\n  }\n  isProtocolSuffix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  nextIsAuthoritySlashes() {\n    return this.isNonSpecialPatternChar(this.tokenIndex + 1, \"/\") && this.isNonSpecialPatternChar(this.tokenIndex + 2, \"/\");\n  }\n  isIdentityTerminator() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"@\");\n  }\n  isPasswordPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPortPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPathnameStart() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"/\");\n  }\n  isSearchPrefix() {\n    if (this.isNonSpecialPatternChar(this.tokenIndex, \"?\")) {\n      return true;\n    }\n    if (this.tokenList[this.tokenIndex].value !== \"?\") {\n      return false;\n    }\n    const previousToken = this.safeToken(this.tokenIndex - 1);\n    return previousToken.type !== \"NAME\" && previousToken.type !== \"REGEX\" && previousToken.type !== \"CLOSE\" && previousToken.type !== \"ASTERISK\";\n  }\n  isHashPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"#\");\n  }\n  isGroupOpen() {\n    return this.tokenList[this.tokenIndex].type == \"OPEN\";\n  }\n  isGroupClose() {\n    return this.tokenList[this.tokenIndex].type == \"CLOSE\";\n  }\n  isIPv6Open() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"[\");\n  }\n  isIPv6Close() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"]\");\n  }\n  makeComponentString() {\n    const token = this.tokenList[this.tokenIndex];\n    const componentCharStart = this.safeToken(this.componentStart).index;\n    return this.input.substring(componentCharStart, token.index);\n  }\n  computeShouldTreatAsStandardURL() {\n    const options = {};\n    Object.assign(options, DEFAULT_OPTIONS);\n    options.encodePart = protocolEncodeCallback;\n    const regexp = stringToRegexp(\n      this.makeComponentString(),\n      /*keys=*/\n      void 0,\n      options\n    );\n    this.shouldTreatAsStandardURL = isSpecialScheme(regexp);\n  }\n};\n\n// src/url-pattern.ts\nvar COMPONENTS = [\n  \"protocol\",\n  \"username\",\n  \"password\",\n  \"hostname\",\n  \"port\",\n  \"pathname\",\n  \"search\",\n  \"hash\"\n];\nvar DEFAULT_PATTERN = \"*\";\nfunction extractValues(url, baseURL) {\n  if (typeof url !== \"string\") {\n    throw new TypeError(`parameter 1 is not of type 'string'.`);\n  }\n  const o = new URL(url, baseURL);\n  return {\n    protocol: o.protocol.substring(0, o.protocol.length - 1),\n    username: o.username,\n    password: o.password,\n    hostname: o.hostname,\n    port: o.port,\n    pathname: o.pathname,\n    search: o.search !== \"\" ? o.search.substring(1, o.search.length) : void 0,\n    hash: o.hash !== \"\" ? o.hash.substring(1, o.hash.length) : void 0\n  };\n}\nfunction processBaseURLString(input, isPattern) {\n  if (!isPattern) {\n    return input;\n  }\n  return escapePatternString(input);\n}\nfunction applyInit(o, init, isPattern) {\n  let baseURL;\n  if (typeof init.baseURL === \"string\") {\n    try {\n      baseURL = new URL(init.baseURL);\n      o.protocol = processBaseURLString(baseURL.protocol.substring(0, baseURL.protocol.length - 1), isPattern);\n      o.username = processBaseURLString(baseURL.username, isPattern);\n      o.password = processBaseURLString(baseURL.password, isPattern);\n      o.hostname = processBaseURLString(baseURL.hostname, isPattern);\n      o.port = processBaseURLString(baseURL.port, isPattern);\n      o.pathname = processBaseURLString(baseURL.pathname, isPattern);\n      o.search = processBaseURLString(baseURL.search.substring(1, baseURL.search.length), isPattern);\n      o.hash = processBaseURLString(baseURL.hash.substring(1, baseURL.hash.length), isPattern);\n    } catch {\n      throw new TypeError(`invalid baseURL '${init.baseURL}'.`);\n    }\n  }\n  if (typeof init.protocol === \"string\") {\n    o.protocol = canonicalizeProtocol(init.protocol, isPattern);\n  }\n  if (typeof init.username === \"string\") {\n    o.username = canonicalizeUsername(init.username, isPattern);\n  }\n  if (typeof init.password === \"string\") {\n    o.password = canonicalizePassword(init.password, isPattern);\n  }\n  if (typeof init.hostname === \"string\") {\n    o.hostname = canonicalizeHostname(init.hostname, isPattern);\n  }\n  if (typeof init.port === \"string\") {\n    o.port = canonicalizePort(init.port, o.protocol, isPattern);\n  }\n  if (typeof init.pathname === \"string\") {\n    o.pathname = init.pathname;\n    if (baseURL && !isAbsolutePathname(o.pathname, isPattern)) {\n      const slashIndex = baseURL.pathname.lastIndexOf(\"/\");\n      if (slashIndex >= 0) {\n        o.pathname = processBaseURLString(baseURL.pathname.substring(0, slashIndex + 1), isPattern) + o.pathname;\n      }\n    }\n    o.pathname = canonicalizePathname(o.pathname, o.protocol, isPattern);\n  }\n  if (typeof init.search === \"string\") {\n    o.search = canonicalizeSearch(init.search, isPattern);\n  }\n  if (typeof init.hash === \"string\") {\n    o.hash = canonicalizeHash(init.hash, isPattern);\n  }\n  return o;\n}\nfunction escapePatternString(value) {\n  return value.replace(/([+*?:{}()\\\\])/g, \"\\\\$1\");\n}\nfunction escapeRegexpString(value) {\n  return value.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction partsToPattern(parts, options) {\n  options.delimiter ?? (options.delimiter = \"/#?\");\n  options.prefixes ?? (options.prefixes = \"./\");\n  options.sensitive ?? (options.sensitive = false);\n  options.strict ?? (options.strict = false);\n  options.end ?? (options.end = true);\n  options.start ?? (options.start = true);\n  options.endsWith = \"\";\n  const kFullWildcardRegex2 = \".*\";\n  const segmentWildcardRegex = `[^${escapeRegexpString(options.delimiter)}]+?`;\n  const regexIdentifierPart2 = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n  let result = \"\";\n  for (let i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n    if (part.type === 3 /* kFixed */) {\n      if (part.modifier === 3 /* kNone */) {\n        result += escapePatternString(part.value);\n        continue;\n      }\n      result += `{${escapePatternString(part.value)}}${modifierToString(part.modifier)}`;\n      continue;\n    }\n    const customName = part.hasCustomName();\n    let needsGrouping = !!part.suffix.length || !!part.prefix.length && (part.prefix.length !== 1 || !options.prefixes.includes(part.prefix));\n    const lastPart = i > 0 ? parts[i - 1] : null;\n    const nextPart = i < parts.length - 1 ? parts[i + 1] : null;\n    if (!needsGrouping && customName && part.type === 1 /* kSegmentWildcard */ && part.modifier === 3 /* kNone */ && nextPart && !nextPart.prefix.length && !nextPart.suffix.length) {\n      if (nextPart.type === 3 /* kFixed */) {\n        const code = nextPart.value.length > 0 ? nextPart.value[0] : \"\";\n        needsGrouping = regexIdentifierPart2.test(code);\n      } else {\n        needsGrouping = !nextPart.hasCustomName();\n      }\n    }\n    if (!needsGrouping && !part.prefix.length && lastPart && lastPart.type === 3 /* kFixed */) {\n      const code = lastPart.value[lastPart.value.length - 1];\n      needsGrouping = options.prefixes.includes(code);\n    }\n    if (needsGrouping) {\n      result += \"{\";\n    }\n    result += escapePatternString(part.prefix);\n    if (customName) {\n      result += `:${part.name}`;\n    }\n    if (part.type === 2 /* kRegex */) {\n      result += `(${part.value})`;\n    } else if (part.type === 1 /* kSegmentWildcard */) {\n      if (!customName) {\n        result += `(${segmentWildcardRegex})`;\n      }\n    } else if (part.type === 0 /* kFullWildcard */) {\n      if (!customName && (!lastPart || lastPart.type === 3 /* kFixed */ || lastPart.modifier !== 3 /* kNone */ || needsGrouping || part.prefix !== \"\")) {\n        result += \"*\";\n      } else {\n        result += `(${kFullWildcardRegex2})`;\n      }\n    }\n    if (part.type === 1 /* kSegmentWildcard */ && customName && !!part.suffix.length) {\n      if (regexIdentifierPart2.test(part.suffix[0])) {\n        result += \"\\\\\";\n      }\n    }\n    result += escapePatternString(part.suffix);\n    if (needsGrouping) {\n      result += \"}\";\n    }\n    if (part.modifier !== 3 /* kNone */) {\n      result += modifierToString(part.modifier);\n    }\n  }\n  return result;\n}\nvar URLPattern = class {\n  constructor(init = {}, baseURLOrOptions, options) {\n    this.regexp = {};\n    this.names = {};\n    this.component_pattern = {};\n    this.parts = {};\n    try {\n      let baseURL = void 0;\n      if (typeof baseURLOrOptions === \"string\") {\n        baseURL = baseURLOrOptions;\n      } else {\n        options = baseURLOrOptions;\n      }\n      if (typeof init === \"string\") {\n        const parser = new Parser(init);\n        parser.parse();\n        init = parser.result;\n        if (baseURL === void 0 && typeof init.protocol !== \"string\") {\n          throw new TypeError(`A base URL must be provided for a relative constructor string.`);\n        }\n        init.baseURL = baseURL;\n      } else {\n        if (!init || typeof init !== \"object\") {\n          throw new TypeError(`parameter 1 is not of type 'string' and cannot convert to dictionary.`);\n        }\n        if (baseURL) {\n          throw new TypeError(`parameter 1 is not of type 'string'.`);\n        }\n      }\n      if (typeof options === \"undefined\") {\n        options = { ignoreCase: false };\n      }\n      const ignoreCaseOptions = { ignoreCase: options.ignoreCase === true };\n      const defaults = {\n        pathname: DEFAULT_PATTERN,\n        protocol: DEFAULT_PATTERN,\n        username: DEFAULT_PATTERN,\n        password: DEFAULT_PATTERN,\n        hostname: DEFAULT_PATTERN,\n        port: DEFAULT_PATTERN,\n        search: DEFAULT_PATTERN,\n        hash: DEFAULT_PATTERN\n      };\n      this.pattern = applyInit(defaults, init, true);\n      if (defaultPortForProtocol(this.pattern.protocol) === this.pattern.port) {\n        this.pattern.port = \"\";\n      }\n      let component;\n      for (component of COMPONENTS) {\n        if (!(component in this.pattern))\n          continue;\n        const options2 = {};\n        const pattern = this.pattern[component];\n        this.names[component] = [];\n        switch (component) {\n          case \"protocol\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = protocolEncodeCallback;\n            break;\n          case \"username\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = usernameEncodeCallback;\n            break;\n          case \"password\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = passwordEncodeCallback;\n            break;\n          case \"hostname\":\n            Object.assign(options2, HOSTNAME_OPTIONS);\n            if (treatAsIPv6Hostname(pattern)) {\n              options2.encodePart = ipv6HostnameEncodeCallback;\n            } else {\n              options2.encodePart = hostnameEncodeCallback;\n            }\n            break;\n          case \"port\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = portEncodeCallback;\n            break;\n          case \"pathname\":\n            if (isSpecialScheme(this.regexp.protocol)) {\n              Object.assign(options2, PATHNAME_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = standardURLPathnameEncodeCallback;\n            } else {\n              Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = pathURLPathnameEncodeCallback;\n            }\n            break;\n          case \"search\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = searchEncodeCallback;\n            break;\n          case \"hash\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = hashEncodeCallback;\n            break;\n        }\n        try {\n          this.parts[component] = parse(pattern, options2);\n          this.regexp[component] = partsToRegexp(\n            this.parts[component],\n            /* out */\n            this.names[component],\n            options2\n          );\n          this.component_pattern[component] = partsToPattern(this.parts[component], options2);\n        } catch (err) {\n          throw new TypeError(`invalid ${component} pattern '${this.pattern[component]}'.`);\n        }\n      }\n    } catch (err) {\n      throw new TypeError(`Failed to construct 'URLPattern': ${err.message}`);\n    }\n  }\n  test(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return false;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return false;\n    }\n    let component;\n    for (component of COMPONENTS) {\n      if (!this.regexp[component].exec(values[component])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  exec(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return null;\n    }\n    let result = {};\n    if (baseURL) {\n      result.inputs = [input, baseURL];\n    } else {\n      result.inputs = [input];\n    }\n    let component;\n    for (component of COMPONENTS) {\n      let match = this.regexp[component].exec(values[component]);\n      if (!match) {\n        return null;\n      }\n      let groups = {};\n      for (let [i, name] of this.names[component].entries()) {\n        if (typeof name === \"string\" || typeof name === \"number\") {\n          let value = match[i + 1];\n          groups[name] = value;\n        }\n      }\n      result[component] = {\n        input: values[component] ?? \"\",\n        groups\n      };\n    }\n    return result;\n  }\n  static compareComponent(component, left, right) {\n    const comparePart = (left2, right2) => {\n      for (let attr of [\"type\", \"modifier\", \"prefix\", \"value\", \"suffix\"]) {\n        if (left2[attr] < right2[attr])\n          return -1;\n        else if (left2[attr] === right2[attr])\n          continue;\n        else\n          return 1;\n      }\n      return 0;\n    };\n    const emptyFixedPart = new Part(3 /* kFixed */, \"\", \"\", \"\", \"\", 3 /* kNone */);\n    const wildcardOnlyPart = new Part(0 /* kFullWildcard */, \"\", \"\", \"\", \"\", 3 /* kNone */);\n    const comparePartList = (left2, right2) => {\n      let i = 0;\n      for (; i < Math.min(left2.length, right2.length); ++i) {\n        let result = comparePart(left2[i], right2[i]);\n        if (result)\n          return result;\n      }\n      if (left2.length === right2.length) {\n        return 0;\n      }\n      return comparePart(left2[i] ?? emptyFixedPart, right2[i] ?? emptyFixedPart);\n    };\n    if (!left.component_pattern[component] && !right.component_pattern[component]) {\n      return 0;\n    }\n    if (left.component_pattern[component] && !right.component_pattern[component]) {\n      return comparePartList(left.parts[component], [wildcardOnlyPart]);\n    }\n    if (!left.component_pattern[component] && right.component_pattern[component]) {\n      return comparePartList([wildcardOnlyPart], right.parts[component]);\n    }\n    return comparePartList(left.parts[component], right.parts[component]);\n  }\n  get protocol() {\n    return this.component_pattern.protocol;\n  }\n  get username() {\n    return this.component_pattern.username;\n  }\n  get password() {\n    return this.component_pattern.password;\n  }\n  get hostname() {\n    return this.component_pattern.hostname;\n  }\n  get port() {\n    return this.component_pattern.port;\n  }\n  get pathname() {\n    return this.component_pattern.pathname;\n  }\n  get search() {\n    return this.component_pattern.search;\n  }\n  get hash() {\n    return this.component_pattern.hash;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdXJscGF0dGVybi1wb2x5ZmlsbEA4LjAuMi9ub2RlX21vZHVsZXMvdXJscGF0dGVybi1wb2x5ZmlsbC9kaXN0L3VybHBhdHRlcm4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQWlEO0FBQ3JFO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFtRDtBQUN2RTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0IsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPLE9BQU8sRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQyxzQ0FBc0MsVUFBVSxLQUFLLE1BQU0sYUFBYSxLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLHlCQUF5QixHQUFHLGdDQUFnQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcsZ0NBQWdDO0FBQ3BFLFFBQVE7QUFDUix5QkFBeUIsV0FBVyxHQUFHLGdDQUFnQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEIsR0FBRyxXQUFXLEdBQUcsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUMscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixXQUFXLE1BQU0sMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RCx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxLQUFLLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsR0FBRyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUyxHQUFHLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsaUNBQWlDLEVBQUUsZ0NBQWdDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLE1BQU07QUFDTjtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUixzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUNBQXlDLFdBQVcsV0FBVyx3QkFBd0I7QUFDdkY7QUFDQTtBQUNBLE1BQU07QUFDTiwrREFBK0QsWUFBWTtBQUMzRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2FkMTkvRG9jdW1lbnRzL2Fuc2FybS1maWxlLXNlcnZlci9ub2RlX21vZHVsZXMvLnBucG0vdXJscGF0dGVybi1wb2x5ZmlsbEA4LjAuMi9ub2RlX21vZHVsZXMvdXJscGF0dGVybi1wb2x5ZmlsbC9kaXN0L3VybHBhdHRlcm4uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL3VybC1wYXR0ZXJuLnRzXG52YXIgdXJsX3BhdHRlcm5fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXJsX3BhdHRlcm5fZXhwb3J0cywge1xuICBVUkxQYXR0ZXJuOiAoKSA9PiBVUkxQYXR0ZXJuXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHVybF9wYXR0ZXJuX2V4cG9ydHMpO1xuXG4vLyBzcmMvcGF0aC10by1yZWdleC1tb2RpZmllZC50c1xudmFyIFBhcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hbWUsIHByZWZpeCwgdmFsdWUsIHN1ZmZpeCwgbW9kaWZpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSAzIC8qIGtGaXhlZCAqLztcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIHRoaXMucHJlZml4ID0gXCJcIjtcbiAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICB0aGlzLnN1ZmZpeCA9IFwiXCI7XG4gICAgdGhpcy5tb2RpZmllciA9IDMgLyoga05vbmUgKi87XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICB0aGlzLm1vZGlmaWVyID0gbW9kaWZpZXI7XG4gIH1cbiAgaGFzQ3VzdG9tTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lICE9PSBcIlwiICYmIHR5cGVvZiB0aGlzLm5hbWUgIT09IFwibnVtYmVyXCI7XG4gIH1cbn07XG52YXIgcmVnZXhJZGVudGlmaWVyU3RhcnQgPSAvWyRfXFxwe0lEX1N0YXJ0fV0vdTtcbnZhciByZWdleElkZW50aWZpZXJQYXJ0ID0gL1skX1xcdTIwMENcXHUyMDBEXFxwe0lEX0NvbnRpbnVlfV0vdTtcbnZhciBrRnVsbFdpbGRjYXJkUmVnZXggPSBcIi4qXCI7XG5mdW5jdGlvbiBpc0FTQ0lJKHN0ciwgZXh0ZW5kZWQpIHtcbiAgcmV0dXJuIChleHRlbmRlZCA/IC9eW1xceDAwLVxceEZGXSokLyA6IC9eW1xceDAwLVxceDdGXSokLykudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gbGV4ZXIoc3RyLCBsZW5pZW50ID0gZmFsc2UpIHtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hhciA9IHN0cltpXTtcbiAgICBjb25zdCBFcnJvck9ySW52YWxpZCA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKCFsZW5pZW50KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1zZyk7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiSU5WQUxJRF9DSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfTtcbiAgICBpZiAoY2hhciA9PT0gXCIqXCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJBU1RFUklTS1wiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk9USEVSX01PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRVNDQVBFRF9DSEFSXCIsIGluZGV4OiBpKyssIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCI6XCIpIHtcbiAgICAgIGxldCBuYW1lID0gXCJcIjtcbiAgICAgIGxldCBqID0gaSArIDE7XG4gICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5zdWJzdHIoaiwgMSk7XG4gICAgICAgIGlmIChqID09PSBpICsgMSAmJiByZWdleElkZW50aWZpZXJTdGFydC50ZXN0KGNvZGUpIHx8IGogIT09IGkgKyAxICYmIHJlZ2V4SWRlbnRpZmllclBhcnQudGVzdChjb2RlKSkge1xuICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgRXJyb3JPckludmFsaWQoYE1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgJHtpfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgIGkgPSBqO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIihcIikge1xuICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgIGxldCBwYXR0ZXJuID0gXCJcIjtcbiAgICAgIGxldCBqID0gaSArIDE7XG4gICAgICBsZXQgZXJyb3IgPSBmYWxzZTtcbiAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgIEVycm9yT3JJbnZhbGlkKGBQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFwiP1wiIGF0ICR7an1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFpc0FTQ0lJKHN0cltqXSwgZmFsc2UpKSB7XG4gICAgICAgICAgRXJyb3JPckludmFsaWQoYEludmFsaWQgY2hhcmFjdGVyICcke3N0cltqXX0nIGF0ICR7an0uYCk7XG4gICAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXSArIHN0cltqKytdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJbal0gPT09IFwiKFwiKSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgIEVycm9yT3JJbnZhbGlkKGBDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCAke2p9YCk7XG4gICAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCkge1xuICAgICAgICBFcnJvck9ySW52YWxpZChgVW5iYWxhbmNlZCBwYXR0ZXJuIGF0ICR7aX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgRXJyb3JPckludmFsaWQoYE1pc3NpbmcgcGF0dGVybiBhdCAke2l9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIlJFR0VYXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgIGkgPSBqO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gIH1cbiAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0b2tlbnMgPSBsZXhlcihzdHIpO1xuICBvcHRpb25zLmRlbGltaXRlciA/PyAob3B0aW9ucy5kZWxpbWl0ZXIgPSBcIi8jP1wiKTtcbiAgb3B0aW9ucy5wcmVmaXhlcyA/PyAob3B0aW9ucy5wcmVmaXhlcyA9IFwiLi9cIik7XG4gIGNvbnN0IHNlZ21lbnRXaWxkY2FyZFJlZ2V4ID0gYFteJHtlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIpfV0rP2A7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQga2V5ID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcGF0aCA9IFwiXCI7XG4gIGxldCBuYW1lU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdHJ5Q29uc3VtZSA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICB9O1xuICBjb25zdCB0cnlDb25zdW1lTW9kaWZpZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRyeUNvbnN1bWUoXCJPVEhFUl9NT0RJRklFUlwiKSA/PyB0cnlDb25zdW1lKFwiQVNURVJJU0tcIik7XG4gIH07XG4gIGNvbnN0IG11c3RDb25zdW1lID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRyeUNvbnN1bWUodHlwZSk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyB0eXBlOiBuZXh0VHlwZSwgaW5kZXggfSA9IHRva2Vuc1tpXTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmV4cGVjdGVkICR7bmV4dFR5cGV9IGF0ICR7aW5kZXh9LCBleHBlY3RlZCAke3R5cGV9YCk7XG4gIH07XG4gIGNvbnN0IGNvbnN1bWVUZXh0ID0gKCkgPT4ge1xuICAgIGxldCByZXN1bHQyID0gXCJcIjtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgPz8gdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkge1xuICAgICAgcmVzdWx0MiArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH07XG4gIGNvbnN0IERlZmF1bHRFbmNvZGVQYXJ0ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBjb25zdCBlbmNvZGVQYXJ0ID0gb3B0aW9ucy5lbmNvZGVQYXJ0IHx8IERlZmF1bHRFbmNvZGVQYXJ0O1xuICBsZXQgcGVuZGluZ0ZpeGVkVmFsdWUgPSBcIlwiO1xuICBjb25zdCBhcHBlbmRUb1BlbmRpbmdGaXhlZFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgcGVuZGluZ0ZpeGVkVmFsdWUgKz0gdmFsdWU7XG4gIH07XG4gIGNvbnN0IG1heWJlQWRkUGFydEZyb21QZW5kaW5nRml4ZWRWYWx1ZSA9ICgpID0+IHtcbiAgICBpZiAoIXBlbmRpbmdGaXhlZFZhbHVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChuZXcgUGFydCgzIC8qIGtGaXhlZCAqLywgXCJcIiwgXCJcIiwgZW5jb2RlUGFydChwZW5kaW5nRml4ZWRWYWx1ZSksIFwiXCIsIDMgLyoga05vbmUgKi8pKTtcbiAgICBwZW5kaW5nRml4ZWRWYWx1ZSA9IFwiXCI7XG4gIH07XG4gIGNvbnN0IGFkZFBhcnQgPSAocHJlZml4LCBuYW1lVG9rZW4sIHJlZ2V4T3JXaWxkY2FyZFRva2VuLCBzdWZmaXgsIG1vZGlmaWVyVG9rZW4pID0+IHtcbiAgICBsZXQgbW9kaWZpZXIgPSAzIC8qIGtOb25lICovO1xuICAgIHN3aXRjaCAobW9kaWZpZXJUb2tlbikge1xuICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgbW9kaWZpZXIgPSAxIC8qIGtPcHRpb25hbCAqLztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiKlwiOlxuICAgICAgICBtb2RpZmllciA9IDAgLyoga1plcm9Pck1vcmUgKi87XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgbW9kaWZpZXIgPSAyIC8qIGtPbmVPck1vcmUgKi87XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW5hbWVUb2tlbiAmJiAhcmVnZXhPcldpbGRjYXJkVG9rZW4gJiYgbW9kaWZpZXIgPT09IDMgLyoga05vbmUgKi8pIHtcbiAgICAgIGFwcGVuZFRvUGVuZGluZ0ZpeGVkVmFsdWUocHJlZml4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF5YmVBZGRQYXJ0RnJvbVBlbmRpbmdGaXhlZFZhbHVlKCk7XG4gICAgaWYgKCFuYW1lVG9rZW4gJiYgIXJlZ2V4T3JXaWxkY2FyZFRva2VuKSB7XG4gICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChuZXcgUGFydCgzIC8qIGtGaXhlZCAqLywgXCJcIiwgXCJcIiwgZW5jb2RlUGFydChwcmVmaXgpLCBcIlwiLCBtb2RpZmllcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVnZXhWYWx1ZTtcbiAgICBpZiAoIXJlZ2V4T3JXaWxkY2FyZFRva2VuKSB7XG4gICAgICByZWdleFZhbHVlID0gc2VnbWVudFdpbGRjYXJkUmVnZXg7XG4gICAgfSBlbHNlIGlmIChyZWdleE9yV2lsZGNhcmRUb2tlbiA9PT0gXCIqXCIpIHtcbiAgICAgIHJlZ2V4VmFsdWUgPSBrRnVsbFdpbGRjYXJkUmVnZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2V4VmFsdWUgPSByZWdleE9yV2lsZGNhcmRUb2tlbjtcbiAgICB9XG4gICAgbGV0IHR5cGUgPSAyIC8qIGtSZWdleCAqLztcbiAgICBpZiAocmVnZXhWYWx1ZSA9PT0gc2VnbWVudFdpbGRjYXJkUmVnZXgpIHtcbiAgICAgIHR5cGUgPSAxIC8qIGtTZWdtZW50V2lsZGNhcmQgKi87XG4gICAgICByZWdleFZhbHVlID0gXCJcIjtcbiAgICB9IGVsc2UgaWYgKHJlZ2V4VmFsdWUgPT09IGtGdWxsV2lsZGNhcmRSZWdleCkge1xuICAgICAgdHlwZSA9IDAgLyoga0Z1bGxXaWxkY2FyZCAqLztcbiAgICAgIHJlZ2V4VmFsdWUgPSBcIlwiO1xuICAgIH1cbiAgICBsZXQgbmFtZTtcbiAgICBpZiAobmFtZVRva2VuKSB7XG4gICAgICBuYW1lID0gbmFtZVRva2VuO1xuICAgIH0gZWxzZSBpZiAocmVnZXhPcldpbGRjYXJkVG9rZW4pIHtcbiAgICAgIG5hbWUgPSBrZXkrKztcbiAgICB9XG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEdXBsaWNhdGUgbmFtZSAnJHtuYW1lfScuYCk7XG4gICAgfVxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xuICAgIHJlc3VsdC5wdXNoKG5ldyBQYXJ0KHR5cGUsIG5hbWUsIGVuY29kZVBhcnQocHJlZml4KSwgcmVnZXhWYWx1ZSwgZW5jb2RlUGFydChzdWZmaXgpLCBtb2RpZmllcikpO1xuICB9O1xuICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGFyVG9rZW4gPSB0cnlDb25zdW1lKFwiQ0hBUlwiKTtcbiAgICBjb25zdCBuYW1lVG9rZW4gPSB0cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICBsZXQgcmVnZXhPcldpbGRjYXJkVG9rZW4gPSB0cnlDb25zdW1lKFwiUkVHRVhcIik7XG4gICAgaWYgKCFuYW1lVG9rZW4gJiYgIXJlZ2V4T3JXaWxkY2FyZFRva2VuKSB7XG4gICAgICByZWdleE9yV2lsZGNhcmRUb2tlbiA9IHRyeUNvbnN1bWUoXCJBU1RFUklTS1wiKTtcbiAgICB9XG4gICAgaWYgKG5hbWVUb2tlbiB8fCByZWdleE9yV2lsZGNhcmRUb2tlbikge1xuICAgICAgbGV0IHByZWZpeCA9IGNoYXJUb2tlbiA/PyBcIlwiO1xuICAgICAgaWYgKG9wdGlvbnMucHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICBhcHBlbmRUb1BlbmRpbmdGaXhlZFZhbHVlKHByZWZpeCk7XG4gICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICB9XG4gICAgICBtYXliZUFkZFBhcnRGcm9tUGVuZGluZ0ZpeGVkVmFsdWUoKTtcbiAgICAgIGxldCBtb2RpZmllclRva2VuID0gdHJ5Q29uc3VtZU1vZGlmaWVyKCk7XG4gICAgICBhZGRQYXJ0KHByZWZpeCwgbmFtZVRva2VuLCByZWdleE9yV2lsZGNhcmRUb2tlbiwgXCJcIiwgbW9kaWZpZXJUb2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjaGFyVG9rZW4gPz8gdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGFwcGVuZFRvUGVuZGluZ0ZpeGVkVmFsdWUodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9wZW5Ub2tlbiA9IHRyeUNvbnN1bWUoXCJPUEVOXCIpO1xuICAgIGlmIChvcGVuVG9rZW4pIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICBjb25zdCBuYW1lVG9rZW4yID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICBsZXQgcmVnZXhPcldpbGRjYXJkVG9rZW4yID0gdHJ5Q29uc3VtZShcIlJFR0VYXCIpO1xuICAgICAgaWYgKCFuYW1lVG9rZW4yICYmICFyZWdleE9yV2lsZGNhcmRUb2tlbjIpIHtcbiAgICAgICAgcmVnZXhPcldpbGRjYXJkVG9rZW4yID0gdHJ5Q29uc3VtZShcIkFTVEVSSVNLXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICBjb25zdCBtb2RpZmllclRva2VuID0gdHJ5Q29uc3VtZU1vZGlmaWVyKCk7XG4gICAgICBhZGRQYXJ0KHByZWZpeCwgbmFtZVRva2VuMiwgcmVnZXhPcldpbGRjYXJkVG9rZW4yLCBzdWZmaXgsIG1vZGlmaWVyVG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1heWJlQWRkUGFydEZyb21QZW5kaW5nRml4ZWRWYWx1ZSgpO1xuICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/XiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUNhc2UgPyBcInVpXCIgOiBcInVcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIG5hbWVzLCBvcHRpb25zKSB7XG4gIHJldHVybiBwYXJ0c1RvUmVnZXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBuYW1lcywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBtb2RpZmllclRvU3RyaW5nKG1vZGlmaWVyKSB7XG4gIHN3aXRjaCAobW9kaWZpZXIpIHtcbiAgICBjYXNlIDAgLyoga1plcm9Pck1vcmUgKi86XG4gICAgICByZXR1cm4gXCIqXCI7XG4gICAgY2FzZSAxIC8qIGtPcHRpb25hbCAqLzpcbiAgICAgIHJldHVybiBcIj9cIjtcbiAgICBjYXNlIDIgLyoga09uZU9yTW9yZSAqLzpcbiAgICAgIHJldHVybiBcIitcIjtcbiAgICBjYXNlIDMgLyoga05vbmUgKi86XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gcGFydHNUb1JlZ2V4cChwYXJ0cywgbmFtZXMsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLmRlbGltaXRlciA/PyAob3B0aW9ucy5kZWxpbWl0ZXIgPSBcIi8jP1wiKTtcbiAgb3B0aW9ucy5wcmVmaXhlcyA/PyAob3B0aW9ucy5wcmVmaXhlcyA9IFwiLi9cIik7XG4gIG9wdGlvbnMuc2Vuc2l0aXZlID8/IChvcHRpb25zLnNlbnNpdGl2ZSA9IGZhbHNlKTtcbiAgb3B0aW9ucy5zdHJpY3QgPz8gKG9wdGlvbnMuc3RyaWN0ID0gZmFsc2UpO1xuICBvcHRpb25zLmVuZCA/PyAob3B0aW9ucy5lbmQgPSB0cnVlKTtcbiAgb3B0aW9ucy5zdGFydCA/PyAob3B0aW9ucy5zdGFydCA9IHRydWUpO1xuICBvcHRpb25zLmVuZHNXaXRoID0gXCJcIjtcbiAgbGV0IHJlc3VsdCA9IG9wdGlvbnMuc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IDMgLyoga0ZpeGVkICovKSB7XG4gICAgICBpZiAocGFydC5tb2RpZmllciA9PT0gMyAvKiBrTm9uZSAqLykge1xuICAgICAgICByZXN1bHQgKz0gZXNjYXBlU3RyaW5nKHBhcnQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoPzoke2VzY2FwZVN0cmluZyhwYXJ0LnZhbHVlKX0pJHttb2RpZmllclRvU3RyaW5nKHBhcnQubW9kaWZpZXIpfWA7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5hbWVzKVxuICAgICAgbmFtZXMucHVzaChwYXJ0Lm5hbWUpO1xuICAgIGNvbnN0IHNlZ21lbnRXaWxkY2FyZFJlZ2V4ID0gYFteJHtlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIpfV0rP2A7XG4gICAgbGV0IHJlZ2V4VmFsdWUgPSBwYXJ0LnZhbHVlO1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IDEgLyoga1NlZ21lbnRXaWxkY2FyZCAqLylcbiAgICAgIHJlZ2V4VmFsdWUgPSBzZWdtZW50V2lsZGNhcmRSZWdleDtcbiAgICBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IDAgLyoga0Z1bGxXaWxkY2FyZCAqLylcbiAgICAgIHJlZ2V4VmFsdWUgPSBrRnVsbFdpbGRjYXJkUmVnZXg7XG4gICAgaWYgKCFwYXJ0LnByZWZpeC5sZW5ndGggJiYgIXBhcnQuc3VmZml4Lmxlbmd0aCkge1xuICAgICAgaWYgKHBhcnQubW9kaWZpZXIgPT09IDMgLyoga05vbmUgKi8gfHwgcGFydC5tb2RpZmllciA9PT0gMSAvKiBrT3B0aW9uYWwgKi8pIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHtyZWdleFZhbHVlfSkke21vZGlmaWVyVG9TdHJpbmcocGFydC5tb2RpZmllcil9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCg/OiR7cmVnZXhWYWx1ZX0pJHttb2RpZmllclRvU3RyaW5nKHBhcnQubW9kaWZpZXIpfSlgO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXJ0Lm1vZGlmaWVyID09PSAzIC8qIGtOb25lICovIHx8IHBhcnQubW9kaWZpZXIgPT09IDEgLyoga09wdGlvbmFsICovKSB7XG4gICAgICByZXN1bHQgKz0gYCg/OiR7ZXNjYXBlU3RyaW5nKHBhcnQucHJlZml4KX0oJHtyZWdleFZhbHVlfSkke2VzY2FwZVN0cmluZyhwYXJ0LnN1ZmZpeCl9KWA7XG4gICAgICByZXN1bHQgKz0gbW9kaWZpZXJUb1N0cmluZyhwYXJ0Lm1vZGlmaWVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCg/OiR7ZXNjYXBlU3RyaW5nKHBhcnQucHJlZml4KX1gO1xuICAgIHJlc3VsdCArPSBgKCg/OiR7cmVnZXhWYWx1ZX0pKD86YDtcbiAgICByZXN1bHQgKz0gZXNjYXBlU3RyaW5nKHBhcnQuc3VmZml4KTtcbiAgICByZXN1bHQgKz0gZXNjYXBlU3RyaW5nKHBhcnQucHJlZml4KTtcbiAgICByZXN1bHQgKz0gYCg/OiR7cmVnZXhWYWx1ZX0pKSopJHtlc2NhcGVTdHJpbmcocGFydC5zdWZmaXgpfSlgO1xuICAgIGlmIChwYXJ0Lm1vZGlmaWVyID09PSAwIC8qIGtaZXJvT3JNb3JlICovKSB7XG4gICAgICByZXN1bHQgKz0gXCI/XCI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVuZHNXaXRoID0gYFske2VzY2FwZVN0cmluZyhvcHRpb25zLmVuZHNXaXRoKX1dfCRgO1xuICBjb25zdCBkZWxpbWl0ZXIgPSBgWyR7ZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyKX1dYDtcbiAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCkge1xuICAgICAgcmVzdWx0ICs9IGAke2RlbGltaXRlcn0/YDtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmVuZHNXaXRoLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ICs9IFwiJFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gYCg/PSR7ZW5kc1dpdGh9KWA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJlc3VsdCwgZmxhZ3Mob3B0aW9ucykpO1xuICB9XG4gIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICByZXN1bHQgKz0gYCg/OiR7ZGVsaW1pdGVyfSg/PSR7ZW5kc1dpdGh9KSk/YDtcbiAgfVxuICBsZXQgaXNFbmREZWxpbWl0ZWQgPSBmYWxzZTtcbiAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RQYXJ0LnR5cGUgPT09IDMgLyoga0ZpeGVkICovICYmIGxhc3RQYXJ0Lm1vZGlmaWVyID09PSAzIC8qIGtOb25lICovKSB7XG4gICAgICBpc0VuZERlbGltaXRlZCA9IG9wdGlvbnMuZGVsaW1pdGVyLmluZGV4T2YobGFzdFBhcnQpID4gLTE7XG4gICAgfVxuICB9XG4gIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICByZXN1bHQgKz0gYCg/PSR7ZGVsaW1pdGVyfXwke2VuZHNXaXRofSlgO1xuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlc3VsdCwgZmxhZ3Mob3B0aW9ucykpO1xufVxuXG4vLyBzcmMvdXJsLXV0aWxzLnRzXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBkZWxpbWl0ZXI6IFwiXCIsXG4gIHByZWZpeGVzOiBcIlwiLFxuICBzZW5zaXRpdmU6IHRydWUsXG4gIHN0cmljdDogdHJ1ZVxufTtcbnZhciBIT1NUTkFNRV9PUFRJT05TID0ge1xuICBkZWxpbWl0ZXI6IFwiLlwiLFxuICBwcmVmaXhlczogXCJcIixcbiAgc2Vuc2l0aXZlOiB0cnVlLFxuICBzdHJpY3Q6IHRydWVcbn07XG52YXIgUEFUSE5BTUVfT1BUSU9OUyA9IHtcbiAgZGVsaW1pdGVyOiBcIi9cIixcbiAgcHJlZml4ZXM6IFwiL1wiLFxuICBzZW5zaXRpdmU6IHRydWUsXG4gIHN0cmljdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRobmFtZShwYXRobmFtZSwgaXNQYXR0ZXJuKSB7XG4gIGlmICghcGF0aG5hbWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwYXRobmFtZVswXSA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWlzUGF0dGVybikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGF0aG5hbWUubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKHBhdGhuYW1lWzBdID09IFwiXFxcXFwiIHx8IHBhdGhuYW1lWzBdID09IFwie1wiKSAmJiBwYXRobmFtZVsxXSA9PSBcIi9cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1heWJlU3RyaXBQcmVmaXgodmFsdWUsIHByZWZpeCkge1xuICBpZiAodmFsdWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1heWJlU3RyaXBTdWZmaXgodmFsdWUsIHN1ZmZpeCkge1xuICBpZiAodmFsdWUuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoMCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdHJlYXRBc0lQdjZIb3N0bmFtZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlWzBdID09PSBcIltcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgodmFsdWVbMF0gPT09IFwiXFxcXFwiIHx8IHZhbHVlWzBdID09PSBcIntcIikgJiYgdmFsdWVbMV0gPT09IFwiW1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFNQRUNJQUxfU0NIRU1FUyA9IFtcbiAgXCJmdHBcIixcbiAgXCJmaWxlXCIsXG4gIFwiaHR0cFwiLFxuICBcImh0dHBzXCIsXG4gIFwid3NcIixcbiAgXCJ3c3NcIlxuXTtcbmZ1bmN0aW9uIGlzU3BlY2lhbFNjaGVtZShwcm90b2NvbF9yZWdleHApIHtcbiAgaWYgKCFwcm90b2NvbF9yZWdleHApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IHNjaGVtZSBvZiBTUEVDSUFMX1NDSEVNRVMpIHtcbiAgICBpZiAocHJvdG9jb2xfcmVnZXhwLnRlc3Qoc2NoZW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUhhc2goaGFzaCwgaXNQYXR0ZXJuKSB7XG4gIGhhc2ggPSBtYXliZVN0cmlwUHJlZml4KGhhc2gsIFwiI1wiKTtcbiAgaWYgKGlzUGF0dGVybiB8fCBoYXNoID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5oYXNoID0gaGFzaDtcbiAgcmV0dXJuIHVybC5oYXNoID8gdXJsLmhhc2guc3Vic3RyaW5nKDEsIHVybC5oYXNoLmxlbmd0aCkgOiBcIlwiO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplU2VhcmNoKHNlYXJjaCwgaXNQYXR0ZXJuKSB7XG4gIHNlYXJjaCA9IG1heWJlU3RyaXBQcmVmaXgoc2VhcmNoLCBcIj9cIik7XG4gIGlmIChpc1BhdHRlcm4gfHwgc2VhcmNoID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHNlYXJjaDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtcbiAgdXJsLnNlYXJjaCA9IHNlYXJjaDtcbiAgcmV0dXJuIHVybC5zZWFyY2ggPyB1cmwuc2VhcmNoLnN1YnN0cmluZygxLCB1cmwuc2VhcmNoLmxlbmd0aCkgOiBcIlwiO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplSG9zdG5hbWUoaG9zdG5hbWUsIGlzUGF0dGVybikge1xuICBpZiAoaXNQYXR0ZXJuIHx8IGhvc3RuYW1lID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGhvc3RuYW1lO1xuICB9XG4gIGlmICh0cmVhdEFzSVB2Nkhvc3RuYW1lKGhvc3RuYW1lKSkge1xuICAgIHJldHVybiBpcHY2SG9zdG5hbWVFbmNvZGVDYWxsYmFjayhob3N0bmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhvc3RuYW1lRW5jb2RlQ2FsbGJhY2soaG9zdG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiBjYW5vbmljYWxpemVQYXNzd29yZChwYXNzd29yZCwgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc1BhdHRlcm4gfHwgcGFzc3dvcmQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gcGFzc3dvcmQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7XG4gIHVybC5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICByZXR1cm4gdXJsLnBhc3N3b3JkO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplVXNlcm5hbWUodXNlcm5hbWUsIGlzUGF0dGVybikge1xuICBpZiAoaXNQYXR0ZXJuIHx8IHVzZXJuYW1lID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVzZXJuYW1lO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgcmV0dXJuIHVybC51c2VybmFtZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVBhdGhuYW1lKHBhdGhuYW1lLCBwcm90b2NvbCwgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc1BhdHRlcm4gfHwgcGF0aG5hbWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gcGF0aG5hbWU7XG4gIH1cbiAgaWYgKHByb3RvY29sICYmICFTUEVDSUFMX1NDSEVNRVMuaW5jbHVkZXMocHJvdG9jb2wpKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b2NvbH06JHtwYXRobmFtZX1gKTtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lO1xuICB9XG4gIGNvbnN0IGxlYWRpbmdTbGFzaCA9IHBhdGhuYW1lWzBdID09IFwiL1wiO1xuICBwYXRobmFtZSA9IG5ldyBVUkwoXG4gICAgIWxlYWRpbmdTbGFzaCA/IFwiLy1cIiArIHBhdGhuYW1lIDogcGF0aG5hbWUsXG4gICAgXCJodHRwczovL2V4YW1wbGUuY29tXCJcbiAgKS5wYXRobmFtZTtcbiAgaWYgKCFsZWFkaW5nU2xhc2gpIHtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygyLCBwYXRobmFtZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVBvcnQocG9ydCwgcHJvdG9jb2wsIGlzUGF0dGVybikge1xuICBpZiAoZGVmYXVsdFBvcnRGb3JQcm90b2NvbChwcm90b2NvbCkgPT09IHBvcnQpIHtcbiAgICBwb3J0ID0gXCJcIjtcbiAgfVxuICBpZiAoaXNQYXR0ZXJuIHx8IHBvcnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gcG9ydDtcbiAgfVxuICByZXR1cm4gcG9ydEVuY29kZUNhbGxiYWNrKHBvcnQpO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsaXplUHJvdG9jb2wocHJvdG9jb2wsIGlzUGF0dGVybikge1xuICBwcm90b2NvbCA9IG1heWJlU3RyaXBTdWZmaXgocHJvdG9jb2wsIFwiOlwiKTtcbiAgaWYgKGlzUGF0dGVybiB8fCBwcm90b2NvbCA9PT0gXCJcIikge1xuICAgIHJldHVybiBwcm90b2NvbDtcbiAgfVxuICByZXR1cm4gcHJvdG9jb2xFbmNvZGVDYWxsYmFjayhwcm90b2NvbCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9ydEZvclByb3RvY29sKHByb3RvY29sKSB7XG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlIFwid3NcIjpcbiAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgcmV0dXJuIFwiODBcIjtcbiAgICBjYXNlIFwid3dzXCI6XG4gICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICByZXR1cm4gXCI0NDNcIjtcbiAgICBjYXNlIFwiZnRwXCI6XG4gICAgICByZXR1cm4gXCIyMVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKC9eWy0rLkEtWmEtejAtOV0qJC8udGVzdChpbnB1dCkpXG4gICAgcmV0dXJuIGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJvdG9jb2wgJyR7aW5wdXR9Jy5gKTtcbn1cbmZ1bmN0aW9uIHVzZXJuYW1lRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwudXNlcm5hbWUgPSBpbnB1dDtcbiAgcmV0dXJuIHVybC51c2VybmFtZTtcbn1cbmZ1bmN0aW9uIHBhc3N3b3JkRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwucGFzc3dvcmQgPSBpbnB1dDtcbiAgcmV0dXJuIHVybC5wYXNzd29yZDtcbn1cbmZ1bmN0aW9uIGhvc3RuYW1lRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGlmICgvW1xcdFxcblxcciAjJS86PD4/QFtcXF1eXFxcXHxdL2cudGVzdChpbnB1dCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGhvc3RuYW1lICcke2lucHV0fSdgKTtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtcbiAgdXJsLmhvc3RuYW1lID0gaW5wdXQ7XG4gIHJldHVybiB1cmwuaG9zdG5hbWU7XG59XG5mdW5jdGlvbiBpcHY2SG9zdG5hbWVFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKC9bXjAtOWEtZkEtRltcXF06XS9nLnRlc3QoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBJUHY2IGhvc3RuYW1lICcke2lucHV0fSdgKTtcbiAgfVxuICByZXR1cm4gaW5wdXQudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHBvcnRFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKC9eWzAtOV0qJC8udGVzdChpbnB1dCkgJiYgcGFyc2VJbnQoaW5wdXQpIDw9IDY1NTM1KSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcG9ydCAnJHtpbnB1dH0nLmApO1xufVxuZnVuY3Rpb24gc3RhbmRhcmRVUkxQYXRobmFtZUVuY29kZUNhbGxiYWNrKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtcbiAgdXJsLnBhdGhuYW1lID0gaW5wdXRbMF0gIT09IFwiL1wiID8gXCIvLVwiICsgaW5wdXQgOiBpbnB1dDtcbiAgaWYgKGlucHV0WzBdICE9PSBcIi9cIikge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUuc3Vic3RyaW5nKDIsIHVybC5wYXRobmFtZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiB1cmwucGF0aG5hbWU7XG59XG5mdW5jdGlvbiBwYXRoVVJMUGF0aG5hbWVFbmNvZGVDYWxsYmFjayhpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTChgZGF0YToke2lucHV0fWApO1xuICByZXR1cm4gdXJsLnBhdGhuYW1lO1xufVxuZnVuY3Rpb24gc2VhcmNoRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwuc2VhcmNoID0gaW5wdXQ7XG4gIHJldHVybiB1cmwuc2VhcmNoLnN1YnN0cmluZygxLCB1cmwuc2VhcmNoLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBoYXNoRW5jb2RlQ2FsbGJhY2soaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICB1cmwuaGFzaCA9IGlucHV0O1xuICByZXR1cm4gdXJsLmhhc2guc3Vic3RyaW5nKDEsIHVybC5oYXNoLmxlbmd0aCk7XG59XG5cbi8vIHNyYy91cmwtcGF0dGVybi1wYXJzZXIudHNcbnZhciBQYXJzZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgLy8gVGhlIGxpc3Qgb2YgYExleFRva2VuYHMgcHJvZHVjZWQgYnkgdGhlIHBhdGgtdG8tcmVnZXhwIGBsZXhlcigpYCBmdW5jdGlvblxuICAgIC8vIHdoZW4gcGFzc2VkIGBpbnB1dGAgd2l0aCBsZW5pZW50IG1vZGUgZW5hYmxlZC5cbiAgICB0aGlzLnRva2VuTGlzdCA9IFtdO1xuICAgIC8vIEFzIHdlIHBhcnNlIHRoZSBpbnB1dCBzdHJpbmcgd2UgcG9wdWxhdGUgYSBgVVJMUGF0dGVybkluaXRgIGRpY3Rpb25hcnlcbiAgICAvLyB3aXRoIGVhY2ggY29tcG9uZW50IHBhdHRlcm4uICBUaGlzIGlzIHRoZW4gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGUgcGFyc2UuXG4gICAgdGhpcy5pbnRlcm5hbFJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBgTGV4VG9rZW5gIGJlaW5nIGNvbnNpZGVyZWQuXG4gICAgdGhpcy50b2tlbkluZGV4ID0gMDtcbiAgICAvLyBUaGUgdmFsdWUgdG8gYWRkIHRvIGB0b2tlbkluZGV4YCBvbiBlYWNoIHR1cm4gdGhyb3VnaCB0aGUgcGFyc2UgbG9vcC5cbiAgICAvLyBXaGlsZSB0eXBpY2FsbHkgdGhpcyBpcyBgMWAsIGl0IGlzIGFsc28gc2V0IHRvIGAwYCBhdCB0aW1lcyBmb3IgdGhpbmdzXG4gICAgLy8gbGlrZSBzdGF0ZSB0cmFuc2l0aW9ucywgZXRjLiAgSXQgaXMgYXV0b21hdGljYWxseSByZXNldCBiYWNrIHRvIGAxYCBhdFxuICAgIC8vIHRoZSB0b3Agb2YgdGhlIHBhcnNlIGxvb3AuXG4gICAgdGhpcy50b2tlbkluY3JlbWVudCA9IDE7XG4gICAgLy8gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBgTGV4VG9rZW5gIHRvIGluY2x1ZGUgaW4gdGhlIGNvbXBvbmVudCBzdHJpbmcuXG4gICAgdGhpcy5jb21wb25lbnRTdGFydCA9IDA7XG4gICAgLy8gVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUuICBUaGlzIHNob3VsZCBvbmx5IGJlIGNoYW5nZWQgdmlhIGBjaGFuZ2VTdGF0ZSgpYFxuICAgIC8vIG9yIGByZXdpbmRBbmRTZXRTdGF0ZSgpYC5cbiAgICB0aGlzLnN0YXRlID0gMCAvKiBJTklUICovO1xuICAgIC8vIFRoZSBjdXJyZW50IG5lc3QgZGVwdGggb2YgYHsgfWAgcGF0dGVybiBncm91cGluZ3MuXG4gICAgdGhpcy5ncm91cERlcHRoID0gMDtcbiAgICAvLyBUaGUgY3VycmVudCBuZXN0aW5nIGRlcHRoIG9mIGBbIF1gIGluIGhvc3RuYW1lIHBhdHRlcm5zLlxuICAgIHRoaXMuaG9zdG5hbWVJUHY2QnJhY2tldERlcHRoID0gMDtcbiAgICAvLyBUcnVlIGlmIHdlIHNob3VsZCBhcHBseSBwYXJzZSBydWxlcyBhcyBpZiB0aGlzIGlzIGEgXCJzdGFuZGFyZFwiIFVSTC4gIElmXG4gICAgLy8gZmFsc2UgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgYSBcIm5vdCBhIGJhc2UgVVJMXCIuXG4gICAgdGhpcy5zaG91bGRUcmVhdEFzU3RhbmRhcmRVUkwgPSBmYWxzZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBwYXJzZSByZXN1bHQuICBUaGUgcmVzdWx0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZVxuICAvLyBgcGFyc2UoKWAgbWV0aG9kIGNvbXBsZXRlcy5cbiAgZ2V0IHJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlc3VsdDtcbiAgfVxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBpbnB1dCBzdHJpbmcgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIFBhcnNlciBvYmplY3QuXG4gIC8vIFRoaXMgbWV0aG9kIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlLiAgQW55IGVycm9ycyB3aWxsIGJlIHRocm93biBhcyBhblxuICAvLyBleGNlcHRpb24uICBSZXRyaWV2ZSB0aGUgcGFyc2UgcmVzdWx0IGJ5IGFjY2Vzc2luZyB0aGUgYFBhcnNlci5yZXN1bHRgXG4gIC8vIHByb3BlcnR5IGdldHRlci5cbiAgcGFyc2UoKSB7XG4gICAgdGhpcy50b2tlbkxpc3QgPSBsZXhlcihcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICAvKmxlbmllbnQ9Ki9cbiAgICAgIHRydWVcbiAgICApO1xuICAgIGZvciAoOyB0aGlzLnRva2VuSW5kZXggPCB0aGlzLnRva2VuTGlzdC5sZW5ndGg7IHRoaXMudG9rZW5JbmRleCArPSB0aGlzLnRva2VuSW5jcmVtZW50KSB7XG4gICAgICB0aGlzLnRva2VuSW5jcmVtZW50ID0gMTtcbiAgICAgIGlmICh0aGlzLnRva2VuTGlzdFt0aGlzLnRva2VuSW5kZXhdLnR5cGUgPT09IFwiRU5EXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDAgLyogSU5JVCAqLykge1xuICAgICAgICAgIHRoaXMucmV3aW5kKCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNIYXNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDkgLyogSEFTSCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2VhcmNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDggLyogU0VBUkNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQuaGFzaCA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDcgLyogUEFUSE5BTUUgKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5zZWFyY2ggPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5oYXNoID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBBVVRIT1JJVFkgKi8pIHtcbiAgICAgICAgICB0aGlzLnJld2luZEFuZFNldFN0YXRlKDUgLyogSE9TVE5BTUUgKi8pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgMTAgLyogRE9ORSAqLyxcbiAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ3JvdXBEZXB0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cENsb3NlKCkpIHtcbiAgICAgICAgICB0aGlzLmdyb3VwRGVwdGggLT0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNHcm91cE9wZW4oKSkge1xuICAgICAgICB0aGlzLmdyb3VwRGVwdGggKz0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIElOSVQgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNQcm90b2NvbFN1ZmZpeCgpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnVzZXJuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQucGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnBvcnQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5wYXRobmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnNlYXJjaCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0Lmhhc2ggPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5yZXdpbmRBbmRTZXRTdGF0ZSgxIC8qIFBST1RPQ09MICovKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBQUk9UT0NPTCAqLzpcbiAgICAgICAgICBpZiAodGhpcy5pc1Byb3RvY29sU3VmZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVNob3VsZFRyZWF0QXNTdGFuZGFyZFVSTCgpO1xuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IDcgLyogUEFUSE5BTUUgKi87XG4gICAgICAgICAgICBsZXQgc2tpcCA9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUcmVhdEFzU3RhbmRhcmRVUkwpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dElzQXV0aG9yaXR5U2xhc2hlcygpKSB7XG4gICAgICAgICAgICAgIG5leHRTdGF0ZSA9IDIgLyogQVVUSE9SSVRZICovO1xuICAgICAgICAgICAgICBza2lwID0gMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRUcmVhdEFzU3RhbmRhcmRVUkwpIHtcbiAgICAgICAgICAgICAgbmV4dFN0YXRlID0gMiAvKiBBVVRIT1JJVFkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG5leHRTdGF0ZSwgc2tpcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQVVUSE9SSVRZICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHlUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmV3aW5kQW5kU2V0U3RhdGUoMyAvKiBVU0VSTkFNRSAqLyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUGF0aG5hbWVTdGFydCgpIHx8IHRoaXMuaXNTZWFyY2hQcmVmaXgoKSB8fCB0aGlzLmlzSGFzaFByZWZpeCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJld2luZEFuZFNldFN0YXRlKDUgLyogSE9TVE5BTUUgKi8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIFVTRVJOQU1FICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzUGFzc3dvcmRQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNCAvKiBQQVNTV09SRCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSWRlbnRpdHlUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDUgLyogSE9TVE5BTUUgKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIFBBU1NXT1JEICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHlUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDUgLyogSE9TVE5BTUUgKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1IC8qIEhPU1ROQU1FICovOlxuICAgICAgICAgIGlmICh0aGlzLmlzSVB2Nk9wZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUlQdjZCcmFja2V0RGVwdGggKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJUHY2Q2xvc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZUlQdjZCcmFja2V0RGVwdGggLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaXNQb3J0UHJlZml4KCkgJiYgIXRoaXMuaG9zdG5hbWVJUHY2QnJhY2tldERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICA2IC8qIFBPUlQgKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1BhdGhuYW1lU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNyAvKiBQQVRITkFNRSAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2VhcmNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDggLyogU0VBUkNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIYXNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDkgLyogSEFTSCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYgLyogUE9SVCAqLzpcbiAgICAgICAgICBpZiAodGhpcy5pc1BhdGhuYW1lU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgNyAvKiBQQVRITkFNRSAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2VhcmNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDggLyogU0VBUkNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIYXNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDkgLyogSEFTSCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDcgLyogUEFUSE5BTUUgKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNTZWFyY2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOCAvKiBTRUFSQ0ggKi8sXG4gICAgICAgICAgICAgIC8qc2tpcD0qL1xuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hhc2hQcmVmaXgoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgOSAvKiBIQVNIICovLFxuICAgICAgICAgICAgICAvKnNraXA9Ki9cbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOCAvKiBTRUFSQ0ggKi86XG4gICAgICAgICAgaWYgKHRoaXMuaXNIYXNoUHJlZml4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgIDkgLyogSEFTSCAqLyxcbiAgICAgICAgICAgICAgLypza2lwPSovXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkgLyogSEFTSCAqLzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMCAvKiBET05FICovOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGFuZ2VTdGF0ZShuZXdTdGF0ZSwgc2tpcCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSAwIC8qIElOSVQgKi86XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIFBST1RPQ09MICovOlxuICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnByb3RvY29sID0gdGhpcy5tYWtlQ29tcG9uZW50U3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIEFVVEhPUklUWSAqLzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogVVNFUk5BTUUgKi86XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQudXNlcm5hbWUgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQgLyogUEFTU1dPUkQgKi86XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQucGFzc3dvcmQgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDUgLyogSE9TVE5BTUUgKi86XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXN1bHQuaG9zdG5hbWUgPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYgLyogUE9SVCAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5wb3J0ID0gdGhpcy5tYWtlQ29tcG9uZW50U3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3IC8qIFBBVEhOQU1FICovOlxuICAgICAgICB0aGlzLmludGVybmFsUmVzdWx0LnBhdGhuYW1lID0gdGhpcy5tYWtlQ29tcG9uZW50U3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4IC8qIFNFQVJDSCAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5zZWFyY2ggPSB0aGlzLm1ha2VDb21wb25lbnRTdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkgLyogSEFTSCAqLzpcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlc3VsdC5oYXNoID0gdGhpcy5tYWtlQ29tcG9uZW50U3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMCAvKiBET05FICovOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZVdpdGhvdXRTZXR0aW5nQ29tcG9uZW50KG5ld1N0YXRlLCBza2lwKTtcbiAgfVxuICBjaGFuZ2VTdGF0ZVdpdGhvdXRTZXR0aW5nQ29tcG9uZW50KG5ld1N0YXRlLCBza2lwKSB7XG4gICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHRoaXMuY29tcG9uZW50U3RhcnQgPSB0aGlzLnRva2VuSW5kZXggKyBza2lwO1xuICAgIHRoaXMudG9rZW5JbmRleCArPSBza2lwO1xuICAgIHRoaXMudG9rZW5JbmNyZW1lbnQgPSAwO1xuICB9XG4gIHJld2luZCgpIHtcbiAgICB0aGlzLnRva2VuSW5kZXggPSB0aGlzLmNvbXBvbmVudFN0YXJ0O1xuICAgIHRoaXMudG9rZW5JbmNyZW1lbnQgPSAwO1xuICB9XG4gIHJld2luZEFuZFNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgdGhpcy5yZXdpbmQoKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gIH1cbiAgc2FmZVRva2VuKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSB0aGlzLnRva2VuTGlzdC5sZW5ndGggLSBpbmRleDtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgdGhpcy50b2tlbkxpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkxpc3RbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbkxpc3RbdGhpcy50b2tlbkxpc3QubGVuZ3RoIC0gMV07XG4gIH1cbiAgaXNOb25TcGVjaWFsUGF0dGVybkNoYXIoaW5kZXgsIHZhbHVlKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnNhZmVUb2tlbihpbmRleCk7XG4gICAgcmV0dXJuIHRva2VuLnZhbHVlID09PSB2YWx1ZSAmJiAodG9rZW4udHlwZSA9PT0gXCJDSEFSXCIgfHwgdG9rZW4udHlwZSA9PT0gXCJFU0NBUEVEX0NIQVJcIiB8fCB0b2tlbi50eXBlID09PSBcIklOVkFMSURfQ0hBUlwiKTtcbiAgfVxuICBpc1Byb3RvY29sU3VmZml4KCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCI6XCIpO1xuICB9XG4gIG5leHRJc0F1dGhvcml0eVNsYXNoZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4ICsgMSwgXCIvXCIpICYmIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4ICsgMiwgXCIvXCIpO1xuICB9XG4gIGlzSWRlbnRpdHlUZXJtaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCJAXCIpO1xuICB9XG4gIGlzUGFzc3dvcmRQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIjpcIik7XG4gIH1cbiAgaXNQb3J0UHJlZml4KCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCI6XCIpO1xuICB9XG4gIGlzUGF0aG5hbWVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXgsIFwiL1wiKTtcbiAgfVxuICBpc1NlYXJjaFByZWZpeCgpIHtcbiAgICBpZiAodGhpcy5pc05vblNwZWNpYWxQYXR0ZXJuQ2hhcih0aGlzLnRva2VuSW5kZXgsIFwiP1wiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnRva2VuTGlzdFt0aGlzLnRva2VuSW5kZXhdLnZhbHVlICE9PSBcIj9cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1Rva2VuID0gdGhpcy5zYWZlVG9rZW4odGhpcy50b2tlbkluZGV4IC0gMSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVG9rZW4udHlwZSAhPT0gXCJOQU1FXCIgJiYgcHJldmlvdXNUb2tlbi50eXBlICE9PSBcIlJFR0VYXCIgJiYgcHJldmlvdXNUb2tlbi50eXBlICE9PSBcIkNMT1NFXCIgJiYgcHJldmlvdXNUb2tlbi50eXBlICE9PSBcIkFTVEVSSVNLXCI7XG4gIH1cbiAgaXNIYXNoUHJlZml4KCkge1xuICAgIHJldHVybiB0aGlzLmlzTm9uU3BlY2lhbFBhdHRlcm5DaGFyKHRoaXMudG9rZW5JbmRleCwgXCIjXCIpO1xuICB9XG4gIGlzR3JvdXBPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuTGlzdFt0aGlzLnRva2VuSW5kZXhdLnR5cGUgPT0gXCJPUEVOXCI7XG4gIH1cbiAgaXNHcm91cENsb3NlKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuTGlzdFt0aGlzLnRva2VuSW5kZXhdLnR5cGUgPT0gXCJDTE9TRVwiO1xuICB9XG4gIGlzSVB2Nk9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIltcIik7XG4gIH1cbiAgaXNJUHY2Q2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOb25TcGVjaWFsUGF0dGVybkNoYXIodGhpcy50b2tlbkluZGV4LCBcIl1cIik7XG4gIH1cbiAgbWFrZUNvbXBvbmVudFN0cmluZygpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5MaXN0W3RoaXMudG9rZW5JbmRleF07XG4gICAgY29uc3QgY29tcG9uZW50Q2hhclN0YXJ0ID0gdGhpcy5zYWZlVG9rZW4odGhpcy5jb21wb25lbnRTdGFydCkuaW5kZXg7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyaW5nKGNvbXBvbmVudENoYXJTdGFydCwgdG9rZW4uaW5kZXgpO1xuICB9XG4gIGNvbXB1dGVTaG91bGRUcmVhdEFzU3RhbmRhcmRVUkwoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgREVGQVVMVF9PUFRJT05TKTtcbiAgICBvcHRpb25zLmVuY29kZVBhcnQgPSBwcm90b2NvbEVuY29kZUNhbGxiYWNrO1xuICAgIGNvbnN0IHJlZ2V4cCA9IHN0cmluZ1RvUmVnZXhwKFxuICAgICAgdGhpcy5tYWtlQ29tcG9uZW50U3RyaW5nKCksXG4gICAgICAvKmtleXM9Ki9cbiAgICAgIHZvaWQgMCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuc2hvdWxkVHJlYXRBc1N0YW5kYXJkVVJMID0gaXNTcGVjaWFsU2NoZW1lKHJlZ2V4cCk7XG4gIH1cbn07XG5cbi8vIHNyYy91cmwtcGF0dGVybi50c1xudmFyIENPTVBPTkVOVFMgPSBbXG4gIFwicHJvdG9jb2xcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInBhc3N3b3JkXCIsXG4gIFwiaG9zdG5hbWVcIixcbiAgXCJwb3J0XCIsXG4gIFwicGF0aG5hbWVcIixcbiAgXCJzZWFyY2hcIixcbiAgXCJoYXNoXCJcbl07XG52YXIgREVGQVVMVF9QQVRURVJOID0gXCIqXCI7XG5mdW5jdGlvbiBleHRyYWN0VmFsdWVzKHVybCwgYmFzZVVSTCkge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLmApO1xuICB9XG4gIGNvbnN0IG8gPSBuZXcgVVJMKHVybCwgYmFzZVVSTCk7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG8ucHJvdG9jb2wuc3Vic3RyaW5nKDAsIG8ucHJvdG9jb2wubGVuZ3RoIC0gMSksXG4gICAgdXNlcm5hbWU6IG8udXNlcm5hbWUsXG4gICAgcGFzc3dvcmQ6IG8ucGFzc3dvcmQsXG4gICAgaG9zdG5hbWU6IG8uaG9zdG5hbWUsXG4gICAgcG9ydDogby5wb3J0LFxuICAgIHBhdGhuYW1lOiBvLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogby5zZWFyY2ggIT09IFwiXCIgPyBvLnNlYXJjaC5zdWJzdHJpbmcoMSwgby5zZWFyY2gubGVuZ3RoKSA6IHZvaWQgMCxcbiAgICBoYXNoOiBvLmhhc2ggIT09IFwiXCIgPyBvLmhhc2guc3Vic3RyaW5nKDEsIG8uaGFzaC5sZW5ndGgpIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzQmFzZVVSTFN0cmluZyhpbnB1dCwgaXNQYXR0ZXJuKSB7XG4gIGlmICghaXNQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBlc2NhcGVQYXR0ZXJuU3RyaW5nKGlucHV0KTtcbn1cbmZ1bmN0aW9uIGFwcGx5SW5pdChvLCBpbml0LCBpc1BhdHRlcm4pIHtcbiAgbGV0IGJhc2VVUkw7XG4gIGlmICh0eXBlb2YgaW5pdC5iYXNlVVJMID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJhc2VVUkwgPSBuZXcgVVJMKGluaXQuYmFzZVVSTCk7XG4gICAgICBvLnByb3RvY29sID0gcHJvY2Vzc0Jhc2VVUkxTdHJpbmcoYmFzZVVSTC5wcm90b2NvbC5zdWJzdHJpbmcoMCwgYmFzZVVSTC5wcm90b2NvbC5sZW5ndGggLSAxKSwgaXNQYXR0ZXJuKTtcbiAgICAgIG8udXNlcm5hbWUgPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLnVzZXJuYW1lLCBpc1BhdHRlcm4pO1xuICAgICAgby5wYXNzd29yZCA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwucGFzc3dvcmQsIGlzUGF0dGVybik7XG4gICAgICBvLmhvc3RuYW1lID0gcHJvY2Vzc0Jhc2VVUkxTdHJpbmcoYmFzZVVSTC5ob3N0bmFtZSwgaXNQYXR0ZXJuKTtcbiAgICAgIG8ucG9ydCA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwucG9ydCwgaXNQYXR0ZXJuKTtcbiAgICAgIG8ucGF0aG5hbWUgPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLnBhdGhuYW1lLCBpc1BhdHRlcm4pO1xuICAgICAgby5zZWFyY2ggPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLnNlYXJjaC5zdWJzdHJpbmcoMSwgYmFzZVVSTC5zZWFyY2gubGVuZ3RoKSwgaXNQYXR0ZXJuKTtcbiAgICAgIG8uaGFzaCA9IHByb2Nlc3NCYXNlVVJMU3RyaW5nKGJhc2VVUkwuaGFzaC5zdWJzdHJpbmcoMSwgYmFzZVVSTC5oYXNoLmxlbmd0aCksIGlzUGF0dGVybik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGJhc2VVUkwgJyR7aW5pdC5iYXNlVVJMfScuYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgaW5pdC5wcm90b2NvbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8ucHJvdG9jb2wgPSBjYW5vbmljYWxpemVQcm90b2NvbChpbml0LnByb3RvY29sLCBpc1BhdHRlcm4pO1xuICB9XG4gIGlmICh0eXBlb2YgaW5pdC51c2VybmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8udXNlcm5hbWUgPSBjYW5vbmljYWxpemVVc2VybmFtZShpbml0LnVzZXJuYW1lLCBpc1BhdHRlcm4pO1xuICB9XG4gIGlmICh0eXBlb2YgaW5pdC5wYXNzd29yZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8ucGFzc3dvcmQgPSBjYW5vbmljYWxpemVQYXNzd29yZChpbml0LnBhc3N3b3JkLCBpc1BhdHRlcm4pO1xuICB9XG4gIGlmICh0eXBlb2YgaW5pdC5ob3N0bmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8uaG9zdG5hbWUgPSBjYW5vbmljYWxpemVIb3N0bmFtZShpbml0Lmhvc3RuYW1lLCBpc1BhdHRlcm4pO1xuICB9XG4gIGlmICh0eXBlb2YgaW5pdC5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5wb3J0ID0gY2Fub25pY2FsaXplUG9ydChpbml0LnBvcnQsIG8ucHJvdG9jb2wsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0LnBhdGhuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5wYXRobmFtZSA9IGluaXQucGF0aG5hbWU7XG4gICAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVQYXRobmFtZShvLnBhdGhuYW1lLCBpc1BhdHRlcm4pKSB7XG4gICAgICBjb25zdCBzbGFzaEluZGV4ID0gYmFzZVVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICBpZiAoc2xhc2hJbmRleCA+PSAwKSB7XG4gICAgICAgIG8ucGF0aG5hbWUgPSBwcm9jZXNzQmFzZVVSTFN0cmluZyhiYXNlVVJMLnBhdGhuYW1lLnN1YnN0cmluZygwLCBzbGFzaEluZGV4ICsgMSksIGlzUGF0dGVybikgKyBvLnBhdGhuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBvLnBhdGhuYW1lID0gY2Fub25pY2FsaXplUGF0aG5hbWUoby5wYXRobmFtZSwgby5wcm90b2NvbCwgaXNQYXR0ZXJuKTtcbiAgfVxuICBpZiAodHlwZW9mIGluaXQuc2VhcmNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgby5zZWFyY2ggPSBjYW5vbmljYWxpemVTZWFyY2goaW5pdC5zZWFyY2gsIGlzUGF0dGVybik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbml0Lmhhc2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICBvLmhhc2ggPSBjYW5vbmljYWxpemVIYXNoKGluaXQuaGFzaCwgaXNQYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGVzY2FwZVBhdHRlcm5TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhbKyo/Ont9KClcXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdleHBTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhbLisqP14ke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbmZ1bmN0aW9uIHBhcnRzVG9QYXR0ZXJuKHBhcnRzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMuZGVsaW1pdGVyID8/IChvcHRpb25zLmRlbGltaXRlciA9IFwiLyM/XCIpO1xuICBvcHRpb25zLnByZWZpeGVzID8/IChvcHRpb25zLnByZWZpeGVzID0gXCIuL1wiKTtcbiAgb3B0aW9ucy5zZW5zaXRpdmUgPz8gKG9wdGlvbnMuc2Vuc2l0aXZlID0gZmFsc2UpO1xuICBvcHRpb25zLnN0cmljdCA/PyAob3B0aW9ucy5zdHJpY3QgPSBmYWxzZSk7XG4gIG9wdGlvbnMuZW5kID8/IChvcHRpb25zLmVuZCA9IHRydWUpO1xuICBvcHRpb25zLnN0YXJ0ID8/IChvcHRpb25zLnN0YXJ0ID0gdHJ1ZSk7XG4gIG9wdGlvbnMuZW5kc1dpdGggPSBcIlwiO1xuICBjb25zdCBrRnVsbFdpbGRjYXJkUmVnZXgyID0gXCIuKlwiO1xuICBjb25zdCBzZWdtZW50V2lsZGNhcmRSZWdleCA9IGBbXiR7ZXNjYXBlUmVnZXhwU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyKX1dKz9gO1xuICBjb25zdCByZWdleElkZW50aWZpZXJQYXJ0MiA9IC9bJF9cXHUyMDBDXFx1MjAwRFxccHtJRF9Db250aW51ZX1dL3U7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IDMgLyoga0ZpeGVkICovKSB7XG4gICAgICBpZiAocGFydC5tb2RpZmllciA9PT0gMyAvKiBrTm9uZSAqLykge1xuICAgICAgICByZXN1bHQgKz0gZXNjYXBlUGF0dGVyblN0cmluZyhwYXJ0LnZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gYHske2VzY2FwZVBhdHRlcm5TdHJpbmcocGFydC52YWx1ZSl9fSR7bW9kaWZpZXJUb1N0cmluZyhwYXJ0Lm1vZGlmaWVyKX1gO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbU5hbWUgPSBwYXJ0Lmhhc0N1c3RvbU5hbWUoKTtcbiAgICBsZXQgbmVlZHNHcm91cGluZyA9ICEhcGFydC5zdWZmaXgubGVuZ3RoIHx8ICEhcGFydC5wcmVmaXgubGVuZ3RoICYmIChwYXJ0LnByZWZpeC5sZW5ndGggIT09IDEgfHwgIW9wdGlvbnMucHJlZml4ZXMuaW5jbHVkZXMocGFydC5wcmVmaXgpKTtcbiAgICBjb25zdCBsYXN0UGFydCA9IGkgPiAwID8gcGFydHNbaSAtIDFdIDogbnVsbDtcbiAgICBjb25zdCBuZXh0UGFydCA9IGkgPCBwYXJ0cy5sZW5ndGggLSAxID8gcGFydHNbaSArIDFdIDogbnVsbDtcbiAgICBpZiAoIW5lZWRzR3JvdXBpbmcgJiYgY3VzdG9tTmFtZSAmJiBwYXJ0LnR5cGUgPT09IDEgLyoga1NlZ21lbnRXaWxkY2FyZCAqLyAmJiBwYXJ0Lm1vZGlmaWVyID09PSAzIC8qIGtOb25lICovICYmIG5leHRQYXJ0ICYmICFuZXh0UGFydC5wcmVmaXgubGVuZ3RoICYmICFuZXh0UGFydC5zdWZmaXgubGVuZ3RoKSB7XG4gICAgICBpZiAobmV4dFBhcnQudHlwZSA9PT0gMyAvKiBrRml4ZWQgKi8pIHtcbiAgICAgICAgY29uc3QgY29kZSA9IG5leHRQYXJ0LnZhbHVlLmxlbmd0aCA+IDAgPyBuZXh0UGFydC52YWx1ZVswXSA6IFwiXCI7XG4gICAgICAgIG5lZWRzR3JvdXBpbmcgPSByZWdleElkZW50aWZpZXJQYXJ0Mi50ZXN0KGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVlZHNHcm91cGluZyA9ICFuZXh0UGFydC5oYXNDdXN0b21OYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbmVlZHNHcm91cGluZyAmJiAhcGFydC5wcmVmaXgubGVuZ3RoICYmIGxhc3RQYXJ0ICYmIGxhc3RQYXJ0LnR5cGUgPT09IDMgLyoga0ZpeGVkICovKSB7XG4gICAgICBjb25zdCBjb2RlID0gbGFzdFBhcnQudmFsdWVbbGFzdFBhcnQudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICBuZWVkc0dyb3VwaW5nID0gb3B0aW9ucy5wcmVmaXhlcy5pbmNsdWRlcyhjb2RlKTtcbiAgICB9XG4gICAgaWYgKG5lZWRzR3JvdXBpbmcpIHtcbiAgICAgIHJlc3VsdCArPSBcIntcIjtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGVzY2FwZVBhdHRlcm5TdHJpbmcocGFydC5wcmVmaXgpO1xuICAgIGlmIChjdXN0b21OYW1lKSB7XG4gICAgICByZXN1bHQgKz0gYDoke3BhcnQubmFtZX1gO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSAyIC8qIGtSZWdleCAqLykge1xuICAgICAgcmVzdWx0ICs9IGAoJHtwYXJ0LnZhbHVlfSlgO1xuICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSAxIC8qIGtTZWdtZW50V2lsZGNhcmQgKi8pIHtcbiAgICAgIGlmICghY3VzdG9tTmFtZSkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3NlZ21lbnRXaWxkY2FyZFJlZ2V4fSlgO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSAwIC8qIGtGdWxsV2lsZGNhcmQgKi8pIHtcbiAgICAgIGlmICghY3VzdG9tTmFtZSAmJiAoIWxhc3RQYXJ0IHx8IGxhc3RQYXJ0LnR5cGUgPT09IDMgLyoga0ZpeGVkICovIHx8IGxhc3RQYXJ0Lm1vZGlmaWVyICE9PSAzIC8qIGtOb25lICovIHx8IG5lZWRzR3JvdXBpbmcgfHwgcGFydC5wcmVmaXggIT09IFwiXCIpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIipcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7a0Z1bGxXaWxkY2FyZFJlZ2V4Mn0pYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gMSAvKiBrU2VnbWVudFdpbGRjYXJkICovICYmIGN1c3RvbU5hbWUgJiYgISFwYXJ0LnN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgIGlmIChyZWdleElkZW50aWZpZXJQYXJ0Mi50ZXN0KHBhcnQuc3VmZml4WzBdKSkge1xuICAgICAgICByZXN1bHQgKz0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCArPSBlc2NhcGVQYXR0ZXJuU3RyaW5nKHBhcnQuc3VmZml4KTtcbiAgICBpZiAobmVlZHNHcm91cGluZykge1xuICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgIH1cbiAgICBpZiAocGFydC5tb2RpZmllciAhPT0gMyAvKiBrTm9uZSAqLykge1xuICAgICAgcmVzdWx0ICs9IG1vZGlmaWVyVG9TdHJpbmcocGFydC5tb2RpZmllcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgVVJMUGF0dGVybiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5pdCA9IHt9LCBiYXNlVVJMT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5yZWdleHAgPSB7fTtcbiAgICB0aGlzLm5hbWVzID0ge307XG4gICAgdGhpcy5jb21wb25lbnRfcGF0dGVybiA9IHt9O1xuICAgIHRoaXMucGFydHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgbGV0IGJhc2VVUkwgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGJhc2VVUkxPck9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYmFzZVVSTCA9IGJhc2VVUkxPck9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gYmFzZVVSTE9yT3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGluaXQpO1xuICAgICAgICBwYXJzZXIucGFyc2UoKTtcbiAgICAgICAgaW5pdCA9IHBhcnNlci5yZXN1bHQ7XG4gICAgICAgIGlmIChiYXNlVVJMID09PSB2b2lkIDAgJiYgdHlwZW9mIGluaXQucHJvdG9jb2wgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIGJhc2UgVVJMIG11c3QgYmUgcHJvdmlkZWQgZm9yIGEgcmVsYXRpdmUgY29uc3RydWN0b3Igc3RyaW5nLmApO1xuICAgICAgICB9XG4gICAgICAgIGluaXQuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWluaXQgfHwgdHlwZW9mIGluaXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJyBhbmQgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVVSTCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgaWdub3JlQ2FzZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlnbm9yZUNhc2VPcHRpb25zID0geyBpZ25vcmVDYXNlOiBvcHRpb25zLmlnbm9yZUNhc2UgPT09IHRydWUgfTtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICBwYXRobmFtZTogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICBwcm90b2NvbDogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICB1c2VybmFtZTogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICBwYXNzd29yZDogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICBob3N0bmFtZTogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICBwb3J0OiBERUZBVUxUX1BBVFRFUk4sXG4gICAgICAgIHNlYXJjaDogREVGQVVMVF9QQVRURVJOLFxuICAgICAgICBoYXNoOiBERUZBVUxUX1BBVFRFUk5cbiAgICAgIH07XG4gICAgICB0aGlzLnBhdHRlcm4gPSBhcHBseUluaXQoZGVmYXVsdHMsIGluaXQsIHRydWUpO1xuICAgICAgaWYgKGRlZmF1bHRQb3J0Rm9yUHJvdG9jb2wodGhpcy5wYXR0ZXJuLnByb3RvY29sKSA9PT0gdGhpcy5wYXR0ZXJuLnBvcnQpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuLnBvcnQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgbGV0IGNvbXBvbmVudDtcbiAgICAgIGZvciAoY29tcG9uZW50IG9mIENPTVBPTkVOVFMpIHtcbiAgICAgICAgaWYgKCEoY29tcG9uZW50IGluIHRoaXMucGF0dGVybikpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMyID0ge307XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5bY29tcG9uZW50XTtcbiAgICAgICAgdGhpcy5uYW1lc1tjb21wb25lbnRdID0gW107XG4gICAgICAgIHN3aXRjaCAoY29tcG9uZW50KSB7XG4gICAgICAgICAgY2FzZSBcInByb3RvY29sXCI6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBERUZBVUxUX09QVElPTlMpO1xuICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IHByb3RvY29sRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidXNlcm5hbWVcIjpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIERFRkFVTFRfT1BUSU9OUyk7XG4gICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gdXNlcm5hbWVFbmNvZGVDYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJwYXNzd29yZFwiOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zMiwgREVGQVVMVF9PUFRJT05TKTtcbiAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBwYXNzd29yZEVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhvc3RuYW1lXCI6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBIT1NUTkFNRV9PUFRJT05TKTtcbiAgICAgICAgICAgIGlmICh0cmVhdEFzSVB2Nkhvc3RuYW1lKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBpcHY2SG9zdG5hbWVFbmNvZGVDYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBob3N0bmFtZUVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBvcnRcIjpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uczIsIERFRkFVTFRfT1BUSU9OUyk7XG4gICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gcG9ydEVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBhdGhuYW1lXCI6XG4gICAgICAgICAgICBpZiAoaXNTcGVjaWFsU2NoZW1lKHRoaXMucmVnZXhwLnByb3RvY29sKSkge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBQQVRITkFNRV9PUFRJT05TLCBpZ25vcmVDYXNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgIG9wdGlvbnMyLmVuY29kZVBhcnQgPSBzdGFuZGFyZFVSTFBhdGhuYW1lRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMyLCBERUZBVUxUX09QVElPTlMsIGlnbm9yZUNhc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZW5jb2RlUGFydCA9IHBhdGhVUkxQYXRobmFtZUVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNlYXJjaFwiOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zMiwgREVGQVVMVF9PUFRJT05TLCBpZ25vcmVDYXNlT3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gc2VhcmNoRW5jb2RlQ2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaGFzaFwiOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zMiwgREVGQVVMVF9PUFRJT05TLCBpZ25vcmVDYXNlT3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zMi5lbmNvZGVQYXJ0ID0gaGFzaEVuY29kZUNhbGxiYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnBhcnRzW2NvbXBvbmVudF0gPSBwYXJzZShwYXR0ZXJuLCBvcHRpb25zMik7XG4gICAgICAgICAgdGhpcy5yZWdleHBbY29tcG9uZW50XSA9IHBhcnRzVG9SZWdleHAoXG4gICAgICAgICAgICB0aGlzLnBhcnRzW2NvbXBvbmVudF0sXG4gICAgICAgICAgICAvKiBvdXQgKi9cbiAgICAgICAgICAgIHRoaXMubmFtZXNbY29tcG9uZW50XSxcbiAgICAgICAgICAgIG9wdGlvbnMyXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudF9wYXR0ZXJuW2NvbXBvbmVudF0gPSBwYXJ0c1RvUGF0dGVybih0aGlzLnBhcnRzW2NvbXBvbmVudF0sIG9wdGlvbnMyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCAke2NvbXBvbmVudH0gcGF0dGVybiAnJHt0aGlzLnBhdHRlcm5bY29tcG9uZW50XX0nLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gY29uc3RydWN0ICdVUkxQYXR0ZXJuJzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgdGVzdChpbnB1dCA9IHt9LCBiYXNlVVJMKSB7XG4gICAgbGV0IHZhbHVlcyA9IHtcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcHJvdG9jb2w6IFwiXCIsXG4gICAgICB1c2VybmFtZTogXCJcIixcbiAgICAgIHBhc3N3b3JkOiBcIlwiLFxuICAgICAgaG9zdG5hbWU6IFwiXCIsXG4gICAgICBwb3J0OiBcIlwiLFxuICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgaGFzaDogXCJcIlxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIiAmJiBiYXNlVVJMKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJy5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YWx1ZXMgPSBhcHBseUluaXQodmFsdWVzLCBpbnB1dCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0gYXBwbHlJbml0KHZhbHVlcywgZXh0cmFjdFZhbHVlcyhpbnB1dCwgYmFzZVVSTCksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBmb3IgKGNvbXBvbmVudCBvZiBDT01QT05FTlRTKSB7XG4gICAgICBpZiAoIXRoaXMucmVnZXhwW2NvbXBvbmVudF0uZXhlYyh2YWx1ZXNbY29tcG9uZW50XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleGVjKGlucHV0ID0ge30sIGJhc2VVUkwpIHtcbiAgICBsZXQgdmFsdWVzID0ge1xuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwcm90b2NvbDogXCJcIixcbiAgICAgIHVzZXJuYW1lOiBcIlwiLFxuICAgICAgcGFzc3dvcmQ6IFwiXCIsXG4gICAgICBob3N0bmFtZTogXCJcIixcbiAgICAgIHBvcnQ6IFwiXCIsXG4gICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiICYmIGJhc2VVUkwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhbHVlcyA9IGFwcGx5SW5pdCh2YWx1ZXMsIGlucHV0LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSBhcHBseUluaXQodmFsdWVzLCBleHRyYWN0VmFsdWVzKGlucHV0LCBiYXNlVVJMKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBpZiAoYmFzZVVSTCkge1xuICAgICAgcmVzdWx0LmlucHV0cyA9IFtpbnB1dCwgYmFzZVVSTF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5pbnB1dHMgPSBbaW5wdXRdO1xuICAgIH1cbiAgICBsZXQgY29tcG9uZW50O1xuICAgIGZvciAoY29tcG9uZW50IG9mIENPTVBPTkVOVFMpIHtcbiAgICAgIGxldCBtYXRjaCA9IHRoaXMucmVnZXhwW2NvbXBvbmVudF0uZXhlYyh2YWx1ZXNbY29tcG9uZW50XSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IGdyb3VwcyA9IHt9O1xuICAgICAgZm9yIChsZXQgW2ksIG5hbWVdIG9mIHRoaXMubmFtZXNbY29tcG9uZW50XS5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBuYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRbY29tcG9uZW50XSA9IHtcbiAgICAgICAgaW5wdXQ6IHZhbHVlc1tjb21wb25lbnRdID8/IFwiXCIsXG4gICAgICAgIGdyb3Vwc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgY29tcGFyZUNvbXBvbmVudChjb21wb25lbnQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY29tcGFyZVBhcnQgPSAobGVmdDIsIHJpZ2h0MikgPT4ge1xuICAgICAgZm9yIChsZXQgYXR0ciBvZiBbXCJ0eXBlXCIsIFwibW9kaWZpZXJcIiwgXCJwcmVmaXhcIiwgXCJ2YWx1ZVwiLCBcInN1ZmZpeFwiXSkge1xuICAgICAgICBpZiAobGVmdDJbYXR0cl0gPCByaWdodDJbYXR0cl0pXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBlbHNlIGlmIChsZWZ0MlthdHRyXSA9PT0gcmlnaHQyW2F0dHJdKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5Rml4ZWRQYXJ0ID0gbmV3IFBhcnQoMyAvKiBrRml4ZWQgKi8sIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIDMgLyoga05vbmUgKi8pO1xuICAgIGNvbnN0IHdpbGRjYXJkT25seVBhcnQgPSBuZXcgUGFydCgwIC8qIGtGdWxsV2lsZGNhcmQgKi8sIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIDMgLyoga05vbmUgKi8pO1xuICAgIGNvbnN0IGNvbXBhcmVQYXJ0TGlzdCA9IChsZWZ0MiwgcmlnaHQyKSA9PiB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IE1hdGgubWluKGxlZnQyLmxlbmd0aCwgcmlnaHQyLmxlbmd0aCk7ICsraSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gY29tcGFyZVBhcnQobGVmdDJbaV0sIHJpZ2h0MltpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0Mi5sZW5ndGggPT09IHJpZ2h0Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFyZVBhcnQobGVmdDJbaV0gPz8gZW1wdHlGaXhlZFBhcnQsIHJpZ2h0MltpXSA/PyBlbXB0eUZpeGVkUGFydCk7XG4gICAgfTtcbiAgICBpZiAoIWxlZnQuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSAmJiAhcmlnaHQuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChsZWZ0LmNvbXBvbmVudF9wYXR0ZXJuW2NvbXBvbmVudF0gJiYgIXJpZ2h0LmNvbXBvbmVudF9wYXR0ZXJuW2NvbXBvbmVudF0pIHtcbiAgICAgIHJldHVybiBjb21wYXJlUGFydExpc3QobGVmdC5wYXJ0c1tjb21wb25lbnRdLCBbd2lsZGNhcmRPbmx5UGFydF0pO1xuICAgIH1cbiAgICBpZiAoIWxlZnQuY29tcG9uZW50X3BhdHRlcm5bY29tcG9uZW50XSAmJiByaWdodC5jb21wb25lbnRfcGF0dGVybltjb21wb25lbnRdKSB7XG4gICAgICByZXR1cm4gY29tcGFyZVBhcnRMaXN0KFt3aWxkY2FyZE9ubHlQYXJ0XSwgcmlnaHQucGFydHNbY29tcG9uZW50XSk7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlUGFydExpc3QobGVmdC5wYXJ0c1tjb21wb25lbnRdLCByaWdodC5wYXJ0c1tjb21wb25lbnRdKTtcbiAgfVxuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4ucHJvdG9jb2w7XG4gIH1cbiAgZ2V0IHVzZXJuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudF9wYXR0ZXJuLnVzZXJuYW1lO1xuICB9XG4gIGdldCBwYXNzd29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5wYXNzd29yZDtcbiAgfVxuICBnZXQgaG9zdG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4uaG9zdG5hbWU7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4ucG9ydDtcbiAgfVxuICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4ucGF0aG5hbWU7XG4gIH1cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRfcGF0dGVybi5zZWFyY2g7XG4gIH1cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50X3BhdHRlcm4uaGFzaDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/dist/urlpattern.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/index.cjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/index.cjs ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { URLPattern } = __webpack_require__(/*! ./dist/urlpattern.cjs */ \"(rsc)/./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/dist/urlpattern.cjs\");\n\nmodule.exports = { URLPattern };\n\nif (!globalThis.URLPattern) {\n  globalThis.URLPattern = URLPattern;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdXJscGF0dGVybi1wb2x5ZmlsbEA4LjAuMi9ub2RlX21vZHVsZXMvdXJscGF0dGVybi1wb2x5ZmlsbC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyx3SUFBdUI7O0FBRXRELG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hZDE5L0RvY3VtZW50cy9hbnNhcm0tZmlsZS1zZXJ2ZXIvbm9kZV9tb2R1bGVzLy5wbnBtL3VybHBhdHRlcm4tcG9seWZpbGxAOC4wLjIvbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgVVJMUGF0dGVybiB9ID0gcmVxdWlyZShcIi4vZGlzdC91cmxwYXR0ZXJuLmNqc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IFVSTFBhdHRlcm4gfTtcblxuaWYgKCFnbG9iYWxUaGlzLlVSTFBhdHRlcm4pIHtcbiAgZ2xvYmFsVGhpcy5VUkxQYXR0ZXJuID0gVVJMUGF0dGVybjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/urlpattern-polyfill@8.0.2/node_modules/urlpattern-polyfill/index.cjs\n");

/***/ })

};
;